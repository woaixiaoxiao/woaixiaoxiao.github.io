

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="no-referrer">
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cao Dong">
  <meta name="keywords" content="">
  
    <meta name="description" content="网络课程设计的课程项目，我选择了网络并发处理专题，并且深入研究了高并发环境中无锁队列，包括单读单写和多读多写两种设计方案">
<meta property="og:type" content="article">
<meta property="og:title" content="网络程序设计_课程项目">
<meta property="og:url" content="http://example.com/2023/12/21/lock-free-queue/index.html">
<meta property="og:site_name" content="dcao&#39;s blog">
<meta property="og:description" content="网络课程设计的课程项目，我选择了网络并发处理专题，并且深入研究了高并发环境中无锁队列，包括单读单写和多读多写两种设计方案">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-21T14:29:46.000Z">
<meta property="article:modified_time" content="2023-12-21T14:35:10.792Z">
<meta property="article:author" content="Cao Dong">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>网络程序设计_课程项目 - dcao&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CaoDong</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/scenery/p1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="网络程序设计_课程项目"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Cao Dong
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-21 22:29" pubdate>
          2023年12月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">网络程序设计_课程项目</h1>
            
            
              <div class="markdown-body">
                
                <ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">为什么需要无锁队列？</a></li>
<li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">无锁队列的实现（单读单写）</a><ul>
<li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">原子操作函数</a></li>
<li><a href="#yqueue_t%E7%9A%84chunk%E5%9D%97%E6%9C%BA%E5%88%B6">yqueue_t的chunk块机制</a><ul>
<li><a href="#chunk%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">chunk一次分配多个元素</a></li>
<li><a href="#chunk%E5%9D%97%E6%9C%BA%E5%88%B6-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">chunk块机制 局部性原理</a></li>
</ul>
</li>
<li><a href="#yqueue_t%E6%88%90%E5%91%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">yqueue_t成员和接口介绍</a><ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0yqueue_t">构造函数yqueue_t</a></li>
<li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0yqueue_t">析构函数~yqueue_t</a></li>
<li><a href="#frontback%E5%87%BD%E6%95%B0">front、back函数</a></li>
<li><a href="#push%E5%87%BD%E6%95%B0">push函数</a></li>
<li><a href="#unpush%E5%87%BD%E6%95%B0">unpush函数</a></li>
<li><a href="#pop">pop</a></li>
</ul>
</li>
<li><a href="#ypipe">ypipe</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96">如何写入和读取</a></li>
<li><a href="#%E8%AF%BB">读</a></li>
<li><a href="#wrfc%E8%AF%A6%E8%A7%A3">w,r,f,c详解</a><ul>
<li><a href="#ypipe_t">ypipe_t</a></li>
<li><a href="#write">write</a></li>
<li><a href="#flush">flush</a></li>
<li><a href="#read">read</a></li>
<li><a href="#check_read">check_read</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">整体思路梳理（单读单写）</a></li>
<li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99">无锁队列的实现（多读多写）</a><ul>
<li><a href="#arraylockfreequeue">ArrayLockFreeQueue</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">函数介绍</a><ul>
<li><a href="#%E5%8F%96%E4%BD%99%E5%87%BD%E6%95%B0">取余函数</a></li>
<li><a href="#%E5%85%A5%E9%98%9F%E5%87%BD%E6%95%B0enqueue">入队函数enqueue</a></li>
<li><a href="#%E5%87%BA%E9%98%9F%E5%87%BD%E6%95%B0dequeue">出队函数dequeue</a></li>
<li><a href="#%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">多读多写的机制总结</a></li>
</ul>
</li>
<li><a href="#yield%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">yield的重要性</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93%E8%87%B4%E8%B0%A2">总结&amp;致谢</a></li>
</ul>
<h1 id="为什么需要无锁队列？"><a href="#为什么需要无锁队列？" class="headerlink" title="为什么需要无锁队列？"></a>为什么需要无锁队列？</h1><p>传统的高并发场景中，是使用阻塞机制来避免并发带来的各种问题。但是传统的阻塞机制有以下两个问题</p>
<ol>
<li>阻塞意味着线程要进行切换，而线程的切换会带来cache的失效。而cache作为存储体系中最重要的一环，频繁地失效肯定会带来极大的开销和性能损失</li>
<li>如果一个线程要处理的事情非常多，但是它却经常为了某个资源而被阻塞住，那肯定会降低系统的吞吐量，带来很高的延迟</li>
</ol>
<h1 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h1><h2 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">atomic_ptr_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T *ptr_)</span></span>; <span class="hljs-comment">//⾮原⼦操作</span><br>    <span class="hljs-function">T *<span class="hljs-title">xchg</span><span class="hljs-params">(T *val_)</span></span>; <span class="hljs-comment">//原⼦操作，设置⼀个新的值，然后返回旧的值</span><br>    <span class="hljs-function">T *<span class="hljs-title">cas</span><span class="hljs-params">(T *cmp_, T *val_)</span></span>;<span class="hljs-comment">//原⼦操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li><code>set</code>是直接设置ptr的值</li>
<li><code>xchg</code>是设置ptr的值为val，并返回ptr设置之前的值</li>
<li><code>cas</code>是先比较<ol>
<li>若ptr和cmp相同，则设置ptr为val并返回ptr设置之前的值</li>
<li>若ptr和cmp不同，不设置ptr，直接返回ptr的值</li>
</ol>
</li>
</ol>
<h2 id="yqueue-t的chunk块机制"><a href="#yqueue-t的chunk块机制" class="headerlink" title="yqueue_t的chunk块机制"></a>yqueue_t的chunk块机制</h2><h3 id="chunk一次分配多个元素"><a href="#chunk一次分配多个元素" class="headerlink" title="chunk一次分配多个元素"></a>chunk一次分配多个元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunk_t</span> &#123;<br>   T values[N];<br>   <span class="hljs-type">chunk_t</span> *prev;<br>   <span class="hljs-type">chunk_t</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>一个chunk包含N个元素，因此可以减少分配内存的次数</p>
<p>会有一个spare_chunk的结构将空闲的chunk保存起来，需要的时候就可以直接拿出来用。在一个chunk空闲时，也不会直接删除，而是放入spare_chunk中</p>
<h3 id="chunk块机制-局部性原理"><a href="#chunk块机制-局部性原理" class="headerlink" title="chunk块机制 局部性原理"></a>chunk块机制 局部性原理</h3><p>利用局部性原理，可以将刚刚空闲的chunk放到spare_chunk中先保存着。如果后面马上就用上了，那就可以节省很多时间，而如果没用上，至少也可以省去重新分配动态内存的时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br></code></pre></td></tr></table></figure>

<p>执行pop的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N) <span class="hljs-comment">// 删除满一个chunk才回收chunk</span><br>    &#123;<br>        <span class="hljs-comment">// 将空闲chunk的指针暂时保留下来</span><br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        <span class="hljs-comment">// 由于空闲chunk是边界，因此更新边界</span><br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将空闲chunk和上一个空闲chunk交换一下，然后将上一个给free掉</span><br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行push的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先取到最后一个chunk和chunk内部的pos</span><br>    back_chunk = end_chunk;<br>    back_pos = end_pos; <br>    <span class="hljs-comment">// 如果最后一个chunk还有空间，则不需要做其他的操作</span><br>    <span class="hljs-keyword">if</span> (++end_pos != N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果最后一个chunk没有空间了，则需要扩容，首先考虑一下spare_chunk是否有空闲的</span><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果有空闲的chunk，直接建立双向连接即可</span><br>    <span class="hljs-keyword">if</span> (sc)<br>    &#123;<br>        end_chunk-&gt;next = sc;<br>        sc-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有空闲的，先分配，再建立连接关系</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        end_chunk-&gt;next = (<span class="hljs-type">chunk_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>)); <br>        <span class="hljs-built_in">alloc_assert</span>(end_chunk-&gt;next);<br>        end_chunk-&gt;next-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 最后修改end_chunk即可</span><br>    end_chunk = end_chunk-&gt;next;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="yqueue-t成员和接口介绍"><a href="#yqueue-t成员和接口介绍" class="headerlink" title="yqueue_t成员和接口介绍"></a>yqueue_t成员和接口介绍</h2><p>可以将这个队列看成是一个双向链表，链表的每个节点都是一个chunk，包含了N个元素，其他的概念和普通的队列差不多。</p>
<p>三种chunk的区别</p>
<ol>
<li>begin_chunk指向队列头部，从这取出元素</li>
<li>back_chunk指向队列的最后一个元素所在的chunk，back_pos指向最后一个元素</li>
<li>end_chunk指向队列最后一个chunk</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yqueue_t</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">        struct chunk_t &#123;</span><br>            T values[N];<br>            <span class="hljs-type">chunk_t</span> *prev;<br>            <span class="hljs-type">chunk_t</span> *next;<br>        &#125;;<br>        <span class="hljs-type">chunk_t</span> *begin_chunk;<br>        <span class="hljs-type">int</span> begin_pos;<br>        <span class="hljs-type">chunk_t</span> *back_chunk;<br>        <span class="hljs-type">int</span> back_pos;<br>        <span class="hljs-type">chunk_t</span> *end_chunk;<br>        <span class="hljs-type">int</span> end_pos;<br>        <span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="构造函数yqueue-t"><a href="#构造函数yqueue-t" class="headerlink" title="构造函数yqueue_t"></a>构造函数yqueue_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化begin_chunk</span><br>    begin_chunk = (<span class="hljs-type">chunk_t</span> *) 				       <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>));<br>    <span class="hljs-built_in">alloc_assert</span>(begin_chunk);<br>    begin_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由于没有元素，因此back_chunk暂时失效</span><br>    back_chunk = <span class="hljs-literal">NULL</span>;<br>    back_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// end_chunk指向的是最后一个chunk，因此有效</span><br>    end_chunk = begin_chunk;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="析构函数-yqueue-t"><a href="#析构函数-yqueue-t" class="headerlink" title="析构函数~yqueue_t"></a>析构函数~yqueue_t</h3><p>销毁所有chunk资源</p>
<p>先遍历访问所有chunk，然后再检查spare_chunk</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (begin_chunk == end_chunk) &#123;<br>            <span class="hljs-built_in">free</span>(begin_chunk);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        <span class="hljs-built_in">free</span>(o);<br>    &#125;<br><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">free</span>(sc);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="front、back函数"><a href="#front、back函数" class="headerlink" title="front、back函数"></a>front、back函数</h3><p>可以注意到，返回的都是引用，因此可以通过函数的返回值修改对应chunk的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> begin_chunk-&gt;values[begin_pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> back_chunk-&gt;values[back_pos];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h3><p>前面已经分析过</p>
<h3 id="unpush函数"><a href="#unpush函数" class="headerlink" title="unpush函数"></a>unpush函数</h3><p>用来回退push操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先处理back块</span><br>    <span class="hljs-comment">// 如果back块的pos是0，说明直接退到前一个去了，否则的话就简单减1就可以</span><br>     <span class="hljs-keyword">if</span> (back_pos)<br>         --back_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         back_pos = N - <span class="hljs-number">1</span>;<br>         back_chunk = back_chunk-&gt;prev;<br>     &#125;<br>    <span class="hljs-comment">// 再处理end块</span><br>    <span class="hljs-comment">// end块的pos如果为0，说明再退一步最后一个块就直接要被丢掉了，否则的话也是简单减1</span><br>     <span class="hljs-keyword">if</span> (end_pos)<br>         --end_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         end_pos = N - <span class="hljs-number">1</span>;<br>         end_chunk = end_chunk-&gt;prev;<br>         <span class="hljs-built_in">free</span>(end_chunk-&gt;next);<br>         end_chunk-&gt;next = <span class="hljs-literal">NULL</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop操作如果发现一个chunk为空了，需要执行xchg函数来处理空闲块，而这个函数必须是线程安全的。因为生产者和消费者分别调用push和pop时都可能使用这个spare_chunk</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N)<br>    &#123;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ypipe"><a href="#ypipe" class="headerlink" title="ypipe"></a>ypipe</h2><p>ypipe在yqueue的基础上进行封装，实现了一个可以单读单写的无锁队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ypipe_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ypipe_t</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">unwrite</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">probe</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*fn)(T &amp;))</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">yqueue_t</span>&lt;T, N&gt; queue;<br>    <span class="hljs-comment">// 指向第一个未刷新的元素</span><br>    T *w;<br>    <span class="hljs-comment">// 指向第一个等待读的元素</span><br>    T *r;<br>    <span class="hljs-comment">// 指向最后一个待刷新的元素</span><br>    T *f;<br>    <span class="hljs-comment">// 读写指针共享，指向每一轮刷新的起点</span><br>    <span class="hljs-type">atomic_ptr_t</span>&lt;T&gt; c;<br>    <span class="hljs-built_in">ypipe_t</span>(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>    <span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="如何写入和读取"><a href="#如何写入和读取" class="headerlink" title="如何写入和读取"></a>如何写入和读取</h3><p>首先看write函数，这个函数只会将更新底层的queue_t，并且在这一轮写结束的时候，即incomplete为false时，才更新f为待刷新的最后一个元素</p>
<p>在这里也可以看到queue_t的使用方法，先设置值，再调用push或者pop函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br><br>    <span class="hljs-comment">//  Move the &quot;flush up to here&quot; poiter.</span><br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后是flush函数，再完成一波写入后，手动调用flush函数</p>
<p>flush函数就是更新了w和c两个指针</p>
<ol>
<li>w指针代表着已经写到哪了</li>
<li>c指针在读写线程之间共享<ol>
<li>读线程通过c知道是否读完了</li>
<li>写线程通过读线程是否将c设置为null知道读线程是否在睡眠</li>
</ol>
</li>
</ol>
<p>如果读线程在睡眠，返回false，否则返回true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果w和f相同，说明没有需要flush的东西</span><br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w)<br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>先检查是否有数据可读，如果没有，直接返回false</p>
<p>如果有数据可读，读出，并返回true</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体来说，check_read</p>
<ol>
<li>如果r指针存在且和queue的front不同，说明已经被预取了，直接返回true</li>
<li>如果待操作的c指针是queue的首元素，则直接返回false，代表没有预取元素</li>
<li>否则就说明可以读，返回true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果读线程调用read返回了false，则读线程应该阻塞自己</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (yqueue.<span class="hljs-built_in">read</span>(&amp;value)) &#123;<br>    <span class="hljs-comment">// 具体处理逻辑</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获得锁，然后通过条件变量阻塞自己</span><br>    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(ypipe_mutex_);<br>    ypipe_cond_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>阻塞一直到写进程写入数据，通过条件变量唤醒阻塞的读进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">yqueue.<span class="hljs-built_in">write</span>(count, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!yqueue.<span class="hljs-built_in">flush</span>()) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(ypipe_mutex_)</span></span>;<br>    ypipe_cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="w-r-f-c详解"><a href="#w-r-f-c详解" class="headerlink" title="w,r,f,c详解"></a>w,r,f,c详解</h3><p>首先看看在各个函数中，哪些指针被使用了</p>
<h4 id="ypipe-t"><a href="#ypipe-t" class="headerlink" title="ypipe_t"></a>ypipe_t</h4><p>在初始化函数中</p>
<ol>
<li>首先对队列调用一个push，为back赋予一个正常的值（这里面，在使用的时候，back永远指向一个空的位置，即可以直接赋值）</li>
<li>然后将四个指针都置为back</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span> </span>&#123;<br>    queue.<span class="hljs-built_in">push</span>();<br>    r = w = f = &amp;queue.<span class="hljs-built_in">back</span>(); <br>    c.<span class="hljs-built_in">set</span>(&amp;queue.<span class="hljs-built_in">back</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><ol>
<li><p>将一个值直接写到队列中。这里也证实了back就是指向一个空的位置，每次使用时，直接赋值然后++</p>
</li>
<li><p>重头戏来了，这里首次更新指针<code>f</code></p>
<p>如果这是这次写的最后一个（生产者可以一次性写一大堆数据），那么就会更新f指向当前队列的最后一个元素。待会在flush的时候会用上它</p>
</li>
</ol>
<p>这里是使用了一种机制，使得写操作不会马上呈现在消费者眼中，只会在生产者调用了flush之后消费者才能看到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ol>
<li>如果w和f相同，说明没有需要flush的，直接返回true</li>
<li>比较c和w的值<ol>
<li>无论如何都会将c和w更新为f</li>
<li>如果c和w的值不同，c只可能是null，说明读线程被阻塞了，返回一个false提醒写线程唤醒读线程</li>
</ol>
</li>
</ol>
<p>flush函数的作用</p>
<ol>
<li>更新c和w，以告诉读线程，现在有新的数据可读</li>
<li>根据返回值告诉写线程读线程是否被阻塞了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w) <br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>对于读线程</p>
<ol>
<li>通过check_read判断是否可读，不可读的话直接返回不可读</li>
<li>可读的话直接开读</li>
</ol>
<p>因此关键在于check_read函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="check-read"><a href="#check-read" class="headerlink" title="check_read"></a>check_read</h4><ol>
<li>如果r指针有效，并且它不是front，即现在还有可读的数据，那么返回true，直接读</li>
<li>如果目前r指针不对劲，那么尝试更新r指针为c（如果现在有可读的数据，即生产者调用了flush，那c一定是最新的可读的边界）<ol>
<li>如果c也是队列头，说明现在根本就没数据，因此将c置为NULL</li>
<li>如果c不是队列头，那么不会改变c</li>
</ol>
</li>
<li>判断更新之后的r是否有效并且不是队列头，如果不满足的话，返回false，否则返回true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="整体思路梳理（单读单写）"><a href="#整体思路梳理（单读单写）" class="headerlink" title="整体思路梳理（单读单写）"></a>整体思路梳理（单读单写）</h1><p>现在有一个队列，一个生产者和一个消费者</p>
<p>传统的思路就是用一把大锁，谁要用队列就直接锁上，这样一定会保证线程安全，但是这样太慢了</p>
<p>先尝试这样的优化思路</p>
<ol>
<li>生产者维护一个下标w，指向它生产到了哪里</li>
<li>消费者维护一个下标r，指向它可以一直读到哪个下标为止</li>
</ol>
<p>比如有个队列长为10，如果w&#x3D;5，r&#x3D;3</p>
<p>r&#x3D;3则表示消费者可以一直读到下标3处为止，比如1,2,3它都可以读</p>
<p>w&#x3D;5则表示，现在1,2,3,4,5都有东西可读</p>
<p>之所以w和r不一样，是因为w和r是分别存在于生产者和消费者线程内的，互相不可见，这样就不会有竞争条件</p>
<p>但是这样虽然没竞争，但是w和r肯定是要同步的，要不然消费者咋知道生产者生产了多少东西</p>
<p>既然要进行线程间的同步，那肯定要用到锁了。无锁队列采用的是CAS机制。首先全局有一个生产者和消费者都可以操作的变量c</p>
<ol>
<li>在生产者生产了一个东西放入队列后，它可以通过变量c的CAS机制将新的下标更新到c中。因为CAS机制，所以一定是线程安全的</li>
<li>在消费者发现自己已经读到了下标r后，它会试着用变量c的CAS机制来更新下标r，如果有更新，说明有新的可读，否则的话说明没东西读了</li>
</ol>
<p>因此，通过变量c，就可以将w和r联系起来，并且一定保证线程安全</p>
<p>但是还可以继续优化，如果频繁调用CAS机制，那可能还是比较耗费资源</p>
<ol>
<li>在生产者端，写入数据后，可以不急着更新到c中，等到写入一定量的数据后，再更新到c中，这样可以避免频繁调用CAS，并且这样一次就可以更新多个值，消费者那边效率也高些，不会说取一个就没了</li>
<li>在消费者端，其实已经是优化过的思路了，即r指针代表的是可以读到的位置，假如r等于5，而我们目前只读到2，那可以啥也不管地一直读3个，直到读到了r，这时候才需要考虑更新r</li>
</ol>
<p>在具体的实现中，还有一个f指针，主要是用于代码实现的，理解思路跟它没啥关系</p>
<p>至此，又优化了一波。还可以继续优化吗？</p>
<p>接下来可以从底层数据结构的角度进行优化</p>
<ol>
<li>首先，为了避免频繁调用malloc（除了系统调用的开销，它还会阻塞一个进程内的所有线程），可以一次分配一个N个元素的大块。并且可以缓存一个空闲的块，不马上销毁，也可以提升性能</li>
<li>其次，考虑到一个块太大了浪费，太小了不够用，可以以链表的形式将多个块串起来，这样就可以避免数组带来的连续空间的问题了</li>
</ol>
<h1 id="无锁队列的实现（多读多写）"><a href="#无锁队列的实现（多读多写）" class="headerlink" title="无锁队列的实现（多读多写）"></a>无锁队列的实现（多读多写）</h1><p>之前分析的单写单读无锁队列由于没有对w和r加锁，因此只能用于一个生产者一个消费者的情况。</p>
<h2 id="ArrayLockFreeQueue"><a href="#ArrayLockFreeQueue" class="headerlink" title="ArrayLockFreeQueue"></a>ArrayLockFreeQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;<br><span class="hljs-keyword">class</span> ArrayLockFreeQueue &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-function">QUEUE_INT <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ELEM_T &amp;a_data)</span></span>;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(ELEM_T &amp;a_data)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 环形数组</span><br>    ELEM_T m_thequeue[Q_SIZE];<br>    <span class="hljs-comment">// 队列内待处理的元素数量</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_count;<br>    <span class="hljs-comment">// 写坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_writeIndex;<br>    <span class="hljs-comment">// 读坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_readIndex;<br>    <span class="hljs-comment">// 最大的可读位置的坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_maximumReadIndex;<br>    <span class="hljs-comment">// 取余函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> QUEUE_INT <span class="hljs-title">countToIndex</span><span class="hljs-params">(QUEUE_INT a_count)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，m_maximumReadIndex不一定和m_writeIndex同步，因为申请空间后就会更新writeindex，但只有在数据写入之后，才会更新m_maximumReadIndex</p>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p>循环队列，因此肯定要有取余的操作，直接mod数组的长度Q_SIZE即可</p>
<p>队列已满的判断条件：(write+1)%size&#x3D;&#x3D;read%size</p>
<p>队列为空的判断条件：write%size&#x3D;&#x3D;read%size</p>
<h3 id="入队函数enqueue"><a href="#入队函数enqueue" class="headerlink" title="入队函数enqueue"></a>入队函数enqueue</h3><ol>
<li>首先判断队列是否已经满了（获取全局的读和写指针），如果已经满了，直接返回false</li>
<li>如果队列有空位，尝试将写指针+1，如果失败，则回到第1步重新循环</li>
<li>如果写指针增加成功，那么将值写入更新前的位置（写指针指向的是空闲位置，更新之后，相当于指向的是下一次写的空闲位置）</li>
<li>最后尝试更新read最多可读到的位置，如果更新失败，则阻塞后再循环（这里有个很奇妙的地方，只有在read最多可读的位置的指针和当前指针相同时，才会将它更新到+1，这样就保证了这个值一定是一点一点地加1，不会出现多个线程乱操作的情况）</li>
</ol>
<p>总结来说，CAS很奇妙，使用它不仅是保证这次一定只有一个线程能访问到它正确的值，更是通过它和之前的值进行比较，保证了一定只有某个线程可以更新它</p>
<p>所以，使用CAS之前，应该拿到一个旧值，这样相当于一个通行证，只有它才能使用CAS更新某个变量为新值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">enqueue</span>(<span class="hljs-type">const</span> ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentWriteIndex;<br>    QUEUE_INT currentReadIndex;<br>    <span class="hljs-keyword">do</span> &#123;<br>        currentWriteIndex = m_writeIndex;<br>        currentReadIndex = m_readIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentWriteIndex + <span class="hljs-number">1</span>) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentReadIndex)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>)));<br>    m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentWriteIndex)] = a_data;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">sched_yield</span>();<br>    &#125;<br>    <span class="hljs-built_in">AtomicAdd</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="出队函数dequeue"><a href="#出队函数dequeue" class="headerlink" title="出队函数dequeue"></a>出队函数dequeue</h3><ol>
<li>先判断当前队列是否为空，如果空的话，直接返回false了。这里可能不太严谨，因为可能刚取完read和max的值，这两个值就被更新了，但是没关系，大不了再调用一次</li>
<li>取出队头的值，但是这不代表它正确取出了，原因如上所说，可能刚取完read和max的下标，这个下标就已经被别人修改了</li>
<li>如果现在全局的read指针和自己的指针相同，这才说明这个值应该是由自己取出来，否则的话说明已经被别人给取了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">dequeue</span>(ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentMaximumReadIndex;<br>    QUEUE_INT currentReadIndex;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        currentReadIndex = m_readIndex;<br>        currentMaximumReadIndex = m_maximumReadIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentReadIndex) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentMaximumReadIndex))    <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        a_data = m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentReadIndex)]; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CAS</span>(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-built_in">AtomicSub</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多读多写的机制总结"><a href="#多读多写的机制总结" class="headerlink" title="多读多写的机制总结"></a>多读多写的机制总结</h3><p>多读多写可以说就是在读层面和写层使用了同一个思想</p>
<ol>
<li>先建立一个所有线程共享的下标值</li>
<li>在每个线程试图去操作的时候，先取出当前的下标值，然后判断队空或者队满</li>
<li>如果自己可以操作的话，通过CAS判断目前这个点是否轮到自己操作了，即没有被其他线程抢先操作完了<ol>
<li>对于写线程来说，检查write的下标是否和自己记录的一样，一样的话，说明可以操作，否则循环重新去取下一个吧，这个已经被别人处理了</li>
<li>对于读线程来说也是这样，检查现在read的下标是否和自己记录的一样</li>
<li>当然了，对于写线程来说，它还需要多一个更新可读的最大下标的任务，同样是判断是否应该是自己操作。具体实现上通过之前记录的write下标即可</li>
</ol>
</li>
</ol>
<p>这里有个小坑，就是因为是循环数组，因此如果存的是智能指针，可能不会自动释放</p>
<h2 id="yield的重要性"><a href="#yield的重要性" class="headerlink" title="yield的重要性"></a>yield的重要性</h2><p>明明说是无锁队列，为什么还要用yield放弃cpu主动阻塞呢？</p>
<p>因为如果不主动让出cpu，当前线程可能会因为CAS操作失败而不断循环，即空转cpu，这种情况下，还不如让出cpu。</p>
<p>如果只有一个生产者，那么当然不需要yield，也不可能运行到yield语句，但是如果有很多个生产者，就需要考虑了。</p>
<h1 id="总结-致谢"><a href="#总结-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>无锁队列不是真的无锁，而是将锁的粒度设置地特别小，使得并发的性能尽量高。但是好像它只是在并发量特别高的时候才有很好的性能，普通情况下可能还不如直接用锁来的方便，所以还是要依据具体情况选择。</p>
<p>在科软的第一个学期已经要结束了，这学期的课基本也都上完了。只能说孟宁老师的《网络程序设计》真绝世好课，原因如下</p>
<ol>
<li>可以学到东西：几次实验包括了的epoll，grpc框架和消息队列，以及linux内核协议栈的调试（gcc调试方法）</li>
<li>课程内容也不会脱离找工作找实习：第1点里提到的基本都是C++面试必问的。有些课程虽然也能学到东西，但是对于找实习找工作，性价比太低</li>
<li>平时作业很轻松：以学到东西为主，没有很严格的考核机制</li>
<li>最后的大作业的自由度很高，可以借此机会选择自己感兴趣的方向深入学习一下</li>
</ol>
<p>最后，借此机会还搭建了个人博客，只能说，绝世好课！</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>网络程序设计_课程项目</div>
      <div>http://example.com/2023/12/21/lock-free-queue/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cao Dong</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/23/6-5940-lab4/" title="6.5940_lab4">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">6.5940_lab4</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/07/6-5940-lab3/" title="6.5940_lab3">
                        <span class="hidden-mobile">6.5940_lab3</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
