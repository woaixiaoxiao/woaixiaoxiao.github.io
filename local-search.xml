<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络程序设计_课程项目</title>
    <link href="/2023/12/21/lock-free-queue/"/>
    <url>/2023/12/21/lock-free-queue/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">为什么需要无锁队列？</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">无锁队列的实现（单读单写）</a><ul><li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">原子操作函数</a></li><li><a href="#yqueue_t%E7%9A%84chunk%E5%9D%97%E6%9C%BA%E5%88%B6">yqueue_t的chunk块机制</a><ul><li><a href="#chunk%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">chunk一次分配多个元素</a></li><li><a href="#chunk%E5%9D%97%E6%9C%BA%E5%88%B6-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">chunk块机制 局部性原理</a></li></ul></li><li><a href="#yqueue_t%E6%88%90%E5%91%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">yqueue_t成员和接口介绍</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0yqueue_t">构造函数yqueue_t</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0yqueue_t">析构函数~yqueue_t</a></li><li><a href="#frontback%E5%87%BD%E6%95%B0">front、back函数</a></li><li><a href="#push%E5%87%BD%E6%95%B0">push函数</a></li><li><a href="#unpush%E5%87%BD%E6%95%B0">unpush函数</a></li><li><a href="#pop">pop</a></li></ul></li><li><a href="#ypipe">ypipe</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96">如何写入和读取</a></li><li><a href="#%E8%AF%BB">读</a></li><li><a href="#wrfc%E8%AF%A6%E8%A7%A3">w,r,f,c详解</a><ul><li><a href="#ypipe_t">ypipe_t</a></li><li><a href="#write">write</a></li><li><a href="#flush">flush</a></li><li><a href="#read">read</a></li><li><a href="#check_read">check_read</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">整体思路梳理（单读单写）</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99">无锁队列的实现（多读多写）</a><ul><li><a href="#arraylockfreequeue">ArrayLockFreeQueue</a></li><li><a href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">函数介绍</a><ul><li><a href="#%E5%8F%96%E4%BD%99%E5%87%BD%E6%95%B0">取余函数</a></li><li><a href="#%E5%85%A5%E9%98%9F%E5%87%BD%E6%95%B0enqueue">入队函数enqueue</a></li><li><a href="#%E5%87%BA%E9%98%9F%E5%87%BD%E6%95%B0dequeue">出队函数dequeue</a></li><li><a href="#%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">多读多写的机制总结</a></li></ul></li><li><a href="#yield%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">yield的重要性</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93%E8%87%B4%E8%B0%A2">总结&amp;致谢</a></li></ul><h1 id="为什么需要无锁队列？"><a href="#为什么需要无锁队列？" class="headerlink" title="为什么需要无锁队列？"></a>为什么需要无锁队列？</h1><p>传统的高并发场景中，是使用阻塞机制来避免并发带来的各种问题。但是传统的阻塞机制有以下两个问题</p><ol><li>阻塞意味着线程要进行切换，而线程的切换会带来cache的失效。而cache作为存储体系中最重要的一环，频繁地失效肯定会带来极大的开销和性能损失</li><li>如果一个线程要处理的事情非常多，但是它却经常为了某个资源而被阻塞住，那肯定会降低系统的吞吐量，带来很高的延迟</li></ol><h1 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h1><h2 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">atomic_ptr_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T *ptr_)</span></span>; <span class="hljs-comment">//⾮原⼦操作</span><br>    <span class="hljs-function">T *<span class="hljs-title">xchg</span><span class="hljs-params">(T *val_)</span></span>; <span class="hljs-comment">//原⼦操作，设置⼀个新的值，然后返回旧的值</span><br>    <span class="hljs-function">T *<span class="hljs-title">cas</span><span class="hljs-params">(T *cmp_, T *val_)</span></span>;<span class="hljs-comment">//原⼦操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>set</code>是直接设置ptr的值</li><li><code>xchg</code>是设置ptr的值为val，并返回ptr设置之前的值</li><li><code>cas</code>是先比较<ol><li>若ptr和cmp相同，则设置ptr为val并返回ptr设置之前的值</li><li>若ptr和cmp不同，不设置ptr，直接返回ptr的值</li></ol></li></ol><h2 id="yqueue-t的chunk块机制"><a href="#yqueue-t的chunk块机制" class="headerlink" title="yqueue_t的chunk块机制"></a>yqueue_t的chunk块机制</h2><h3 id="chunk一次分配多个元素"><a href="#chunk一次分配多个元素" class="headerlink" title="chunk一次分配多个元素"></a>chunk一次分配多个元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunk_t</span> &#123;<br>   T values[N];<br>   <span class="hljs-type">chunk_t</span> *prev;<br>   <span class="hljs-type">chunk_t</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个chunk包含N个元素，因此可以减少分配内存的次数</p><p>会有一个spare_chunk的结构将空闲的chunk保存起来，需要的时候就可以直接拿出来用。在一个chunk空闲时，也不会直接删除，而是放入spare_chunk中</p><h3 id="chunk块机制-局部性原理"><a href="#chunk块机制-局部性原理" class="headerlink" title="chunk块机制 局部性原理"></a>chunk块机制 局部性原理</h3><p>利用局部性原理，可以将刚刚空闲的chunk放到spare_chunk中先保存着。如果后面马上就用上了，那就可以节省很多时间，而如果没用上，至少也可以省去重新分配动态内存的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br></code></pre></td></tr></table></figure><p>执行pop的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N) <span class="hljs-comment">// 删除满一个chunk才回收chunk</span><br>    &#123;<br>        <span class="hljs-comment">// 将空闲chunk的指针暂时保留下来</span><br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        <span class="hljs-comment">// 由于空闲chunk是边界，因此更新边界</span><br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将空闲chunk和上一个空闲chunk交换一下，然后将上一个给free掉</span><br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行push的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先取到最后一个chunk和chunk内部的pos</span><br>    back_chunk = end_chunk;<br>    back_pos = end_pos; <br>    <span class="hljs-comment">// 如果最后一个chunk还有空间，则不需要做其他的操作</span><br>    <span class="hljs-keyword">if</span> (++end_pos != N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果最后一个chunk没有空间了，则需要扩容，首先考虑一下spare_chunk是否有空闲的</span><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果有空闲的chunk，直接建立双向连接即可</span><br>    <span class="hljs-keyword">if</span> (sc)<br>    &#123;<br>        end_chunk-&gt;next = sc;<br>        sc-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有空闲的，先分配，再建立连接关系</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        end_chunk-&gt;next = (<span class="hljs-type">chunk_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>)); <br>        <span class="hljs-built_in">alloc_assert</span>(end_chunk-&gt;next);<br>        end_chunk-&gt;next-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 最后修改end_chunk即可</span><br>    end_chunk = end_chunk-&gt;next;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="yqueue-t成员和接口介绍"><a href="#yqueue-t成员和接口介绍" class="headerlink" title="yqueue_t成员和接口介绍"></a>yqueue_t成员和接口介绍</h2><p>可以将这个队列看成是一个双向链表，链表的每个节点都是一个chunk，包含了N个元素，其他的概念和普通的队列差不多。</p><p>三种chunk的区别</p><ol><li>begin_chunk指向队列头部，从这取出元素</li><li>back_chunk指向队列的最后一个元素所在的chunk，back_pos指向最后一个元素</li><li>end_chunk指向队列最后一个chunk</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yqueue_t</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">        struct chunk_t &#123;</span><br>            T values[N];<br>            <span class="hljs-type">chunk_t</span> *prev;<br>            <span class="hljs-type">chunk_t</span> *next;<br>        &#125;;<br>        <span class="hljs-type">chunk_t</span> *begin_chunk;<br>        <span class="hljs-type">int</span> begin_pos;<br>        <span class="hljs-type">chunk_t</span> *back_chunk;<br>        <span class="hljs-type">int</span> back_pos;<br>        <span class="hljs-type">chunk_t</span> *end_chunk;<br>        <span class="hljs-type">int</span> end_pos;<br>        <span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数yqueue-t"><a href="#构造函数yqueue-t" class="headerlink" title="构造函数yqueue_t"></a>构造函数yqueue_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化begin_chunk</span><br>    begin_chunk = (<span class="hljs-type">chunk_t</span> *)        <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>));<br>    <span class="hljs-built_in">alloc_assert</span>(begin_chunk);<br>    begin_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由于没有元素，因此back_chunk暂时失效</span><br>    back_chunk = <span class="hljs-literal">NULL</span>;<br>    back_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// end_chunk指向的是最后一个chunk，因此有效</span><br>    end_chunk = begin_chunk;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数-yqueue-t"><a href="#析构函数-yqueue-t" class="headerlink" title="析构函数~yqueue_t"></a>析构函数~yqueue_t</h3><p>销毁所有chunk资源</p><p>先遍历访问所有chunk，然后再检查spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (begin_chunk == end_chunk) &#123;<br>            <span class="hljs-built_in">free</span>(begin_chunk);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        <span class="hljs-built_in">free</span>(o);<br>    &#125;<br><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">free</span>(sc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="front、back函数"><a href="#front、back函数" class="headerlink" title="front、back函数"></a>front、back函数</h3><p>可以注意到，返回的都是引用，因此可以通过函数的返回值修改对应chunk的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> begin_chunk-&gt;values[begin_pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> back_chunk-&gt;values[back_pos];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h3><p>前面已经分析过</p><h3 id="unpush函数"><a href="#unpush函数" class="headerlink" title="unpush函数"></a>unpush函数</h3><p>用来回退push操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先处理back块</span><br>    <span class="hljs-comment">// 如果back块的pos是0，说明直接退到前一个去了，否则的话就简单减1就可以</span><br>     <span class="hljs-keyword">if</span> (back_pos)<br>         --back_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         back_pos = N - <span class="hljs-number">1</span>;<br>         back_chunk = back_chunk-&gt;prev;<br>     &#125;<br>    <span class="hljs-comment">// 再处理end块</span><br>    <span class="hljs-comment">// end块的pos如果为0，说明再退一步最后一个块就直接要被丢掉了，否则的话也是简单减1</span><br>     <span class="hljs-keyword">if</span> (end_pos)<br>         --end_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         end_pos = N - <span class="hljs-number">1</span>;<br>         end_chunk = end_chunk-&gt;prev;<br>         <span class="hljs-built_in">free</span>(end_chunk-&gt;next);<br>         end_chunk-&gt;next = <span class="hljs-literal">NULL</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop操作如果发现一个chunk为空了，需要执行xchg函数来处理空闲块，而这个函数必须是线程安全的。因为生产者和消费者分别调用push和pop时都可能使用这个spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N)<br>    &#123;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ypipe"><a href="#ypipe" class="headerlink" title="ypipe"></a>ypipe</h2><p>ypipe在yqueue的基础上进行封装，实现了一个可以单读单写的无锁队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ypipe_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ypipe_t</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">unwrite</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">probe</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*fn)(T &amp;))</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">yqueue_t</span>&lt;T, N&gt; queue;<br>    <span class="hljs-comment">// 指向第一个未刷新的元素</span><br>    T *w;<br>    <span class="hljs-comment">// 指向第一个等待读的元素</span><br>    T *r;<br>    <span class="hljs-comment">// 指向最后一个待刷新的元素</span><br>    T *f;<br>    <span class="hljs-comment">// 读写指针共享，指向每一轮刷新的起点</span><br>    <span class="hljs-type">atomic_ptr_t</span>&lt;T&gt; c;<br>    <span class="hljs-built_in">ypipe_t</span>(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>    <span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="如何写入和读取"><a href="#如何写入和读取" class="headerlink" title="如何写入和读取"></a>如何写入和读取</h3><p>首先看write函数，这个函数只会将更新底层的queue_t，并且在这一轮写结束的时候，即incomplete为false时，才更新f为待刷新的最后一个元素</p><p>在这里也可以看到queue_t的使用方法，先设置值，再调用push或者pop函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br><br>    <span class="hljs-comment">//  Move the &quot;flush up to here&quot; poiter.</span><br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是flush函数，再完成一波写入后，手动调用flush函数</p><p>flush函数就是更新了w和c两个指针</p><ol><li>w指针代表着已经写到哪了</li><li>c指针在读写线程之间共享<ol><li>读线程通过c知道是否读完了</li><li>写线程通过读线程是否将c设置为null知道读线程是否在睡眠</li></ol></li></ol><p>如果读线程在睡眠，返回false，否则返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果w和f相同，说明没有需要flush的东西</span><br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w)<br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>先检查是否有数据可读，如果没有，直接返回false</p><p>如果有数据可读，读出，并返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，check_read</p><ol><li>如果r指针存在且和queue的front不同，说明已经被预取了，直接返回true</li><li>如果待操作的c指针是queue的首元素，则直接返回false，代表没有预取元素</li><li>否则就说明可以读，返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果读线程调用read返回了false，则读线程应该阻塞自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (yqueue.<span class="hljs-built_in">read</span>(&amp;value)) &#123;<br>    <span class="hljs-comment">// 具体处理逻辑</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获得锁，然后通过条件变量阻塞自己</span><br>    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(ypipe_mutex_);<br>    ypipe_cond_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞一直到写进程写入数据，通过条件变量唤醒阻塞的读进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">yqueue.<span class="hljs-built_in">write</span>(count, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!yqueue.<span class="hljs-built_in">flush</span>()) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(ypipe_mutex_)</span></span>;<br>    ypipe_cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="w-r-f-c详解"><a href="#w-r-f-c详解" class="headerlink" title="w,r,f,c详解"></a>w,r,f,c详解</h3><p>首先看看在各个函数中，哪些指针被使用了</p><h4 id="ypipe-t"><a href="#ypipe-t" class="headerlink" title="ypipe_t"></a>ypipe_t</h4><p>在初始化函数中</p><ol><li>首先对队列调用一个push，为back赋予一个正常的值（这里面，在使用的时候，back永远指向一个空的位置，即可以直接赋值）</li><li>然后将四个指针都置为back</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span> </span>&#123;<br>    queue.<span class="hljs-built_in">push</span>();<br>    r = w = f = &amp;queue.<span class="hljs-built_in">back</span>(); <br>    c.<span class="hljs-built_in">set</span>(&amp;queue.<span class="hljs-built_in">back</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><ol><li><p>将一个值直接写到队列中。这里也证实了back就是指向一个空的位置，每次使用时，直接赋值然后++</p></li><li><p>重头戏来了，这里首次更新指针<code>f</code></p><p>如果这是这次写的最后一个（生产者可以一次性写一大堆数据），那么就会更新f指向当前队列的最后一个元素。待会在flush的时候会用上它</p></li></ol><p>这里是使用了一种机制，使得写操作不会马上呈现在消费者眼中，只会在生产者调用了flush之后消费者才能看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ol><li>如果w和f相同，说明没有需要flush的，直接返回true</li><li>比较c和w的值<ol><li>无论如何都会将c和w更新为f</li><li>如果c和w的值不同，c只可能是null，说明读线程被阻塞了，返回一个false提醒写线程唤醒读线程</li></ol></li></ol><p>flush函数的作用</p><ol><li>更新c和w，以告诉读线程，现在有新的数据可读</li><li>根据返回值告诉写线程读线程是否被阻塞了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w) <br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>对于读线程</p><ol><li>通过check_read判断是否可读，不可读的话直接返回不可读</li><li>可读的话直接开读</li></ol><p>因此关键在于check_read函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-read"><a href="#check-read" class="headerlink" title="check_read"></a>check_read</h4><ol><li>如果r指针有效，并且它不是front，即现在还有可读的数据，那么返回true，直接读</li><li>如果目前r指针不对劲，那么尝试更新r指针为c（如果现在有可读的数据，即生产者调用了flush，那c一定是最新的可读的边界）<ol><li>如果c也是队列头，说明现在根本就没数据，因此将c置为NULL</li><li>如果c不是队列头，那么不会改变c</li></ol></li><li>判断更新之后的r是否有效并且不是队列头，如果不满足的话，返回false，否则返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整体思路梳理（单读单写）"><a href="#整体思路梳理（单读单写）" class="headerlink" title="整体思路梳理（单读单写）"></a>整体思路梳理（单读单写）</h1><p>现在有一个队列，一个生产者和一个消费者</p><p>传统的思路就是用一把大锁，谁要用队列就直接锁上，这样一定会保证线程安全，但是这样太慢了</p><p>先尝试这样的优化思路</p><ol><li>生产者维护一个下标w，指向它生产到了哪里</li><li>消费者维护一个下标r，指向它可以一直读到哪个下标为止</li></ol><p>比如有个队列长为10，如果w&#x3D;5，r&#x3D;3</p><p>r&#x3D;3则表示消费者可以一直读到下标3处为止，比如1,2,3它都可以读</p><p>w&#x3D;5则表示，现在1,2,3,4,5都有东西可读</p><p>之所以w和r不一样，是因为w和r是分别存在于生产者和消费者线程内的，互相不可见，这样就不会有竞争条件</p><p>但是这样虽然没竞争，但是w和r肯定是要同步的，要不然消费者咋知道生产者生产了多少东西</p><p>既然要进行线程间的同步，那肯定要用到锁了。无锁队列采用的是CAS机制。首先全局有一个生产者和消费者都可以操作的变量c</p><ol><li>在生产者生产了一个东西放入队列后，它可以通过变量c的CAS机制将新的下标更新到c中。因为CAS机制，所以一定是线程安全的</li><li>在消费者发现自己已经读到了下标r后，它会试着用变量c的CAS机制来更新下标r，如果有更新，说明有新的可读，否则的话说明没东西读了</li></ol><p>因此，通过变量c，就可以将w和r联系起来，并且一定保证线程安全</p><p>但是还可以继续优化，如果频繁调用CAS机制，那可能还是比较耗费资源</p><ol><li>在生产者端，写入数据后，可以不急着更新到c中，等到写入一定量的数据后，再更新到c中，这样可以避免频繁调用CAS，并且这样一次就可以更新多个值，消费者那边效率也高些，不会说取一个就没了</li><li>在消费者端，其实已经是优化过的思路了，即r指针代表的是可以读到的位置，假如r等于5，而我们目前只读到2，那可以啥也不管地一直读3个，直到读到了r，这时候才需要考虑更新r</li></ol><p>在具体的实现中，还有一个f指针，主要是用于代码实现的，理解思路跟它没啥关系</p><p>至此，又优化了一波。还可以继续优化吗？</p><p>接下来可以从底层数据结构的角度进行优化</p><ol><li>首先，为了避免频繁调用malloc（除了系统调用的开销，它还会阻塞一个进程内的所有线程），可以一次分配一个N个元素的大块。并且可以缓存一个空闲的块，不马上销毁，也可以提升性能</li><li>其次，考虑到一个块太大了浪费，太小了不够用，可以以链表的形式将多个块串起来，这样就可以避免数组带来的连续空间的问题了</li></ol><h1 id="无锁队列的实现（多读多写）"><a href="#无锁队列的实现（多读多写）" class="headerlink" title="无锁队列的实现（多读多写）"></a>无锁队列的实现（多读多写）</h1><p>之前分析的单写单读无锁队列由于没有对w和r加锁，因此只能用于一个生产者一个消费者的情况。</p><h2 id="ArrayLockFreeQueue"><a href="#ArrayLockFreeQueue" class="headerlink" title="ArrayLockFreeQueue"></a>ArrayLockFreeQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;<br><span class="hljs-keyword">class</span> ArrayLockFreeQueue &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-function">QUEUE_INT <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ELEM_T &amp;a_data)</span></span>;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(ELEM_T &amp;a_data)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 环形数组</span><br>    ELEM_T m_thequeue[Q_SIZE];<br>    <span class="hljs-comment">// 队列内待处理的元素数量</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_count;<br>    <span class="hljs-comment">// 写坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_writeIndex;<br>    <span class="hljs-comment">// 读坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_readIndex;<br>    <span class="hljs-comment">// 最大的可读位置的坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_maximumReadIndex;<br>    <span class="hljs-comment">// 取余函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> QUEUE_INT <span class="hljs-title">countToIndex</span><span class="hljs-params">(QUEUE_INT a_count)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，m_maximumReadIndex不一定和m_writeIndex同步，因为申请空间后就会更新writeindex，但只有在数据写入之后，才会更新m_maximumReadIndex</p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p>循环队列，因此肯定要有取余的操作，直接mod数组的长度Q_SIZE即可</p><p>队列已满的判断条件：(write+1)%size&#x3D;&#x3D;read%size</p><p>队列为空的判断条件：write%size&#x3D;&#x3D;read%size</p><h3 id="入队函数enqueue"><a href="#入队函数enqueue" class="headerlink" title="入队函数enqueue"></a>入队函数enqueue</h3><ol><li>首先判断队列是否已经满了（获取全局的读和写指针），如果已经满了，直接返回false</li><li>如果队列有空位，尝试将写指针+1，如果失败，则回到第1步重新循环</li><li>如果写指针增加成功，那么将值写入更新前的位置（写指针指向的是空闲位置，更新之后，相当于指向的是下一次写的空闲位置）</li><li>最后尝试更新read最多可读到的位置，如果更新失败，则阻塞后再循环（这里有个很奇妙的地方，只有在read最多可读的位置的指针和当前指针相同时，才会将它更新到+1，这样就保证了这个值一定是一点一点地加1，不会出现多个线程乱操作的情况）</li></ol><p>总结来说，CAS很奇妙，使用它不仅是保证这次一定只有一个线程能访问到它正确的值，更是通过它和之前的值进行比较，保证了一定只有某个线程可以更新它</p><p>所以，使用CAS之前，应该拿到一个旧值，这样相当于一个通行证，只有它才能使用CAS更新某个变量为新值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">enqueue</span>(<span class="hljs-type">const</span> ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentWriteIndex;<br>    QUEUE_INT currentReadIndex;<br>    <span class="hljs-keyword">do</span> &#123;<br>        currentWriteIndex = m_writeIndex;<br>        currentReadIndex = m_readIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentWriteIndex + <span class="hljs-number">1</span>) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentReadIndex)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>)));<br>    m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentWriteIndex)] = a_data;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">sched_yield</span>();<br>    &#125;<br>    <span class="hljs-built_in">AtomicAdd</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队函数dequeue"><a href="#出队函数dequeue" class="headerlink" title="出队函数dequeue"></a>出队函数dequeue</h3><ol><li>先判断当前队列是否为空，如果空的话，直接返回false了。这里可能不太严谨，因为可能刚取完read和max的值，这两个值就被更新了，但是没关系，大不了再调用一次</li><li>取出队头的值，但是这不代表它正确取出了，原因如上所说，可能刚取完read和max的下标，这个下标就已经被别人修改了</li><li>如果现在全局的read指针和自己的指针相同，这才说明这个值应该是由自己取出来，否则的话说明已经被别人给取了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">dequeue</span>(ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentMaximumReadIndex;<br>    QUEUE_INT currentReadIndex;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        currentReadIndex = m_readIndex;<br>        currentMaximumReadIndex = m_maximumReadIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentReadIndex) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentMaximumReadIndex))    <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        a_data = m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentReadIndex)]; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CAS</span>(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-built_in">AtomicSub</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多读多写的机制总结"><a href="#多读多写的机制总结" class="headerlink" title="多读多写的机制总结"></a>多读多写的机制总结</h3><p>多读多写可以说就是在读层面和写层使用了同一个思想</p><ol><li>先建立一个所有线程共享的下标值</li><li>在每个线程试图去操作的时候，先取出当前的下标值，然后判断队空或者队满</li><li>如果自己可以操作的话，通过CAS判断目前这个点是否轮到自己操作了，即没有被其他线程抢先操作完了<ol><li>对于写线程来说，检查write的下标是否和自己记录的一样，一样的话，说明可以操作，否则循环重新去取下一个吧，这个已经被别人处理了</li><li>对于读线程来说也是这样，检查现在read的下标是否和自己记录的一样</li><li>当然了，对于写线程来说，它还需要多一个更新可读的最大下标的任务，同样是判断是否应该是自己操作。具体实现上通过之前记录的write下标即可</li></ol></li></ol><p>这里有个小坑，就是因为是循环数组，因此如果存的是智能指针，可能不会自动释放</p><h2 id="yield的重要性"><a href="#yield的重要性" class="headerlink" title="yield的重要性"></a>yield的重要性</h2><p>明明说是无锁队列，为什么还要用yield放弃cpu主动阻塞呢？</p><p>因为如果不主动让出cpu，当前线程可能会因为CAS操作失败而不断循环，即空转cpu，这种情况下，还不如让出cpu。</p><p>如果只有一个生产者，那么当然不需要yield，也不可能运行到yield语句，但是如果有很多个生产者，就需要考虑了。</p><h1 id="总结-致谢"><a href="#总结-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>无锁队列不是真的无锁，而是将锁的粒度设置地特别小，使得并发的性能尽量高。但是好像它只是在并发量特别高的时候才有很好的性能，普通情况下可能还不如直接用锁来的方便，所以还是要依据具体情况选择。</p><p>在科软的第一个学期已经要结束了，这学期的课基本也都上完了。只能说孟宁老师的《网络程序设计》真绝世好课，原因如下</p><ol><li>可以学到东西：几次实验包括了的epoll，grpc框架和消息队列，以及linux内核协议栈的调试（gcc调试方法）</li><li>课程内容也不会脱离找工作找实习：第1点里提到的基本都是C++面试必问的。有些课程虽然也能学到东西，但是对于找实习找工作，性价比太低</li><li>平时作业很轻松：以学到东西为主，没有很严格的考核机制</li><li>最后的大作业的自由度很高，可以借此机会选择自己感兴趣的方向深入学习一下</li></ol><p>最后，借此机会还搭建了个人博客，只能说，绝世好课！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab10</title>
    <link href="/2023/12/20/lab10%20mmap/"/>
    <url>/2023/12/20/lab10%20mmap/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231220221050424.png" alt="image-20231220221050424"></p><ul><li><a href="#task">task</a></li><li><a href="#hints">hints</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE">基础设置</a></li><li><a href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">增加数据结构</a></li><li><a href="#sys_mmap">sys_mmap</a></li><li><a href="#usertrap">usertrap</a></li><li><a href="#munmap">munmap</a></li><li><a href="#exit">exit</a></li><li><a href="#fork">fork</a></li></ul></li></ul><h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><hr><p>mmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ol><li><p>在这个lab中，addr永远为0，即内核决定用哪个虚拟地址去映射这个文件，mmap返回这个虚拟地址，或者0xffffffffffffffff 表示失败</p></li><li><p>length代表映射的字节数量，不一定要是文件的长度</p></li><li><p>prot决定了这个内存，可读，可写或者可执行</p><p> 具体的宏为PROT_READ、PROT_WRITE</p></li><li><p>flags如果是MAP_SHARED，意味着对内存的修改要写回到文件</p><p> MAP_PRIVATE意味着不用写回文件</p></li><li><p>fd是文件的描述符，你可以假设offset是0</p></li></ol><hr><p>munmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">munmap(addr, length)<br></code></pre></td></tr></table></figure><ol><li>munmap应该移出这些地址范围内的映射</li><li>如果进程修改了内存，并且映射方式是MAP_SHARED，那么修改应该被写回文件</li><li>munmap可能只覆盖了mmap的一部分区间，可以是开始，可以是末尾，也可能是整个，但不会是中间位置</li></ol><h1 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h1><ol><li><p>首先在Makefile中添加_mmaptest，并且增加mmap和munmap系统调用</p><p> 在<code>kernel/fcntl.h</code>为你定义了<code>PROT_READ</code>等参数</p></li><li><p>lazy地对待页表，类似于lazy lab。</p><p> 即mmap并不会直接分配物理内存和读文件，在usertrap中处理页错误时再真正的分配内存</p></li><li><p>你需要记录每个进程通过mmap映射了什么</p><p> 你可以定义一个和VMA相关的数据结构，去记录地址，长度，权限，文件等</p><p> 你可以定义一个固定长度的VMA数组，16就足够了</p></li><li><p>实现mmap</p><ol><li><p>在进程的地址空间找一块未使用的区域去映射文件</p></li><li><p>并且增加一个VMA到进程映射区域的表中</p><ol><li>VMA应该包含一个指向<code>struct file</code>的指针。mmap应该增加这个文件的引用，这一部分可以参考<code>filedup</code></li></ol></li><li><p>这时候运行mmaptest，可以发现第一个成功了，但是后面的还是失败了</p></li></ol></li><li><p>增加代码</p><ol><li>在页错误发生在mapped区域时，分配一个物理页面，从相关的文件中读取4096个字节，并且将其映射到用户地址空间</li><li>用readi读取文件，它会使用到一个offset参数，同时你需要将inode结点给lock和unlock</li><li>不要忘记设置这一页的权限位</li><li>运行mmaptest，这时候会运行到munmap了</li></ol></li><li><p>实现munmap</p><ol><li>找到这个地址范围内的VMA，unmap指定的页面，使用<code>uvmunmap</code></li><li>如果munmap删除了mmap分配的所有区域，那它应该减少文件的引用次数</li><li>如果一个页面是MAP_SHARED，并且被修改了，那么应该写回文件（学习<code>filewrite</code>）。写回时不需要管pte的dirty位</li></ol></li><li><p>修改exit函数，使其能够在进程用过mmap的情况下，将没有被munmap都处理掉，至此mmap_test可能可以通过了</p></li><li><p>修改fork保证孩子也有和父节点一样的映射区域，不要忘记了去给VMA文件增加引用数。在页错误发生时，可以分配一个新的物理页面，而不是和父进程共享一个。</p></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>首先需要修改Makefile并且添加两个系统调用，这个就比较简单了</p><h2 id="增加数据结构"><a href="#增加数据结构" class="headerlink" title="增加数据结构"></a>增加数据结构</h2><p>我们应该按照hints提示的，创造一个VMA的结构体，并且在进程的proc的结构体中存储一个VMA的数组。这里的思路就比较简单暴力了，就只维护一个数组，需要用的时候就遍历数组去找就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> &#123;</span><br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> prot;<br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> valid;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[16];</span><br>    <span class="hljs-comment">//.......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h2><p>开始写<code>mmap</code>函数</p><ol><li>这玩意的作用就是只申请一个虚拟地址空间，但是不直接分配物理地址。在申请完之后，就将相关的东西存在proc的VMA数组中去</li><li>有几个情况需要特判<ol><li>如果文件不可读，那么就不能用<code>MAP_SHARED</code>，因为这种模式在之后会写入到磁盘</li><li>地址不够了，即<code>p-&gt;sz&gt;MAXVA</code></li></ol></li><li>注意点<ol><li>只分配虚拟内存，不增加物理内存，就是通过只增加<code>p-&gt;sz</code>而不真正的映射实现的。包括页表中都没有相关的记录</li><li>用<code>argfd</code>取出文件指针</li><li>记得用<code>filedup</code>增加文件的引用计数</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> length, prot, flags, offest;<br>    uint64 erro = <span class="hljs-number">0xffffffffffffffff</span>;<br><br>    <span class="hljs-comment">// 取出参数</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span><br>        || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span><br>        || argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;file) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">5</span>, &amp;offest) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 权限不对</span><br>    <span class="hljs-keyword">if</span> (file-&gt;writable == <span class="hljs-number">0</span> &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 地址不够了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (p-&gt;sz + length &gt; MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 分配地址，找出一个空闲的vma</span><br>    addr = p-&gt;sz;<br>    p-&gt;sz += length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            p-&gt;vmas[i].addr = addr;<br>            p-&gt;vmas[i].flag = flags;<br>            p-&gt;vmas[i].length = length;<br>            p-&gt;vmas[i].prot = prot;<br>            p-&gt;vmas[i].file = file;<br>            filedup(file);<br>            <span class="hljs-keyword">return</span> addr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> erro;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>修改<code>usertrap</code>函数，使得vma相关的地址能够被正确处理</p><ol><li>首先应该通过<code>r_scause</code>捕获异常</li><li>判断地址的合法性<ol><li>压根不在vma管辖范围内<ol><li>不能超出当前进程的虚拟地址范围，即<code>p-&gt;sz</code></li><li>不能低于栈区</li><li>在进程的vma数组中找不到对应的地址</li></ol></li><li>权限合法性<ol><li>通过<code>r_scause</code>可以知道当前是读还是写操作，通过文件的类型，可以确定是否有这个权限</li></ol></li></ol></li><li><code>kalloc</code>分配一个物理页面</li><li><code>readi</code>将文件的内容读入物理页面，其中偏移部分通过当前地址和vma记录的addr做差值得到，因为一读就是一个页面，因此还要将这个偏移向PGSIZE舍入</li><li>将映射关系通过<code>uvmmap</code>写入到页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-comment">// #ifdef LAB_MMAP</span><br>        <span class="hljs-keyword">if</span> (mmap_handler(r_stval(), r_scause()) == <span class="hljs-number">-1</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// #endif</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <br>    <br><span class="hljs-type">int</span> mmap_handler(uint64 va, uint64 r_cause) &#123;<br>    <span class="hljs-keyword">struct</span> proc *p = myproc();<br>    <span class="hljs-comment">// 地址不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否和vma有关系</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (va &gt;= p-&gt;vmas[i].addr &amp;&amp; va &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 和vma没关系</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 和vma是有关的</span><br>    <span class="hljs-comment">// 看看权限是否正确</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> vma-&gt;file;<br>    <span class="hljs-comment">// 不能读，但是你读了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;readable &amp;&amp; r_cause == <span class="hljs-number">13</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不能写，但是你写了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;writable &amp;&amp; r_cause == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 构建pte的标志位</span><br>    <span class="hljs-type">int</span> pte_flag = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;<br>        pte_flag |= PTE_R;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;<br>        pte_flag |= PTE_W;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;<br>        pte_flag |= PTE_X;<br>    &#125;<br>    <span class="hljs-comment">// 先分配一个物理页面</span><br>    uint64 pa = (uint64)kalloc();<br>    <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// 成功分配物理页面，从文件中读</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span> =</span> file-&gt;ip;<br>    ilock(ip);<br>    <span class="hljs-comment">// 读取失败</span><br>    <span class="hljs-keyword">if</span> (readi(ip, <span class="hljs-number">0</span>, pa, PGROUNDDOWN(va - vma-&gt;addr), PGSIZE) == <span class="hljs-number">0</span>) &#123;<br>        iunlock(ip);<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlock(ip);<br>    <span class="hljs-comment">// 加入映射</span><br>    <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, pa, pte_flag) != <span class="hljs-number">0</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><blockquote><p>lab对munmap的情况做了简化，只会从头开始unmap，因此在将数据写回磁盘时，直接调用filewrite函数，它在内部会自动调用file的偏移</p></blockquote><p>munmap就是取消某部分虚拟地址的mmap</p><ol><li>在进程的vma数组找到对应的vma</li><li>更新vma中的addr和length，如果当前length&#x3D;0，说明全部被写入了，那么就通过fileclose关闭这个文件，并且将这个vma的valid修改为0。这个关闭的操作最好放到最后，因为我们可能在第3步还要写这个文件</li><li>如果需要写入，则通过filewrite函数写入磁盘，这个函数的参数很简单，第一个是文件的指针，第二个是起始的虚拟地址，第三个是length</li><li>将进程的页表给<code>uvmunmap</code>掉，因为lab的仁慈，这里的参数传递也很简单，addr全都是PGSIZE的倍数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先找到对应vma</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (addr &gt;= p-&gt;vmas[i].addr &amp;&amp; addr &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-comment">// 头部</span><br>            <span class="hljs-keyword">if</span> (vma-&gt;addr == addr) &#123;<br>                vma-&gt;addr += length;<br>                vma-&gt;length -= length;<br>                <span class="hljs-comment">// 尾部</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr + length == vma-&gt;addr + vma-&gt;length) &#123;<br>                vma-&gt;length -= length;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果是shared，需要先写回磁盘</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>        filewrite(vma-&gt;file, addr, length);<br>    &#125;<br>    <span class="hljs-comment">// 修改页表</span><br>    uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果map区域为0</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个小补丁要打，分别是<code>uvmunmap</code>和<code>uvmcopy</code>，它们在查找页表的时候，如果发现pte无效，会panic，这里直接忽略，因为可能是mmap还没有分配物理地址的区域</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>这个函数是用于进程死亡时，就所有的mmap区域都给删掉</p><ol><li>遍历进程的所有vma</li><li>如果vma有效<ol><li>如果需要写入磁盘，那就写入磁盘</li><li>更新页表</li><li>关闭文件</li><li>设置vma无效</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将所有的映射区取消</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>            filewrite(vma-&gt;file, vma-&gt;addr, vma-&gt;length);<br>        &#125;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>        uvmunmap(p-&gt;pagetable, vma-&gt;addr, vma-&gt;length / PGSIZE, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>这个函数主要用于子进程将父进程的mmap区域都给拷贝过来，要不然子进程一旦访问还没有分配物理地址的mmap区域，在usertrap里就不能正确处理它了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将父进程的mmap也拷贝给它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>    <span class="hljs-keyword">if</span> (vma-&gt;valid) &#123;<br>        memmove(&amp;np-&gt;vmas[i], vma, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vma));<br>        filedup(vma-&gt;file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
