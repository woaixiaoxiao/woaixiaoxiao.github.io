<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络程序设计_课程项目</title>
    <link href="/2023/12/21/lock-free-queue/"/>
    <url>/2023/12/21/lock-free-queue/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">为什么需要无锁队列？</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">无锁队列的实现（单读单写）</a><ul><li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">原子操作函数</a></li><li><a href="#yqueue_t%E7%9A%84chunk%E5%9D%97%E6%9C%BA%E5%88%B6">yqueue_t的chunk块机制</a><ul><li><a href="#chunk%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">chunk一次分配多个元素</a></li><li><a href="#chunk%E5%9D%97%E6%9C%BA%E5%88%B6-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">chunk块机制 局部性原理</a></li></ul></li><li><a href="#yqueue_t%E6%88%90%E5%91%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">yqueue_t成员和接口介绍</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0yqueue_t">构造函数yqueue_t</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0yqueue_t">析构函数~yqueue_t</a></li><li><a href="#frontback%E5%87%BD%E6%95%B0">front、back函数</a></li><li><a href="#push%E5%87%BD%E6%95%B0">push函数</a></li><li><a href="#unpush%E5%87%BD%E6%95%B0">unpush函数</a></li><li><a href="#pop">pop</a></li></ul></li><li><a href="#ypipe">ypipe</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96">如何写入和读取</a></li><li><a href="#%E8%AF%BB">读</a></li><li><a href="#wrfc%E8%AF%A6%E8%A7%A3">w,r,f,c详解</a><ul><li><a href="#ypipe_t">ypipe_t</a></li><li><a href="#write">write</a></li><li><a href="#flush">flush</a></li><li><a href="#read">read</a></li><li><a href="#check_read">check_read</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">整体思路梳理（单读单写）</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99">无锁队列的实现（多读多写）</a><ul><li><a href="#arraylockfreequeue">ArrayLockFreeQueue</a></li><li><a href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">函数介绍</a><ul><li><a href="#%E5%8F%96%E4%BD%99%E5%87%BD%E6%95%B0">取余函数</a></li><li><a href="#%E5%85%A5%E9%98%9F%E5%87%BD%E6%95%B0enqueue">入队函数enqueue</a></li><li><a href="#%E5%87%BA%E9%98%9F%E5%87%BD%E6%95%B0dequeue">出队函数dequeue</a></li><li><a href="#%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">多读多写的机制总结</a></li></ul></li><li><a href="#yield%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">yield的重要性</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93%E8%87%B4%E8%B0%A2">总结&amp;致谢</a></li></ul><h1 id="为什么需要无锁队列？"><a href="#为什么需要无锁队列？" class="headerlink" title="为什么需要无锁队列？"></a>为什么需要无锁队列？</h1><p>传统的高并发场景中，是使用阻塞机制来避免并发带来的各种问题。但是传统的阻塞机制有以下两个问题</p><ol><li>阻塞意味着线程要进行切换，而线程的切换会带来cache的失效。而cache作为存储体系中最重要的一环，频繁地失效肯定会带来极大的开销和性能损失</li><li>如果一个线程要处理的事情非常多，但是它却经常为了某个资源而被阻塞住，那肯定会降低系统的吞吐量，带来很高的延迟</li></ol><h1 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h1><h2 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">atomic_ptr_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T *ptr_)</span></span>; <span class="hljs-comment">//⾮原⼦操作</span><br>    <span class="hljs-function">T *<span class="hljs-title">xchg</span><span class="hljs-params">(T *val_)</span></span>; <span class="hljs-comment">//原⼦操作，设置⼀个新的值，然后返回旧的值</span><br>    <span class="hljs-function">T *<span class="hljs-title">cas</span><span class="hljs-params">(T *cmp_, T *val_)</span></span>;<span class="hljs-comment">//原⼦操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>set</code>是直接设置ptr的值</li><li><code>xchg</code>是设置ptr的值为val，并返回ptr设置之前的值</li><li><code>cas</code>是先比较<ol><li>若ptr和cmp相同，则设置ptr为val并返回ptr设置之前的值</li><li>若ptr和cmp不同，不设置ptr，直接返回ptr的值</li></ol></li></ol><h2 id="yqueue-t的chunk块机制"><a href="#yqueue-t的chunk块机制" class="headerlink" title="yqueue_t的chunk块机制"></a>yqueue_t的chunk块机制</h2><h3 id="chunk一次分配多个元素"><a href="#chunk一次分配多个元素" class="headerlink" title="chunk一次分配多个元素"></a>chunk一次分配多个元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunk_t</span> &#123;<br>   T values[N];<br>   <span class="hljs-type">chunk_t</span> *prev;<br>   <span class="hljs-type">chunk_t</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个chunk包含N个元素，因此可以减少分配内存的次数</p><p>会有一个spare_chunk的结构将空闲的chunk保存起来，需要的时候就可以直接拿出来用。在一个chunk空闲时，也不会直接删除，而是放入spare_chunk中</p><h3 id="chunk块机制-局部性原理"><a href="#chunk块机制-局部性原理" class="headerlink" title="chunk块机制 局部性原理"></a>chunk块机制 局部性原理</h3><p>利用局部性原理，可以将刚刚空闲的chunk放到spare_chunk中先保存着。如果后面马上就用上了，那就可以节省很多时间，而如果没用上，至少也可以省去重新分配动态内存的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br></code></pre></td></tr></table></figure><p>执行pop的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N) <span class="hljs-comment">// 删除满一个chunk才回收chunk</span><br>    &#123;<br>        <span class="hljs-comment">// 将空闲chunk的指针暂时保留下来</span><br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        <span class="hljs-comment">// 由于空闲chunk是边界，因此更新边界</span><br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将空闲chunk和上一个空闲chunk交换一下，然后将上一个给free掉</span><br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行push的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先取到最后一个chunk和chunk内部的pos</span><br>    back_chunk = end_chunk;<br>    back_pos = end_pos; <br>    <span class="hljs-comment">// 如果最后一个chunk还有空间，则不需要做其他的操作</span><br>    <span class="hljs-keyword">if</span> (++end_pos != N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果最后一个chunk没有空间了，则需要扩容，首先考虑一下spare_chunk是否有空闲的</span><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果有空闲的chunk，直接建立双向连接即可</span><br>    <span class="hljs-keyword">if</span> (sc)<br>    &#123;<br>        end_chunk-&gt;next = sc;<br>        sc-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有空闲的，先分配，再建立连接关系</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        end_chunk-&gt;next = (<span class="hljs-type">chunk_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>)); <br>        <span class="hljs-built_in">alloc_assert</span>(end_chunk-&gt;next);<br>        end_chunk-&gt;next-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 最后修改end_chunk即可</span><br>    end_chunk = end_chunk-&gt;next;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="yqueue-t成员和接口介绍"><a href="#yqueue-t成员和接口介绍" class="headerlink" title="yqueue_t成员和接口介绍"></a>yqueue_t成员和接口介绍</h2><p>可以将这个队列看成是一个双向链表，链表的每个节点都是一个chunk，包含了N个元素，其他的概念和普通的队列差不多。</p><p>三种chunk的区别</p><ol><li>begin_chunk指向队列头部，从这取出元素</li><li>back_chunk指向队列的最后一个元素所在的chunk，back_pos指向最后一个元素</li><li>end_chunk指向队列最后一个chunk</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yqueue_t</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">        struct chunk_t &#123;</span><br>            T values[N];<br>            <span class="hljs-type">chunk_t</span> *prev;<br>            <span class="hljs-type">chunk_t</span> *next;<br>        &#125;;<br>        <span class="hljs-type">chunk_t</span> *begin_chunk;<br>        <span class="hljs-type">int</span> begin_pos;<br>        <span class="hljs-type">chunk_t</span> *back_chunk;<br>        <span class="hljs-type">int</span> back_pos;<br>        <span class="hljs-type">chunk_t</span> *end_chunk;<br>        <span class="hljs-type">int</span> end_pos;<br>        <span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数yqueue-t"><a href="#构造函数yqueue-t" class="headerlink" title="构造函数yqueue_t"></a>构造函数yqueue_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化begin_chunk</span><br>    begin_chunk = (<span class="hljs-type">chunk_t</span> *)        <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>));<br>    <span class="hljs-built_in">alloc_assert</span>(begin_chunk);<br>    begin_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由于没有元素，因此back_chunk暂时失效</span><br>    back_chunk = <span class="hljs-literal">NULL</span>;<br>    back_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// end_chunk指向的是最后一个chunk，因此有效</span><br>    end_chunk = begin_chunk;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数-yqueue-t"><a href="#析构函数-yqueue-t" class="headerlink" title="析构函数~yqueue_t"></a>析构函数~yqueue_t</h3><p>销毁所有chunk资源</p><p>先遍历访问所有chunk，然后再检查spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (begin_chunk == end_chunk) &#123;<br>            <span class="hljs-built_in">free</span>(begin_chunk);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        <span class="hljs-built_in">free</span>(o);<br>    &#125;<br><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">free</span>(sc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="front、back函数"><a href="#front、back函数" class="headerlink" title="front、back函数"></a>front、back函数</h3><p>可以注意到，返回的都是引用，因此可以通过函数的返回值修改对应chunk的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> begin_chunk-&gt;values[begin_pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> back_chunk-&gt;values[back_pos];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h3><p>前面已经分析过</p><h3 id="unpush函数"><a href="#unpush函数" class="headerlink" title="unpush函数"></a>unpush函数</h3><p>用来回退push操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先处理back块</span><br>    <span class="hljs-comment">// 如果back块的pos是0，说明直接退到前一个去了，否则的话就简单减1就可以</span><br>     <span class="hljs-keyword">if</span> (back_pos)<br>         --back_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         back_pos = N - <span class="hljs-number">1</span>;<br>         back_chunk = back_chunk-&gt;prev;<br>     &#125;<br>    <span class="hljs-comment">// 再处理end块</span><br>    <span class="hljs-comment">// end块的pos如果为0，说明再退一步最后一个块就直接要被丢掉了，否则的话也是简单减1</span><br>     <span class="hljs-keyword">if</span> (end_pos)<br>         --end_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         end_pos = N - <span class="hljs-number">1</span>;<br>         end_chunk = end_chunk-&gt;prev;<br>         <span class="hljs-built_in">free</span>(end_chunk-&gt;next);<br>         end_chunk-&gt;next = <span class="hljs-literal">NULL</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop操作如果发现一个chunk为空了，需要执行xchg函数来处理空闲块，而这个函数必须是线程安全的。因为生产者和消费者分别调用push和pop时都可能使用这个spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N)<br>    &#123;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ypipe"><a href="#ypipe" class="headerlink" title="ypipe"></a>ypipe</h2><p>ypipe在yqueue的基础上进行封装，实现了一个可以单读单写的无锁队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ypipe_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ypipe_t</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">unwrite</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">probe</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*fn)(T &amp;))</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">yqueue_t</span>&lt;T, N&gt; queue;<br>    <span class="hljs-comment">// 指向第一个未刷新的元素</span><br>    T *w;<br>    <span class="hljs-comment">// 指向第一个等待读的元素</span><br>    T *r;<br>    <span class="hljs-comment">// 指向最后一个待刷新的元素</span><br>    T *f;<br>    <span class="hljs-comment">// 读写指针共享，指向每一轮刷新的起点</span><br>    <span class="hljs-type">atomic_ptr_t</span>&lt;T&gt; c;<br>    <span class="hljs-built_in">ypipe_t</span>(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>    <span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="如何写入和读取"><a href="#如何写入和读取" class="headerlink" title="如何写入和读取"></a>如何写入和读取</h3><p>首先看write函数，这个函数只会将更新底层的queue_t，并且在这一轮写结束的时候，即incomplete为false时，才更新f为待刷新的最后一个元素</p><p>在这里也可以看到queue_t的使用方法，先设置值，再调用push或者pop函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br><br>    <span class="hljs-comment">//  Move the &quot;flush up to here&quot; poiter.</span><br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是flush函数，再完成一波写入后，手动调用flush函数</p><p>flush函数就是更新了w和c两个指针</p><ol><li>w指针代表着已经写到哪了</li><li>c指针在读写线程之间共享<ol><li>读线程通过c知道是否读完了</li><li>写线程通过读线程是否将c设置为null知道读线程是否在睡眠</li></ol></li></ol><p>如果读线程在睡眠，返回false，否则返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果w和f相同，说明没有需要flush的东西</span><br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w)<br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>先检查是否有数据可读，如果没有，直接返回false</p><p>如果有数据可读，读出，并返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，check_read</p><ol><li>如果r指针存在且和queue的front不同，说明已经被预取了，直接返回true</li><li>如果待操作的c指针是queue的首元素，则直接返回false，代表没有预取元素</li><li>否则就说明可以读，返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果读线程调用read返回了false，则读线程应该阻塞自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (yqueue.<span class="hljs-built_in">read</span>(&amp;value)) &#123;<br>    <span class="hljs-comment">// 具体处理逻辑</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获得锁，然后通过条件变量阻塞自己</span><br>    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(ypipe_mutex_);<br>    ypipe_cond_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞一直到写进程写入数据，通过条件变量唤醒阻塞的读进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">yqueue.<span class="hljs-built_in">write</span>(count, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!yqueue.<span class="hljs-built_in">flush</span>()) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(ypipe_mutex_)</span></span>;<br>    ypipe_cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="w-r-f-c详解"><a href="#w-r-f-c详解" class="headerlink" title="w,r,f,c详解"></a>w,r,f,c详解</h3><p>首先看看在各个函数中，哪些指针被使用了</p><h4 id="ypipe-t"><a href="#ypipe-t" class="headerlink" title="ypipe_t"></a>ypipe_t</h4><p>在初始化函数中</p><ol><li>首先对队列调用一个push，为back赋予一个正常的值（这里面，在使用的时候，back永远指向一个空的位置，即可以直接赋值）</li><li>然后将四个指针都置为back</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span> </span>&#123;<br>    queue.<span class="hljs-built_in">push</span>();<br>    r = w = f = &amp;queue.<span class="hljs-built_in">back</span>(); <br>    c.<span class="hljs-built_in">set</span>(&amp;queue.<span class="hljs-built_in">back</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><ol><li><p>将一个值直接写到队列中。这里也证实了back就是指向一个空的位置，每次使用时，直接赋值然后++</p></li><li><p>重头戏来了，这里首次更新指针<code>f</code></p><p>如果这是这次写的最后一个（生产者可以一次性写一大堆数据），那么就会更新f指向当前队列的最后一个元素。待会在flush的时候会用上它</p></li></ol><p>这里是使用了一种机制，使得写操作不会马上呈现在消费者眼中，只会在生产者调用了flush之后消费者才能看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ol><li>如果w和f相同，说明没有需要flush的，直接返回true</li><li>比较c和w的值<ol><li>无论如何都会将c和w更新为f</li><li>如果c和w的值不同，c只可能是null，说明读线程被阻塞了，返回一个false提醒写线程唤醒读线程</li></ol></li></ol><p>flush函数的作用</p><ol><li>更新c和w，以告诉读线程，现在有新的数据可读</li><li>根据返回值告诉写线程读线程是否被阻塞了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w) <br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>对于读线程</p><ol><li>通过check_read判断是否可读，不可读的话直接返回不可读</li><li>可读的话直接开读</li></ol><p>因此关键在于check_read函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-read"><a href="#check-read" class="headerlink" title="check_read"></a>check_read</h4><ol><li>如果r指针有效，并且它不是front，即现在还有可读的数据，那么返回true，直接读</li><li>如果目前r指针不对劲，那么尝试更新r指针为c（如果现在有可读的数据，即生产者调用了flush，那c一定是最新的可读的边界）<ol><li>如果c也是队列头，说明现在根本就没数据，因此将c置为NULL</li><li>如果c不是队列头，那么不会改变c</li></ol></li><li>判断更新之后的r是否有效并且不是队列头，如果不满足的话，返回false，否则返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整体思路梳理（单读单写）"><a href="#整体思路梳理（单读单写）" class="headerlink" title="整体思路梳理（单读单写）"></a>整体思路梳理（单读单写）</h1><p>现在有一个队列，一个生产者和一个消费者</p><p>传统的思路就是用一把大锁，谁要用队列就直接锁上，这样一定会保证线程安全，但是这样太慢了</p><p>先尝试这样的优化思路</p><ol><li>生产者维护一个下标w，指向它生产到了哪里</li><li>消费者维护一个下标r，指向它可以一直读到哪个下标为止</li></ol><p>比如有个队列长为10，如果w&#x3D;5，r&#x3D;3</p><p>r&#x3D;3则表示消费者可以一直读到下标3处为止，比如1,2,3它都可以读</p><p>w&#x3D;5则表示，现在1,2,3,4,5都有东西可读</p><p>之所以w和r不一样，是因为w和r是分别存在于生产者和消费者线程内的，互相不可见，这样就不会有竞争条件</p><p>但是这样虽然没竞争，但是w和r肯定是要同步的，要不然消费者咋知道生产者生产了多少东西</p><p>既然要进行线程间的同步，那肯定要用到锁了。无锁队列采用的是CAS机制。首先全局有一个生产者和消费者都可以操作的变量c</p><ol><li>在生产者生产了一个东西放入队列后，它可以通过变量c的CAS机制将新的下标更新到c中。因为CAS机制，所以一定是线程安全的</li><li>在消费者发现自己已经读到了下标r后，它会试着用变量c的CAS机制来更新下标r，如果有更新，说明有新的可读，否则的话说明没东西读了</li></ol><p>因此，通过变量c，就可以将w和r联系起来，并且一定保证线程安全</p><p>但是还可以继续优化，如果频繁调用CAS机制，那可能还是比较耗费资源</p><ol><li>在生产者端，写入数据后，可以不急着更新到c中，等到写入一定量的数据后，再更新到c中，这样可以避免频繁调用CAS，并且这样一次就可以更新多个值，消费者那边效率也高些，不会说取一个就没了</li><li>在消费者端，其实已经是优化过的思路了，即r指针代表的是可以读到的位置，假如r等于5，而我们目前只读到2，那可以啥也不管地一直读3个，直到读到了r，这时候才需要考虑更新r</li></ol><p>在具体的实现中，还有一个f指针，主要是用于代码实现的，理解思路跟它没啥关系</p><p>至此，又优化了一波。还可以继续优化吗？</p><p>接下来可以从底层数据结构的角度进行优化</p><ol><li>首先，为了避免频繁调用malloc（除了系统调用的开销，它还会阻塞一个进程内的所有线程），可以一次分配一个N个元素的大块。并且可以缓存一个空闲的块，不马上销毁，也可以提升性能</li><li>其次，考虑到一个块太大了浪费，太小了不够用，可以以链表的形式将多个块串起来，这样就可以避免数组带来的连续空间的问题了</li></ol><h1 id="无锁队列的实现（多读多写）"><a href="#无锁队列的实现（多读多写）" class="headerlink" title="无锁队列的实现（多读多写）"></a>无锁队列的实现（多读多写）</h1><p>之前分析的单写单读无锁队列由于没有对w和r加锁，因此只能用于一个生产者一个消费者的情况。</p><h2 id="ArrayLockFreeQueue"><a href="#ArrayLockFreeQueue" class="headerlink" title="ArrayLockFreeQueue"></a>ArrayLockFreeQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;<br><span class="hljs-keyword">class</span> ArrayLockFreeQueue &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-function">QUEUE_INT <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ELEM_T &amp;a_data)</span></span>;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(ELEM_T &amp;a_data)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 环形数组</span><br>    ELEM_T m_thequeue[Q_SIZE];<br>    <span class="hljs-comment">// 队列内待处理的元素数量</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_count;<br>    <span class="hljs-comment">// 写坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_writeIndex;<br>    <span class="hljs-comment">// 读坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_readIndex;<br>    <span class="hljs-comment">// 最大的可读位置的坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_maximumReadIndex;<br>    <span class="hljs-comment">// 取余函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> QUEUE_INT <span class="hljs-title">countToIndex</span><span class="hljs-params">(QUEUE_INT a_count)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，m_maximumReadIndex不一定和m_writeIndex同步，因为申请空间后就会更新writeindex，但只有在数据写入之后，才会更新m_maximumReadIndex</p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p>循环队列，因此肯定要有取余的操作，直接mod数组的长度Q_SIZE即可</p><p>队列已满的判断条件：(write+1)%size&#x3D;&#x3D;read%size</p><p>队列为空的判断条件：write%size&#x3D;&#x3D;read%size</p><h3 id="入队函数enqueue"><a href="#入队函数enqueue" class="headerlink" title="入队函数enqueue"></a>入队函数enqueue</h3><ol><li>首先判断队列是否已经满了（获取全局的读和写指针），如果已经满了，直接返回false</li><li>如果队列有空位，尝试将写指针+1，如果失败，则回到第1步重新循环</li><li>如果写指针增加成功，那么将值写入更新前的位置（写指针指向的是空闲位置，更新之后，相当于指向的是下一次写的空闲位置）</li><li>最后尝试更新read最多可读到的位置，如果更新失败，则阻塞后再循环（这里有个很奇妙的地方，只有在read最多可读的位置的指针和当前指针相同时，才会将它更新到+1，这样就保证了这个值一定是一点一点地加1，不会出现多个线程乱操作的情况）</li></ol><p>总结来说，CAS很奇妙，使用它不仅是保证这次一定只有一个线程能访问到它正确的值，更是通过它和之前的值进行比较，保证了一定只有某个线程可以更新它</p><p>所以，使用CAS之前，应该拿到一个旧值，这样相当于一个通行证，只有它才能使用CAS更新某个变量为新值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">enqueue</span>(<span class="hljs-type">const</span> ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentWriteIndex;<br>    QUEUE_INT currentReadIndex;<br>    <span class="hljs-keyword">do</span> &#123;<br>        currentWriteIndex = m_writeIndex;<br>        currentReadIndex = m_readIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentWriteIndex + <span class="hljs-number">1</span>) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentReadIndex)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>)));<br>    m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentWriteIndex)] = a_data;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">sched_yield</span>();<br>    &#125;<br>    <span class="hljs-built_in">AtomicAdd</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队函数dequeue"><a href="#出队函数dequeue" class="headerlink" title="出队函数dequeue"></a>出队函数dequeue</h3><ol><li>先判断当前队列是否为空，如果空的话，直接返回false了。这里可能不太严谨，因为可能刚取完read和max的值，这两个值就被更新了，但是没关系，大不了再调用一次</li><li>取出队头的值，但是这不代表它正确取出了，原因如上所说，可能刚取完read和max的下标，这个下标就已经被别人修改了</li><li>如果现在全局的read指针和自己的指针相同，这才说明这个值应该是由自己取出来，否则的话说明已经被别人给取了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">dequeue</span>(ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentMaximumReadIndex;<br>    QUEUE_INT currentReadIndex;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        currentReadIndex = m_readIndex;<br>        currentMaximumReadIndex = m_maximumReadIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentReadIndex) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentMaximumReadIndex))    <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        a_data = m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentReadIndex)]; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CAS</span>(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-built_in">AtomicSub</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多读多写的机制总结"><a href="#多读多写的机制总结" class="headerlink" title="多读多写的机制总结"></a>多读多写的机制总结</h3><p>多读多写可以说就是在读层面和写层使用了同一个思想</p><ol><li>先建立一个所有线程共享的下标值</li><li>在每个线程试图去操作的时候，先取出当前的下标值，然后判断队空或者队满</li><li>如果自己可以操作的话，通过CAS判断目前这个点是否轮到自己操作了，即没有被其他线程抢先操作完了<ol><li>对于写线程来说，检查write的下标是否和自己记录的一样，一样的话，说明可以操作，否则循环重新去取下一个吧，这个已经被别人处理了</li><li>对于读线程来说也是这样，检查现在read的下标是否和自己记录的一样</li><li>当然了，对于写线程来说，它还需要多一个更新可读的最大下标的任务，同样是判断是否应该是自己操作。具体实现上通过之前记录的write下标即可</li></ol></li></ol><p>这里有个小坑，就是因为是循环数组，因此如果存的是智能指针，可能不会自动释放</p><h2 id="yield的重要性"><a href="#yield的重要性" class="headerlink" title="yield的重要性"></a>yield的重要性</h2><p>明明说是无锁队列，为什么还要用yield放弃cpu主动阻塞呢？</p><p>因为如果不主动让出cpu，当前线程可能会因为CAS操作失败而不断循环，即空转cpu，这种情况下，还不如让出cpu。</p><p>如果只有一个生产者，那么当然不需要yield，也不可能运行到yield语句，但是如果有很多个生产者，就需要考虑了。</p><h1 id="总结-致谢"><a href="#总结-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>无锁队列不是真的无锁，而是将锁的粒度设置地特别小，使得并发的性能尽量高。但是好像它只是在并发量特别高的时候才有很好的性能，普通情况下可能还不如直接用锁来的方便，所以还是要依据具体情况选择。</p><p>在科软的第一个学期已经要结束了，这学期的课基本也都上完了。只能说孟宁老师的《网络程序设计》真绝世好课，原因如下</p><ol><li>可以学到东西：几次实验包括了的epoll，grpc框架和消息队列，以及linux内核协议栈的调试（gcc调试方法）</li><li>课程内容也不会脱离找工作找实习：第1点里提到的基本都是C++面试必问的。有些课程虽然也能学到东西，但是对于找实习找工作，性价比太低</li><li>平时作业很轻松：以学到东西为主，没有很严格的考核机制</li><li>最后的大作业的自由度很高，可以借此机会选择自己感兴趣的方向深入学习一下</li></ol><p>最后，借此机会还搭建了个人博客，只能说，绝世好课！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab10</title>
    <link href="/2023/12/20/lab10%20mmap/"/>
    <url>/2023/12/20/lab10%20mmap/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231220221050424.png" alt="image-20231220221050424"></p><ul><li><a href="#task">task</a></li><li><a href="#hints">hints</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE">基础设置</a></li><li><a href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">增加数据结构</a></li><li><a href="#sys_mmap">sys_mmap</a></li><li><a href="#usertrap">usertrap</a></li><li><a href="#munmap">munmap</a></li><li><a href="#exit">exit</a></li><li><a href="#fork">fork</a></li></ul></li></ul><h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><hr><p>mmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ol><li><p>在这个lab中，addr永远为0，即内核决定用哪个虚拟地址去映射这个文件，mmap返回这个虚拟地址，或者0xffffffffffffffff 表示失败</p></li><li><p>length代表映射的字节数量，不一定要是文件的长度</p></li><li><p>prot决定了这个内存，可读，可写或者可执行</p><p> 具体的宏为PROT_READ、PROT_WRITE</p></li><li><p>flags如果是MAP_SHARED，意味着对内存的修改要写回到文件</p><p> MAP_PRIVATE意味着不用写回文件</p></li><li><p>fd是文件的描述符，你可以假设offset是0</p></li></ol><hr><p>munmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">munmap(addr, length)<br></code></pre></td></tr></table></figure><ol><li>munmap应该移出这些地址范围内的映射</li><li>如果进程修改了内存，并且映射方式是MAP_SHARED，那么修改应该被写回文件</li><li>munmap可能只覆盖了mmap的一部分区间，可以是开始，可以是末尾，也可能是整个，但不会是中间位置</li></ol><h1 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h1><ol><li><p>首先在Makefile中添加_mmaptest，并且增加mmap和munmap系统调用</p><p> 在<code>kernel/fcntl.h</code>为你定义了<code>PROT_READ</code>等参数</p></li><li><p>lazy地对待页表，类似于lazy lab。</p><p> 即mmap并不会直接分配物理内存和读文件，在usertrap中处理页错误时再真正的分配内存</p></li><li><p>你需要记录每个进程通过mmap映射了什么</p><p> 你可以定义一个和VMA相关的数据结构，去记录地址，长度，权限，文件等</p><p> 你可以定义一个固定长度的VMA数组，16就足够了</p></li><li><p>实现mmap</p><ol><li><p>在进程的地址空间找一块未使用的区域去映射文件</p></li><li><p>并且增加一个VMA到进程映射区域的表中</p><ol><li>VMA应该包含一个指向<code>struct file</code>的指针。mmap应该增加这个文件的引用，这一部分可以参考<code>filedup</code></li></ol></li><li><p>这时候运行mmaptest，可以发现第一个成功了，但是后面的还是失败了</p></li></ol></li><li><p>增加代码</p><ol><li>在页错误发生在mapped区域时，分配一个物理页面，从相关的文件中读取4096个字节，并且将其映射到用户地址空间</li><li>用readi读取文件，它会使用到一个offset参数，同时你需要将inode结点给lock和unlock</li><li>不要忘记设置这一页的权限位</li><li>运行mmaptest，这时候会运行到munmap了</li></ol></li><li><p>实现munmap</p><ol><li>找到这个地址范围内的VMA，unmap指定的页面，使用<code>uvmunmap</code></li><li>如果munmap删除了mmap分配的所有区域，那它应该减少文件的引用次数</li><li>如果一个页面是MAP_SHARED，并且被修改了，那么应该写回文件（学习<code>filewrite</code>）。写回时不需要管pte的dirty位</li></ol></li><li><p>修改exit函数，使其能够在进程用过mmap的情况下，将没有被munmap都处理掉，至此mmap_test可能可以通过了</p></li><li><p>修改fork保证孩子也有和父节点一样的映射区域，不要忘记了去给VMA文件增加引用数。在页错误发生时，可以分配一个新的物理页面，而不是和父进程共享一个。</p></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>首先需要修改Makefile并且添加两个系统调用，这个就比较简单了</p><h2 id="增加数据结构"><a href="#增加数据结构" class="headerlink" title="增加数据结构"></a>增加数据结构</h2><p>我们应该按照hints提示的，创造一个VMA的结构体，并且在进程的proc的结构体中存储一个VMA的数组。这里的思路就比较简单暴力了，就只维护一个数组，需要用的时候就遍历数组去找就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> &#123;</span><br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> prot;<br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> valid;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[16];</span><br>    <span class="hljs-comment">//.......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h2><p>开始写<code>mmap</code>函数</p><ol><li>这玩意的作用就是只申请一个虚拟地址空间，但是不直接分配物理地址。在申请完之后，就将相关的东西存在proc的VMA数组中去</li><li>有几个情况需要特判<ol><li>如果文件不可读，那么就不能用<code>MAP_SHARED</code>，因为这种模式在之后会写入到磁盘</li><li>地址不够了，即<code>p-&gt;sz&gt;MAXVA</code></li></ol></li><li>注意点<ol><li>只分配虚拟内存，不增加物理内存，就是通过只增加<code>p-&gt;sz</code>而不真正的映射实现的。包括页表中都没有相关的记录</li><li>用<code>argfd</code>取出文件指针</li><li>记得用<code>filedup</code>增加文件的引用计数</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> length, prot, flags, offest;<br>    uint64 erro = <span class="hljs-number">0xffffffffffffffff</span>;<br><br>    <span class="hljs-comment">// 取出参数</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span><br>        || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span><br>        || argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;file) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">5</span>, &amp;offest) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 权限不对</span><br>    <span class="hljs-keyword">if</span> (file-&gt;writable == <span class="hljs-number">0</span> &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 地址不够了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (p-&gt;sz + length &gt; MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 分配地址，找出一个空闲的vma</span><br>    addr = p-&gt;sz;<br>    p-&gt;sz += length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            p-&gt;vmas[i].addr = addr;<br>            p-&gt;vmas[i].flag = flags;<br>            p-&gt;vmas[i].length = length;<br>            p-&gt;vmas[i].prot = prot;<br>            p-&gt;vmas[i].file = file;<br>            filedup(file);<br>            <span class="hljs-keyword">return</span> addr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> erro;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>修改<code>usertrap</code>函数，使得vma相关的地址能够被正确处理</p><ol><li>首先应该通过<code>r_scause</code>捕获异常</li><li>判断地址的合法性<ol><li>压根不在vma管辖范围内<ol><li>不能超出当前进程的虚拟地址范围，即<code>p-&gt;sz</code></li><li>不能低于栈区</li><li>在进程的vma数组中找不到对应的地址</li></ol></li><li>权限合法性<ol><li>通过<code>r_scause</code>可以知道当前是读还是写操作，通过文件的类型，可以确定是否有这个权限</li></ol></li></ol></li><li><code>kalloc</code>分配一个物理页面</li><li><code>readi</code>将文件的内容读入物理页面，其中偏移部分通过当前地址和vma记录的addr做差值得到，因为一读就是一个页面，因此还要将这个偏移向PGSIZE舍入</li><li>将映射关系通过<code>uvmmap</code>写入到页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-comment">// #ifdef LAB_MMAP</span><br>        <span class="hljs-keyword">if</span> (mmap_handler(r_stval(), r_scause()) == <span class="hljs-number">-1</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// #endif</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <br>    <br><span class="hljs-type">int</span> mmap_handler(uint64 va, uint64 r_cause) &#123;<br>    <span class="hljs-keyword">struct</span> proc *p = myproc();<br>    <span class="hljs-comment">// 地址不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否和vma有关系</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (va &gt;= p-&gt;vmas[i].addr &amp;&amp; va &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 和vma没关系</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 和vma是有关的</span><br>    <span class="hljs-comment">// 看看权限是否正确</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> vma-&gt;file;<br>    <span class="hljs-comment">// 不能读，但是你读了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;readable &amp;&amp; r_cause == <span class="hljs-number">13</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不能写，但是你写了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;writable &amp;&amp; r_cause == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 构建pte的标志位</span><br>    <span class="hljs-type">int</span> pte_flag = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;<br>        pte_flag |= PTE_R;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;<br>        pte_flag |= PTE_W;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;<br>        pte_flag |= PTE_X;<br>    &#125;<br>    <span class="hljs-comment">// 先分配一个物理页面</span><br>    uint64 pa = (uint64)kalloc();<br>    <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// 成功分配物理页面，从文件中读</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span> =</span> file-&gt;ip;<br>    ilock(ip);<br>    <span class="hljs-comment">// 读取失败</span><br>    <span class="hljs-keyword">if</span> (readi(ip, <span class="hljs-number">0</span>, pa, PGROUNDDOWN(va - vma-&gt;addr), PGSIZE) == <span class="hljs-number">0</span>) &#123;<br>        iunlock(ip);<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlock(ip);<br>    <span class="hljs-comment">// 加入映射</span><br>    <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, pa, pte_flag) != <span class="hljs-number">0</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><blockquote><p>lab对munmap的情况做了简化，只会从头开始unmap，因此在将数据写回磁盘时，直接调用filewrite函数，它在内部会自动调用file的偏移</p></blockquote><p>munmap就是取消某部分虚拟地址的mmap</p><ol><li>在进程的vma数组找到对应的vma</li><li>更新vma中的addr和length，如果当前length&#x3D;0，说明全部被写入了，那么就通过fileclose关闭这个文件，并且将这个vma的valid修改为0。这个关闭的操作最好放到最后，因为我们可能在第3步还要写这个文件</li><li>如果需要写入，则通过filewrite函数写入磁盘，这个函数的参数很简单，第一个是文件的指针，第二个是起始的虚拟地址，第三个是length</li><li>将进程的页表给<code>uvmunmap</code>掉，因为lab的仁慈，这里的参数传递也很简单，addr全都是PGSIZE的倍数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先找到对应vma</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (addr &gt;= p-&gt;vmas[i].addr &amp;&amp; addr &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-comment">// 头部</span><br>            <span class="hljs-keyword">if</span> (vma-&gt;addr == addr) &#123;<br>                vma-&gt;addr += length;<br>                vma-&gt;length -= length;<br>                <span class="hljs-comment">// 尾部</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr + length == vma-&gt;addr + vma-&gt;length) &#123;<br>                vma-&gt;length -= length;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果是shared，需要先写回磁盘</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>        filewrite(vma-&gt;file, addr, length);<br>    &#125;<br>    <span class="hljs-comment">// 修改页表</span><br>    uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果map区域为0</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个小补丁要打，分别是<code>uvmunmap</code>和<code>uvmcopy</code>，它们在查找页表的时候，如果发现pte无效，会panic，这里直接忽略，因为可能是mmap还没有分配物理地址的区域</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>这个函数是用于进程死亡时，就所有的mmap区域都给删掉</p><ol><li>遍历进程的所有vma</li><li>如果vma有效<ol><li>如果需要写入磁盘，那就写入磁盘</li><li>更新页表</li><li>关闭文件</li><li>设置vma无效</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将所有的映射区取消</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>            filewrite(vma-&gt;file, vma-&gt;addr, vma-&gt;length);<br>        &#125;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>        uvmunmap(p-&gt;pagetable, vma-&gt;addr, vma-&gt;length / PGSIZE, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>这个函数主要用于子进程将父进程的mmap区域都给拷贝过来，要不然子进程一旦访问还没有分配物理地址的mmap区域，在usertrap里就不能正确处理它了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将父进程的mmap也拷贝给它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>    <span class="hljs-keyword">if</span> (vma-&gt;valid) &#123;<br>        memmove(&amp;np-&gt;vmas[i], vma, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vma));<br>        filedup(vma-&gt;file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab2</title>
    <link href="/2023/07/30/csapp-lab2/"/>
    <url>/2023/07/30/csapp-lab2/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202009.png" alt="20231224202009"></p><h1 id="寄存器相关的知识"><a href="#寄存器相关的知识" class="headerlink" title="寄存器相关的知识"></a>寄存器相关的知识</h1><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202024.png" alt="20231224202024"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202037.png" alt="20231224202037"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202045.png" alt="20231224202045"></p><h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对bomb可执行文件进行调试</span><br>gdb bomb<br><span class="hljs-comment">// 通过disas指令可以通过反汇编操作查看phase_1这个函数的汇编代码</span><br>disas phase_1<br><span class="hljs-comment">// 或者可以直接通过这个指令生成整个反汇编文件</span><br>objdump -d bomb &gt; bomb.s<br></code></pre></td></tr></table></figure><ol><li>通过下面这个文件可以发现，read_line函数的结果rax放入了rdi寄存器，也就是作为phase_1函数的第一个参数，然后调用了phase_1函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">400e32</span>:e8 <span class="hljs-number">67</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40149</span>e &lt;read_line&gt;<br><span class="hljs-number">400e37</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-number">400e3</span>a:e8 a1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">400</span>ee0 &lt;phase_1&gt;<br></code></pre></td></tr></table></figure></li><li>在phase_1函数中，又将0x402400放入esi寄存器，调用了strings_not_equal函数。</li><li>此时rdi寄存器存的是readline函数的结果，esi寄存器存的是一个地址，分别作为strings_not_equal函数第一个和第二个参数。</li><li>因此可以猜测，我们需要输入的就是0x402400这个地方存的字符串。通过<code>x/s 0x402400</code>即可获得这个字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dump of assembler code <span class="hljs-keyword">for</span> function phase_1:<br>   <span class="hljs-comment">// 函数调用时的压栈操作</span><br>   <span class="hljs-number">0x0000000000400ee0</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-comment">// 将0x402400这个地址放入esi寄存器</span><br>   <span class="hljs-comment">// 作为strings_not_equal的一个参数</span><br>   <span class="hljs-number">0x0000000000400ee4</span> &lt;+<span class="hljs-number">4</span>&gt;:     mov    $<span class="hljs-number">0x402400</span>,%esi<br>   <span class="hljs-number">0x0000000000400ee9</span> &lt;+<span class="hljs-number">9</span>&gt;:     callq  <span class="hljs-number">0x401338</span> &lt;strings_not_equal&gt;<br>   <span class="hljs-comment">// 将eax和eax寄存器进行按位与操作，并把结果放入标志寄存器</span><br>   <span class="hljs-comment">// eax是上面那个函数的返回值，如果eax为0，说明这两个字符是相同的</span><br>   <span class="hljs-number">0x0000000000400eee</span> &lt;+<span class="hljs-number">14</span>&gt;:    test   %eax,%eax<br>   <span class="hljs-comment">// 如果零标志位为1，则je成功运行，即躲过explode_bomb</span><br>   <span class="hljs-comment">// 也就是说零标志位如果是0，代表eax不是0，那么就会爆炸</span><br>   <span class="hljs-number">0x0000000000400ef0</span> &lt;+<span class="hljs-number">16</span>&gt;:    je     <span class="hljs-number">0x400ef7</span> &lt;phase_1+<span class="hljs-number">23</span>&gt;<br>   <span class="hljs-comment">// 爆炸</span><br>   <span class="hljs-number">0x0000000000400ef2</span> &lt;+<span class="hljs-number">18</span>&gt;:    callq  <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x0000000000400ef7</span> &lt;+<span class="hljs-number">23</span>&gt;:    add    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">0x0000000000400efb</span> &lt;+<span class="hljs-number">27</span>&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure></li></ol><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>反汇编代码如下<br>这个phase的大意是通过sccanf读取我们输入的6个数字，如果能够满足是1 2 4 8 16 32的话，那就可以通过。<br>结合着汇编代码去看，应该不难理解这个phase的意思。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400</span>efc &lt;phase_2&gt;:<br>  <span class="hljs-number">400</span>efc:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">400</span>efd:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">400</span>efe:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">28</span>          sub    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>02:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi<br>  <span class="hljs-number">400f</span>05:e8 <span class="hljs-number">52</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt;<br>  <span class="hljs-number">400f</span>0a:<span class="hljs-number">83</span> <span class="hljs-number">3</span>c <span class="hljs-number">24</span> <span class="hljs-number">01</span>          cmpl   $<span class="hljs-number">0x1</span>,(%rsp) <span class="hljs-comment">// 栈指针指向的内存的值应该是1</span><br>  <span class="hljs-number">400f</span>0e:<span class="hljs-number">74</span> <span class="hljs-number">20</span>                je     <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>10:e8 <span class="hljs-number">25</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>15:eb <span class="hljs-number">19</span>                jmp    <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>17:<span class="hljs-number">8b</span> <span class="hljs-number">43</span> fc             mov    <span class="hljs-number">-0x4</span>(%rbx),%eax <span class="hljs-comment">// 将rbx-4的位置的内存值给到eax</span><br>  <span class="hljs-number">400f</span>1a:<span class="hljs-number">01</span> c0                add    %eax,%eax <span class="hljs-comment">// eax乘2</span><br>  <span class="hljs-number">400f</span>1c:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 即eax乘2后，要等于rbx指向的值，eax实际上是rbx下面的一个值</span><br>  <span class="hljs-number">400f</span>1e:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>25 &lt;phase_2+<span class="hljs-number">0x29</span>&gt;<br>  <span class="hljs-number">400f</span>20:e8 <span class="hljs-number">15</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>25:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c3 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rbx <span class="hljs-comment">// 再给rbx+4</span><br>  <span class="hljs-number">400f</span>29:<span class="hljs-number">48</span> <span class="hljs-number">39</span> eb             cmp    %rbp,%rbx<br>  <span class="hljs-number">400f</span>2c:<span class="hljs-number">75</span> e9                jne    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt; <span class="hljs-comment">// 重复</span><br>  <span class="hljs-number">400f</span>2e:eb <span class="hljs-number">0</span>c                jmp    <span class="hljs-number">400f</span>3c &lt;phase_2+<span class="hljs-number">0x40</span>&gt; <span class="hljs-comment">//结束当前程序</span><br>  <span class="hljs-number">400f</span>30:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">04</span>       lea    <span class="hljs-number">0x4</span>(%rsp),%rbx <span class="hljs-comment">// 栈顶指针+4，给到rbx</span><br>  <span class="hljs-number">400f</span>35:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">6</span>c <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rbp <span class="hljs-comment">// 栈顶指针+24，给到rbp，即栈底指针</span><br>  <span class="hljs-number">400f</span>3a:eb db                jmp    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt;<br>  <span class="hljs-number">400f</span>3c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">28</span>          add    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>40:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">400f</span>41:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">400f</span>42:c3                   retq   <br></code></pre></td></tr></table></figure><p>但是有个问题就是，我们输入的应该是正序还是倒序的？这个需要结合read_six_numbers来看了。</p><ol><li>这个函数其实关键是调用了sscanf函数，解析我们输入的字符串</li><li>而sccanf的参数为<code>int sscanf(const char *str, const char *format, ...)</code>，其中后面的省略号就是通过str解析出来的结果，可能有多个，在这里，就是6个数字。</li><li>可以发现，这里将0x4025c3放入了esi，即作为sscanf的第二个参数，那么说明这个地址存放的东西就是解析的format，通过打印这个地址的值可以发现就是”%d %d %d %d %d %d”，说明除了str和format，我们还需要传递六个参数。</li><li>可以发现，第一个参数rdi，这里没有显式地设置，因为这个rdi从phase_2函数开始就没有变过，一直都是我们输入的字符串。</li><li>read_six_numbers在调用sscanf之前的那么多行，其实就是在传递后面的六个参数，也就是第3个到第8个参数。</li><li>通过前几行就可以发现，第1个值被放在了rsi处，而rsi其实就是phase_2的栈顶位置，也就是说第一个被解析出来的值放在栈底，也就是1。因此我们的字符串应该是从1开始增长，而不是从32开始逆序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040145</span>c &lt;read_six_numbers&gt;:<br>  <span class="hljs-number">40145</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401460</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> f2             mov    %rsi,%rdx <span class="hljs-comment">// 第3个参数，也是被解析的第一个值</span><br>  <span class="hljs-number">401463</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">04</span>          lea    <span class="hljs-number">0x4</span>(%rsi),%rcx <span class="hljs-comment">// 第4个参数，也是被解析的第二个值</span><br>  <span class="hljs-number">401467</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">14</span>          lea    <span class="hljs-number">0x14</span>(%rsi),%rax<br>  <span class="hljs-number">40146b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       mov    %rax,<span class="hljs-number">0x8</span>(%rsp)<br>  <span class="hljs-number">401470</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">10</span>          lea    <span class="hljs-number">0x10</span>(%rsi),%rax<br>  <span class="hljs-number">401474</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>          mov    %rax,(%rsp)<br>  <span class="hljs-number">401478</span>:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">0</span>c          lea    <span class="hljs-number">0xc</span>(%rsi),%r9<br>  <span class="hljs-number">40147</span>c:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">08</span>          lea    <span class="hljs-number">0x8</span>(%rsi),%r8<br>  <span class="hljs-number">401480</span>:be c3 <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $,%esi<br>  <span class="hljs-number">401485</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">40148</span>a:e8 <span class="hljs-number">61</span> f7 ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">40148f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax<br>  <span class="hljs-number">401492</span>:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">401499</span> &lt;read_six_numbers+<span class="hljs-number">0x3d</span>&gt;<br>  <span class="hljs-number">401494</span>:e8 a1 ff ff ff       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401499</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">40149</span>d:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>这个phase会让你输入两个数字</p><ul><li>第一个数字是介于0-6之间的数，小于7即可</li><li>第二个数字根据第一个数字，通过switch指令进行跳转<br>一开始做的时候还没看懂那个switch的跳转指令。通过gdb调试不断往下走才确定了我输入的6对应的是哪个位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>43 &lt;phase_3&gt;:<br>  <span class="hljs-number">400f</span>43:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 减小栈指针，挪出24字节的空间</span><br>  <span class="hljs-number">400f</span>47:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 栈指针+12 给rcx</span><br>  <span class="hljs-number">400f</span>4c:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 栈指针+8 给rdx</span><br>  <span class="hljs-number">400f</span>51:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// %d %d，sscanf的参数</span><br>  <span class="hljs-number">400f</span>56:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>5b:e8 <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">400f</span>60:<span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 匹配成功的数目要大于1，即大于等于2，应该是2</span><br>  <span class="hljs-number">400f</span>63:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">400f</span>6a &lt;phase_3+<span class="hljs-number">0x27</span>&gt;<br>  <span class="hljs-number">400f</span>65:e8 d0 <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>6a:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0x7</span>,<span class="hljs-number">0x8</span>(%rsp) <br>  <span class="hljs-number">400f</span>6f:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400f</span>ad &lt;phase_3+<span class="hljs-number">0x6a</span>&gt; <span class="hljs-comment">// 7如果大于rsp+8指向的值，则直接爆炸</span><br>  <span class="hljs-number">400f</span>71:<span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%eax <span class="hljs-comment">// rsp+8指向的值给eax</span><br>  <span class="hljs-number">400f</span>75:ff <span class="hljs-number">24</span> c5 <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) <span class="hljs-comment">// 间接寻址0x402470+8*rax，其实这里就是个switch操作，根据你输入的第一个数字是0-6，给你传送到下面对应的mov</span><br>  <span class="hljs-number">400f</span>7c:b8 cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xcf</span>,%eax <span class="hljs-comment">// 将eax置为0xcf，即11001111 15+64+128=207</span><br>  <span class="hljs-number">400f</span>81:eb <span class="hljs-number">3b</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>83:b8 c3 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2c3</span>,%eax<br>  <span class="hljs-number">400f</span>88:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>8a:b8 <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x100</span>,%eax<br>  <span class="hljs-number">400f</span>8f:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>91:b8 <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x185</span>,%eax<br>  <span class="hljs-number">400f</span>96:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>98:b8 ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xce</span>,%eax<br>  <span class="hljs-number">400f</span>9d:eb <span class="hljs-number">1f</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>9f:b8 aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2aa</span>,%eax<br>  <span class="hljs-number">400f</span>a4:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>a6:b8 <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x147</span>,%eax<br>  <span class="hljs-number">400f</span>ab:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>ad:e8 <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>b2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>b7:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>b9:b8 <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x137</span>,%eax<br>  <span class="hljs-number">400f</span>be:<span class="hljs-number">3b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0xc</span>(%rsp),%eax <span class="hljs-comment">// 比较eax是否等于rsp+12指向的值</span><br>  <span class="hljs-number">400f</span>c2:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>c9 &lt;phase_3+<span class="hljs-number">0x86</span>&gt; <span class="hljs-comment">// 等于的话，直接退出程序</span><br>  <span class="hljs-number">400f</span>c4:e8 <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 不等于的话，就爆炸</span><br>  <span class="hljs-number">400f</span>c9:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">400f</span>cd:c3                   retq   <br></code></pre></td></tr></table></figure></li></ul><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>phase_4反汇编的代码如下<br>要求我们两个数字，其中第一个数字要小于等于14，第二个数字必须为0。其中第一个数字要通过func4函数，并且使其返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040100</span>c &lt;phase_4&gt;:<br>  <span class="hljs-number">40100</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 栈指针下移，挪出24字节的位置</span><br>  <span class="hljs-number">401010</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 将rcx置为栈顶指针+12</span><br>  <span class="hljs-number">401015</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 将rdx置为栈顶指针+8</span><br>  <span class="hljs-number">40101</span>a:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// </span><br>  <span class="hljs-number">40101f</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">401024</span>:e8 c7 fb ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">401029</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0x2</span>,%eax<br>  <span class="hljs-number">40102</span>c:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401035</span> &lt;phase_4+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果输入参数个数不是两个，直接爆炸</span><br>  <span class="hljs-number">40102</span>e:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>e       cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) <span class="hljs-comment">// 将14 和 栈顶指针+8指向的值 比较</span><br>  <span class="hljs-number">401033</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; <span class="hljs-comment">// 如果小于等于，则跳过炸弹继续执行</span><br>  <span class="hljs-number">401035</span>:e8 <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果大于则直接爆炸</span><br>  <span class="hljs-number">40103</span>a:ba <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xe</span>,%edx <span class="hljs-comment">// 将edx置为14，func4的第3个参数</span><br>  <span class="hljs-number">40103f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// 将esi置为0，func4的第2个参数</span><br>  <span class="hljs-number">401044</span>:<span class="hljs-number">8b</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%edi <span class="hljs-comment">// 将rsp+8指向的值给edi，func4的第1个参数</span><br>  <span class="hljs-number">401048</span>:e8 <span class="hljs-number">81</span> ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 调用一个函数</span><br>  <span class="hljs-number">40104</span>d:<span class="hljs-number">85</span> c0                test   %eax,%eax <span class="hljs-comment">// 如果eax不为0，则直接爆炸</span><br>  <span class="hljs-number">40104f</span>:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401058</span> &lt;phase_4+<span class="hljs-number">0x4c</span>&gt; <span class="hljs-comment">// eax不为0，跳到炸弹那里去</span><br>  <span class="hljs-number">401051</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span>       cmpl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xc</span>(%rsp) <span class="hljs-comment">// 比较0和rsp+12指向的值</span><br>  <span class="hljs-number">401056</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">40105</span>d &lt;phase_4+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果rsp+12指向的值就是0，则通过</span><br>  <span class="hljs-number">401058</span>:e8 dd <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">40105</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401061</span>:c3                   retq<br></code></pre></td></tr></table></figure><p>func4函数的反汇编的代码</p><ol><li>func4是一个递归程序，这个代码如果要完全弄清楚，非常复杂，有一些大佬将其一步步分析成C语言代码，但是依然很恶心。不过如果只是想要通过，就没那么难。</li><li>首先，func4有3个参数，第一个参数就是我们输入的第一个数字，第二个参数固定为0，第三个参数固定为14</li><li>在func4的第一次跳转之前，ecx一定是7。然后我们用第一个数字和ecx即7比较，如果小于等于7就会跳转。</li><li>跳转之后，又用我们第一个数字和ecx即7进行比较，如果小于等于7，就会直接结束函数，并且返回0</li><li>因此，可以发现，7就是一个答案。并且是最简单的那个，都不会触发递归。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>ce &lt;func4&gt;:<br>  <span class="hljs-number">400f</span>ce:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">400f</span>d2:<span class="hljs-number">89</span> d0                mov    %edx,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d4:<span class="hljs-number">29</span> f0                sub    %esi,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d6:<span class="hljs-number">89</span> c1                mov    %eax,%ecx <span class="hljs-comment">// ecx被置为14</span><br>  <span class="hljs-number">400f</span>d8:c1 e9 <span class="hljs-number">1f</span>             shr    $<span class="hljs-number">0x1f</span>,%ecx <span class="hljs-comment">// ecx被置为0</span><br>  <span class="hljs-number">400f</span>db:<span class="hljs-number">01</span> c8                add    %ecx,%eax <span class="hljs-comment">// eax被置为14 0b1110</span><br>  <span class="hljs-number">400f</span>dd:d1 f8                sar    %eax <span class="hljs-comment">// eax被置为0b111，即7</span><br>  <span class="hljs-number">400f</span>df:<span class="hljs-number">8</span>d <span class="hljs-number">0</span>c <span class="hljs-number">30</span>             <span class="hljs-built_in">lea</span>    (%rax,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// ecx被置为7</span><br>  <br>  <span class="hljs-number">400f</span>e2:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// x和7比较</span><br>  <span class="hljs-number">400f</span>e4:<span class="hljs-number">7</span>e <span class="hljs-number">0</span>c                jle    <span class="hljs-number">400f</span>f2 &lt;func4+<span class="hljs-number">0x24</span>&gt; <span class="hljs-comment">// 如果x&lt;=7，跳转</span><br>  <span class="hljs-number">400f</span>e6:<span class="hljs-number">8</span>d <span class="hljs-number">51</span> ff             lea    <span class="hljs-number">-0x1</span>(%rcx),%edx<br>  <span class="hljs-number">400f</span>e9:e8 e0 ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt;<br>  <span class="hljs-number">400f</span>ee:<span class="hljs-number">01</span> c0                add    %eax,%eax<br>  <span class="hljs-number">400f</span>f0:eb <span class="hljs-number">15</span>                jmp    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt;<br>  <br>  <span class="hljs-number">400f</span>f2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置为0</span><br>  <span class="hljs-number">400f</span>f7:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// 将x和7比较</span><br>  <span class="hljs-number">400f</span>f9:<span class="hljs-number">7</span>d <span class="hljs-number">0</span>c                jge    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt; <span class="hljs-comment">// 如果大于等于7，则直接跳出程序</span><br>  <span class="hljs-number">400f</span>fb:<span class="hljs-number">8</span>d <span class="hljs-number">71</span> <span class="hljs-number">01</span>             lea    <span class="hljs-number">0x1</span>(%rcx),%esi <span class="hljs-comment">// 将esi置为8</span><br>  <span class="hljs-number">400f</span>fe:e8 cb ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 递归</span><br>  <span class="hljs-number">401003</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0x1</span>(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>  <span class="hljs-number">401007</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">40100b</span>:c3                   retq   <br></code></pre></td></tr></table></figure>我刚开始做phase4的时候，陷入了func4这个函数里，完全搞不清楚它在干啥。这也有了一个教训，看汇编代码的时候，不要陷进去汇编的细节，要能够提取它的作用，用C语言的形式去想一下，或者想一想它具体在完成什么动作。</li></ol><h1 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h1><p>这个炸弹很有意思</p><ol><li>首先阅读汇编代码，搞清楚每个语句的作用，然后按照代码的逻辑给它划分，看的更加有层次感，最后搞清楚每个层次都干了什么</li><li>首先，这个phase需要我们输入一个长度为6的字符串</li><li>然后根据我们这些字符串的ascii码的二进制表示的最低4位的值为偏移，去系统给出的一个字符串取字符</li><li>根据输入的6个字符取出来的6个字符需要刚好和系统给定的另一个字符串相同<br>做的时候踩了些坑</li><li>第一遍阅读汇编代码的时候，就可以尝试去划分和理解，不用等到完全读了一遍之后再来划分。这样效率其实很低。耐下心来正确地分析代码，还是可以在第一遍读代码的时候就理解代码的逻辑的。这样就算没有很清楚，也可以通过第二轮去专门划分</li><li>有的时候各种寄存器一波操作，其实就是完成了一个很简单的逻辑，不要迷失在细节里了</li><li>分清楚传的是寄存器的值还是这个寄存器指向的内存的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000401062</span> &lt;phase_5&gt;:<br><span class="hljs-comment">// 将fs:0x28的值放到rsp+24字节的位置</span><br>  <span class="hljs-number">401062</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">401063</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>          sub    $<span class="hljs-number">0x20</span>,%rsp <span class="hljs-comment">// 给栈挪出32字节的位置</span><br>  <span class="hljs-number">401067</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> fb             mov    %rdi,%rbx <span class="hljs-comment">// 将我们的输入给rbx</span><br>  <span class="hljs-number">40106</span>a:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> mov    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将段寄存器偏移40字节的值给rax</span><br>  <span class="hljs-number">401071</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">401073</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    %rax,<span class="hljs-number">0x18</span>(%rsp) <span class="hljs-comment">// 将rax给栈顶指针+24字节的位置</span><br><br><span class="hljs-comment">// 判断输入字符串的长度是否是6，如果不是6则直接爆炸</span><br>  <span class="hljs-number">401078</span>:<span class="hljs-number">31</span> c0                <span class="hljs-keyword">xor</span>    %eax,%eax <span class="hljs-comment">// eax清零</span><br>  <span class="hljs-number">40107</span>a:e8 <span class="hljs-number">9</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40131b</span> &lt;string_length&gt; <span class="hljs-comment">// 获取我们输入的字符串的长度</span><br>  <span class="hljs-number">40107f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>             cmp    $<span class="hljs-number">0x6</span>,%eax <span class="hljs-comment">// 判断是否是6</span><br>  <span class="hljs-number">401082</span>:<span class="hljs-number">74</span> <span class="hljs-number">4</span>e                je     <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt; <span class="hljs-comment">// 如果是6的话，则跳过炸弹</span><br>  <span class="hljs-number">401084</span>:e8 b1 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果不是6，则直接爆炸</span><br>  <span class="hljs-number">401089</span>:eb <span class="hljs-number">47</span>                jmp    <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt;<br><br><span class="hljs-comment">// 这一段就是把我们输入的字符串通过一些奇怪的处理，放置在栈上rsp+16开始的位置，16-21</span><br><span class="hljs-comment">// 这个奇怪的处理应该是根据我们输入的字符，用它们的ascii码为偏移，去0x4024b0地址取字符放到rsp+16开始的位置</span><br>  <span class="hljs-number">40108b</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">0</span>c <span class="hljs-number">03</span>          <span class="hljs-built_in">movzbl</span> (%rbx,%rax,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 将rbx+rax指向的值放入ecx，这里的rbx就是我们的输入，这里应该就是依次把字符给ecx</span><br>  <span class="hljs-number">40108f</span>:<span class="hljs-number">88</span> <span class="hljs-number">0</span>c <span class="hljs-number">24</span>             mov    %cl,(%rsp) <span class="hljs-comment">// 将ecx的值为栈顶指向的位置</span><br>  <span class="hljs-number">401092</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">14</span> <span class="hljs-number">24</span>          <span class="hljs-built_in">mov</span>    (%rsp),%rdx <span class="hljs-comment">// 把栈顶的值给edx</span><br>  <span class="hljs-number">401096</span>:<span class="hljs-number">83</span> e2 <span class="hljs-number">0f</span>             <span class="hljs-keyword">and</span>    $<span class="hljs-number">0xf</span>,%edx <span class="hljs-comment">// 用0b1111与edx按位与</span><br>  <span class="hljs-number">401099</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">92</span> b0 <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> movzbl <span class="hljs-number">0x4024b0</span>(%rdx),%edx <span class="hljs-comment">// 将0x4024b0+edx指向的值给edx</span><br>  <span class="hljs-number">4010</span>a0:<span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">04</span> <span class="hljs-number">10</span>          mov    %dl,<span class="hljs-number">0x10</span>(%rsp,%rax,<span class="hljs-number">1</span>) <span class="hljs-comment">// 将edx的值放到16+rsp+rax指向的位置</span><br>  <span class="hljs-number">4010</span>a4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%rax <span class="hljs-comment">// 给rax+1</span><br>  <span class="hljs-number">4010</span>a8:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%rax <span class="hljs-comment">// 6和rax比较</span><br>  <span class="hljs-number">4010</span>ac:<span class="hljs-number">75</span> dd                jne    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果不同，则继续循环</span><br><br><span class="hljs-comment">// 判断我们放在栈上的字符串是否和0x40245e这个地址的字符一样</span><br>  <span class="hljs-number">4010</span>ae:c6 <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span>       movb   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x16</span>(%rsp) <span class="hljs-comment">// 将rsp+22指向的值置为0</span><br>  <span class="hljs-number">4010b</span>3:be <span class="hljs-number">5</span>e <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x40245e</span>,%esi <span class="hljs-comment">// 给esi一个地址0x40245e // &quot;flyers&quot;</span><br>  <span class="hljs-number">4010b</span>8:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">10</span>       lea    <span class="hljs-number">0x10</span>(%rsp),%rdi <span class="hljs-comment">// 给rdi一个地址rsp+16 // &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br>  <span class="hljs-number">4010b</span>d:e8 <span class="hljs-number">76</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401338</span> &lt;strings_not_equal&gt; <span class="hljs-comment">// 比较这两个地址指向的字符串</span><br>  <span class="hljs-number">4010</span>c2:<span class="hljs-number">85</span> c0                test   %eax,%eax <br>  <span class="hljs-number">4010</span>c4:<span class="hljs-number">74</span> <span class="hljs-number">13</span>                je     <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt; <span class="hljs-comment">// 如果字符串相同，则跳过炸弹</span><br>  <span class="hljs-number">4010</span>c6:e8 <span class="hljs-number">6f</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果字符串不相同，则爆炸</span><br>  <span class="hljs-number">4010</span>cb:<span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0x0</span>(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-number">4010</span>d0:eb <span class="hljs-number">07</span>                jmp    <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt;<br><br>  <span class="hljs-number">4010</span>d2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置0</span><br>  <span class="hljs-number">4010</span>d7:eb b2                jmp    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 跳转</span><br><br><span class="hljs-comment">// 比较%fs:0x2和栈上0x18(%rsp)开始的值是否一样，一样则成功。这个测试正常来说不会有问题。</span><br>  <span class="hljs-number">4010</span>d9:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    <span class="hljs-number">0x18</span>(%rsp),%rax <span class="hljs-comment">// 将rsp+24指向的值给rax</span><br>  <span class="hljs-number">4010</span>de:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将rax和一个地址的值异或</span><br>  <span class="hljs-number">4010e5</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">4010e7</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4010</span>ee &lt;phase_5+<span class="hljs-number">0x8c</span>&gt; <span class="hljs-comment">// 如果等于0，则跳过下面这个函数，成功返回</span><br>  <span class="hljs-number">4010e9</span>:e8 <span class="hljs-number">42</span> fa ff ff       callq  <span class="hljs-number">400b</span>30 &lt;__stack_chk_fail@plt&gt;<br>  <span class="hljs-number">4010</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">20</span>          add    $<span class="hljs-number">0x20</span>,%rsp<br>  <span class="hljs-number">4010f</span>2:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4010f</span>3:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h1><p>这个lab也很有意思啊</p><ol><li>首先，它需要我们输入六个数字</li><li>其次，它要求我们这个六个数字都小于等于6，并且不重复</li><li>然后，它会把我们这六个数字替换为7-x，即如果输入是123456，就会被替换成654321</li><li>然后，它会根据现在的数字，去一个链表里取6个数字。比如我们现在的数字被变成了6454321，那么它就会去这个链表里取出从第六个到第一个结点的地址。再将这个地址放到栈中从rsp+0x20开始的地方</li><li>然后，它会依次把取出来的六个结点串成一个链表</li><li>最后，它会检查这个链表是否是一个单调递减链表<br>因此，我们输入的六个数字其实就相当于是一个排序的方法，如果我们输入214356，那就代表着我们把原链表里的顺序从123456改为214356，然后判断修改之后是否是单调递减的。注意，这里说的123456指的是链表的结点编号，排序的依据是这个节点的val。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004010f</span>4 &lt;phase_6&gt;:<br><span class="hljs-comment">// 准备操作</span><br>  <span class="hljs-number">4010f</span>4:<span class="hljs-number">41</span> <span class="hljs-number">56</span>                push   %r14<br>  <span class="hljs-number">4010f</span>6:<span class="hljs-number">41</span> <span class="hljs-number">55</span>                push   %r13<br>  <span class="hljs-number">4010f</span>8:<span class="hljs-number">41</span> <span class="hljs-number">54</span>                push   %r12<br>  <span class="hljs-number">4010f</span>a:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">4010f</span>b:<span class="hljs-number">53</span>                   push   %rbx<br><span class="hljs-comment">// 开始操作</span><br>  <span class="hljs-number">4010f</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">50</span>          sub    $<span class="hljs-number">0x50</span>,%rsp <span class="hljs-comment">// 开辟了80个字节的栈空间</span><br>  <span class="hljs-number">401100</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e5             mov    %rsp,%r13 <span class="hljs-comment">// 将栈顶指针给r13</span><br>  <span class="hljs-number">401103</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi <span class="hljs-comment">// 将栈顶指针给了rsi，即函数的第二个参数</span><br>  <span class="hljs-number">401106</span>:e8 <span class="hljs-number">51</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt; <span class="hljs-comment">// 将我们输入的6个数字读入栈中</span><br>  <span class="hljs-number">40110b</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e6             mov    %rsp,%r14 <span class="hljs-comment">// 把栈指针给了r14</span><br>  <span class="hljs-number">40110</span>e:<span class="hljs-number">41</span> bc <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    $<span class="hljs-number">0x0</span>,%r12d <span class="hljs-comment">// 将r12置为0</span><br><br><span class="hljs-comment">// 下面这一波就是判断，是否六个数字都不同，并且六个数字都小于等于6</span><br>  <span class="hljs-number">401114</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> ed             mov    %r13,%rbp <span class="hljs-comment">// 把r13给rbp，rbp是栈底指针啊</span><br>  <span class="hljs-number">401117</span>:<span class="hljs-number">41</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>          mov    <span class="hljs-number">0x0</span>(%r13),%eax <span class="hljs-comment">// 把r13指向的东西赋给了eax，r13现在是栈底，应该就是我们输入的第一个数字</span><br>  <span class="hljs-number">40111b</span>:<span class="hljs-number">83</span> e8 <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 将输入的第一个数字减1</span><br>  <span class="hljs-number">40111</span>e:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax <span class="hljs-comment">// 5和输入的数字进行比较</span><br>  <span class="hljs-number">401121</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">401128</span> &lt;phase_6+<span class="hljs-number">0x34</span>&gt; <span class="hljs-comment">// 输入的数字减1后小于等于5，则跳过炸弹，否则爆炸</span><br>  <span class="hljs-number">401123</span>:e8 <span class="hljs-number">12</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401128</span>:<span class="hljs-number">41</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%r12d <span class="hljs-comment">// 给r12加1,r12在这之前刚被置为0</span><br>  <span class="hljs-number">40112</span>c:<span class="hljs-number">41</span> <span class="hljs-number">83</span> fc <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%r12d <span class="hljs-comment">// 6和r12对比，如果一样则跳转，第一次到这里应该是不会跳转</span><br>  <span class="hljs-number">401130</span>:<span class="hljs-number">74</span> <span class="hljs-number">21</span>                je     <span class="hljs-number">401153</span> &lt;phase_6+<span class="hljs-number">0x5f</span>&gt;<br>  <span class="hljs-number">401132</span>:<span class="hljs-number">44</span> <span class="hljs-number">89</span> e3             mov    %r12d,%ebx <span class="hljs-comment">// 将r12给ebx，即ebx置为1</span><br><span class="hljs-comment">// 下面这一段是判断输入的第2到第6数是否都不和第1个数相同，如果存在相同的，则直接爆炸</span><br>  <span class="hljs-number">401135</span>:<span class="hljs-number">48</span> <span class="hljs-number">63</span> c3             movslq %ebx,%rax <span class="hljs-comment">// 将ebx给rax，rax=1</span><br>  <span class="hljs-number">401138</span>:<span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">84</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rax,<span class="hljs-number">4</span>),%eax <span class="hljs-comment">// eax=rsp+4*rax指向的值，第一次运行到这里应该是rsp+4，访问的是输入的第2个数字</span><br>  <span class="hljs-number">40113b</span>:<span class="hljs-number">39</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>             cmp    %eax,<span class="hljs-number">0x0</span>(%rbp) <span class="hljs-comment">// eax和rbp指向的值比较,即第一个数和第二个数进行比较</span><br>  <span class="hljs-number">40113</span>e:<span class="hljs-number">75</span> <span class="hljs-number">05</span>                jne    <span class="hljs-number">401145</span> &lt;phase_6+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果不同，则跳转，否则就爆炸</span><br>  <span class="hljs-number">401140</span>:e8 f5 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401145</span>:<span class="hljs-number">83</span> c3 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%ebx <span class="hljs-comment">// ebx+=1</span><br>  <span class="hljs-number">401148</span>:<span class="hljs-number">83</span> fb <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%ebx <span class="hljs-comment">// ebx和5进行对比，如果ebx小于等于5，则跳转</span><br>  <span class="hljs-number">40114b</span>:<span class="hljs-number">7</span>e e8                jle    <span class="hljs-number">401135</span> &lt;phase_6+<span class="hljs-number">0x41</span>&gt;<br><span class="hljs-comment">// 给r13加4</span><br>  <span class="hljs-number">40114</span>d:<span class="hljs-number">49</span> <span class="hljs-number">83</span> c5 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%r13<br>  <span class="hljs-number">401151</span>:eb c1                jmp    <span class="hljs-number">401114</span> &lt;phase_6+<span class="hljs-number">0x20</span>&gt;<br><br>  <span class="hljs-number">401153</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rsi <span class="hljs-comment">// 将rsi指向rsp+24的位置</span><br>  <span class="hljs-number">401158</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> f0             mov    %r14,%rax <span class="hljs-comment">// 把r14给rax，第一次运行到这里的时候r14这时候就是rsp</span><br>  <span class="hljs-number">40115b</span>:b9 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x7</span>,%ecx <span class="hljs-comment">// ecx置为7</span><br><span class="hljs-comment">// 这是一个小循环，循环6次，将我们输入的数，都换成7-x</span><br>  <span class="hljs-number">401160</span>:<span class="hljs-number">89</span> ca                mov    %ecx,%edx <span class="hljs-comment">// edx置为7</span><br>  <span class="hljs-number">401162</span>:<span class="hljs-number">2b</span> <span class="hljs-number">10</span>                <span class="hljs-built_in">sub</span>    (%rax),%edx <span class="hljs-comment">// 7-rsp指向的值</span><br>  <span class="hljs-number">401164</span>:<span class="hljs-number">89</span> <span class="hljs-number">10</span>                mov    %edx,(%rax) <span class="hljs-comment">// 再将7-rsp指向的值放到rsp指向的位置</span><br>  <span class="hljs-number">401166</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rax <span class="hljs-comment">// rax+4</span><br>  <span class="hljs-number">40116</span>a:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// rsi和rax比较</span><br>  <span class="hljs-number">40116</span>d:<span class="hljs-number">75</span> f1                jne    <span class="hljs-number">401160</span> &lt;phase_6+<span class="hljs-number">0x6c</span>&gt; <span class="hljs-comment">// 如果不一样，则继续循环</span><br><span class="hljs-comment">// 现在栈顶的6个数字分别是，6 5 4 3 2 1</span><br><span class="hljs-comment">// 下面的操作是根据栈顶的六个数字，去一个链表里取结点</span><br>  <span class="hljs-number">40116f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// esi置为0</span><br>  <span class="hljs-number">401174</span>:eb <span class="hljs-number">21</span>                jmp    <span class="hljs-number">401197</span> &lt;phase_6+<span class="hljs-number">0xa3</span>&gt; <span class="hljs-comment">// 跳转</span><br><br>  <span class="hljs-number">401176</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">52</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rdx),%rdx <span class="hljs-comment">// rdx+8指向的值放到rdx中</span><br>  <span class="hljs-number">40117</span>a:<span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax+1</span><br>  <span class="hljs-number">40117</span>d:<span class="hljs-number">39</span> c8                cmp    %ecx,%eax <span class="hljs-comment">// ecx中存放的是我们输入的数字，</span><br>  <span class="hljs-number">40117f</span>:<span class="hljs-number">75</span> f5                jne    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt; <span class="hljs-comment">// 如果不同的话，就不断循环</span><br><br>  <span class="hljs-number">401181</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">401188</span> &lt;phase_6+<span class="hljs-number">0x94</span>&gt;<br>  <span class="hljs-number">401183</span>:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx<br><br>  <span class="hljs-number">401188</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">54</span> <span class="hljs-number">74</span> <span class="hljs-number">20</span>       mov    %rdx,<span class="hljs-number">0x20</span>(%rsp,%rsi,<span class="hljs-number">2</span>) <span class="hljs-comment">// 6304544 6304528 6304512 6304496 6304480 0x6032d0</span><br>  <span class="hljs-number">40118</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c6 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rsi<br>  <span class="hljs-number">401191</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fe <span class="hljs-number">18</span>          cmp    $<span class="hljs-number">0x18</span>,%rsi<br>  <span class="hljs-number">401195</span>:<span class="hljs-number">74</span> <span class="hljs-number">14</span>                je     <span class="hljs-number">4011</span>ab &lt;phase_6+<span class="hljs-number">0xb7</span>&gt;<br><br>  <span class="hljs-number">401197</span>:<span class="hljs-number">8b</span> <span class="hljs-number">0</span>c <span class="hljs-number">34</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 取出栈顶的元素放到ecx</span><br>  <span class="hljs-number">40119</span>a:<span class="hljs-number">83</span> f9 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%ecx <span class="hljs-comment">// 元素和1相比</span><br>  <span class="hljs-number">40119</span>d:<span class="hljs-number">7</span>e e4                jle    <span class="hljs-number">401183</span> &lt;phase_6+<span class="hljs-number">0x8f</span>&gt; <span class="hljs-comment">// 如果元素小于等于1，则跳转</span><br>  <span class="hljs-number">40119f</span>:b8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax置为1</span><br>  <span class="hljs-number">4011</span>a4:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx <span class="hljs-comment">// edx置为0x6032d0</span><br>  <span class="hljs-number">4011</span>a9:eb cb                jmp    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt;<br><br><span class="hljs-comment">// 上面的操作花了这么大牛劲，就是把6304544 6304528 6304512 6304496 6304480 0x6032d0这六个地址放在了rsp+32 +0 +8 +16 +24 +32 +40的位置 好像刚好放满了这个栈</span><br>  <span class="hljs-number">4011</span>ab:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">20</span>       mov    <span class="hljs-number">0x20</span>(%rsp),%rbx <span class="hljs-comment">// 把rbx置为rsp+32指向的值</span><br>  <span class="hljs-number">4011b</span>0:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">28</span>       lea    <span class="hljs-number">0x28</span>(%rsp),%rax <span class="hljs-comment">// 把rax置为rsp+40，即上述操作栈的第二个元素的位置</span><br>  <span class="hljs-number">4011b</span>5:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">50</span>       lea    <span class="hljs-number">0x50</span>(%rsp),%rsi <span class="hljs-comment">// 把rsi置为rsp+80，即整个栈的终点</span><br>  <span class="hljs-number">4011b</span>a:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d9             mov    %rbx,%rcx <span class="hljs-comment">// 把rcx置为第一个值</span><br>  <span class="hljs-comment">// 这里好像是循环着把一个链表给串起来</span><br>  <span class="hljs-number">4011b</span>d:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">10</span>             <span class="hljs-built_in">mov</span>    (%rax),%rdx <span class="hljs-comment">// 把rdx置为第二个值</span><br>  <span class="hljs-number">4011</span>c0:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">51</span> <span class="hljs-number">08</span>          mov    %rdx,<span class="hljs-number">0x8</span>(%rcx) <span class="hljs-comment">// 把第二个值放到rcx+8指向的位置</span><br>  <span class="hljs-number">4011</span>c4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rax <span class="hljs-comment">// rax+=1，即指向下一个值</span><br>  <span class="hljs-number">4011</span>c8:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// 比较是否到了终点</span><br>  <span class="hljs-number">4011</span>cb:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4011</span>d2 &lt;phase_6+<span class="hljs-number">0xde</span>&gt; <span class="hljs-comment">// 到了终点则跳转</span><br>  <span class="hljs-number">4011</span>cd:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d1             mov    %rdx,%rcx <span class="hljs-comment">// 否则将rcx变成rdx，即变成第二个点</span><br>  <span class="hljs-number">4011</span>d0:eb eb                jmp    <span class="hljs-number">4011b</span>d &lt;phase_6+<span class="hljs-number">0xc9</span>&gt;<br> <span class="hljs-comment">// 将链表最后一个节点的next指针置为0</span><br>  <span class="hljs-number">4011</span>d2:<span class="hljs-number">48</span> c7 <span class="hljs-number">42</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x8</span>(%rdx) <br>  <span class="hljs-number">4011</span>d9:<span class="hljs-number">00</span> <br><span class="hljs-comment">// 链表降序排序 443 477 691 924 168 332</span><br>  <span class="hljs-number">4011</span>da:bd <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x5</span>,%ebp <span class="hljs-comment">// ebp置为5</span><br>  <span class="hljs-number">4011</span>df:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">43</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rax <span class="hljs-comment">// 此时rbx是第一个结点的地址，因此rax是第二个结点的地址</span><br>  <span class="hljs-number">4011e3</span>:<span class="hljs-number">8b</span> <span class="hljs-number">00</span>                <span class="hljs-built_in">mov</span>    (%rax),%eax  <span class="hljs-comment">// 将eax置为第二个结点</span><br>  <span class="hljs-number">4011e5</span>:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 比较第二个结点和第一个结点的值</span><br>  <span class="hljs-number">4011e7</span>:<span class="hljs-number">7</span>d <span class="hljs-number">05</span>                jge    <span class="hljs-number">4011</span>ee &lt;phase_6+<span class="hljs-number">0xfa</span>&gt; <span class="hljs-comment">// 第一个如果要大于等于第二个，那么就跳过炸弹，否则就爆炸</span><br>  <span class="hljs-number">4011e9</span>:e8 <span class="hljs-number">4</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">4011</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5b</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rbx<br>  <span class="hljs-number">4011f</span>2:<span class="hljs-number">83</span> ed <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%ebp<br>  <span class="hljs-number">4011f</span>5:<span class="hljs-number">75</span> e8                jne    <span class="hljs-number">4011</span>df &lt;phase_6+<span class="hljs-number">0xeb</span>&gt;<br>  <span class="hljs-number">4011f</span>7:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">50</span>          add    $<span class="hljs-number">0x50</span>,%rsp<br>  <span class="hljs-number">4011f</span>b:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4011f</span>c:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">4011f</span>d:<span class="hljs-number">41</span> <span class="hljs-number">5</span>c                pop    %r12<br>  <span class="hljs-number">4011f</span>f:<span class="hljs-number">41</span> <span class="hljs-number">5</span>d                pop    %r13<br>  <span class="hljs-number">401201</span>:<span class="hljs-number">41</span> <span class="hljs-number">5</span>e                pop    %r14<br>  <span class="hljs-number">401203</span>:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab1</title>
    <link href="/2023/07/26/csapp-lab1/"/>
    <url>/2023/07/26/csapp-lab1/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#bitxor">bitXor</a></li><li><a href="#tmin">tmin</a></li><li><a href="#istmax">isTmax</a></li><li><a href="#alloddbits">allOddBits</a></li><li><a href="#negate">negate</a></li><li><a href="#isasciidigit">isAsciiDigit</a></li><li><a href="#conditional">conditional</a></li><li><a href="#islessorequal">isLessOrEqual</a></li><li><a href="#logicalneg">logicalNeg</a></li><li><a href="#howmanybits">howManyBits</a></li><li><a href="#floatscale2">floatScale2</a></li><li><a href="#floatfloat2int">floatFloat2Int</a></li><li><a href="#floatpower2">floatPower2</a></li></ul><p>修改<code>bits.c</code>，使其满足<code>btest</code>的测试，代码规范<code>./dlc bits.c</code><br>测试</p><ol><li>make clean</li><li>make btest</li><li>.&#x2F;btest</li></ol><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224201936.png" alt="20231224201936"></p><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><p>思路</p><ol><li>题目的意思是用按位&amp;和取反~实现异或^操作。</li><li>即x和y的同一位置如果都是1或者都是0，那么异或之后是0，否则是1<ol><li>x &amp; y的结果的某一位为1，代表x和y的这一位都是1。而如果x和y的某一位都是1，那么经过异或操作时候，这一位应该是0，所以对这个结果取反，得到a。a的二进制表示中，每一个0都代表这个位置的x和y都是1。</li><li>刚刚处理了x和y同一位置都是1，现在应该处理两个位置都是0。可以通过先分别对x和y取反，将这个问题又转为处理同一位置为1。通过和上一步一样的操作，可以得到b。</li><li>a和b的二进制表示中，每一个0都代表x和y在这个位置同时是0或者同时是1。那么将a&amp;b就得到了异或的结果，即相同为0，不同为1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp;</span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 两个1的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> a = ~(x &amp; y);<br>  <span class="hljs-comment">// 两个0的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> b = ~(~x &amp; ~y);<br>  <span class="hljs-comment">// 因此将a和b按位&amp;之后，两个1或者两个0的位置都是0，其他位置是1</span><br>  <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><p>思路</p><ol><li>送分题<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><p>思路</p><ol><li>验证x是不是最大的有符号整数，最大的有符号整数应该是0x7fffffff，记为tmax</li><li>如果只能用位运算，那么要尽量将操作的数往0或者0xffffffff上靠，可以发现tmax+tmax+1正好就是0xffffffff。拿到了0xffffffff，那就好办了，对它取反，正好得到0，也就是下面代码里的b</li><li>那么是不是只有tmax可以通过~(x+x+1)的操作得到0呢，不是！0xffffffff也是可以得到0的。因此还需要对它进行特判。它加上1或者取反正好就是0,再取个非，刚好就是1，也就是下面代码里的c。</li><li>综上所述，b为0，并且c也等于0，才能够证明x是Tmax<br>易错点</li><li>这一题相当于是根据Tmax的特点进行一些操作，得到一个只有Tmax才能经过这一系列操作得到的值。但是还有一个边界情况那就是0xffffffff需要特判。写代码的时候要小心这些corn case<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0xffffffff，这一步不能用异或</span><br>  <span class="hljs-type">int</span> a = x + x + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 0x00000000，如果b为0，那么b要么是0x3fffffff，要么是0xffffffff</span><br>  <span class="hljs-type">int</span> b = ~a;<br>  <span class="hljs-comment">// 排除x为0xffffffff，如果x是0xffffffff，那么c就是1，否则c就是0</span><br>  <span class="hljs-type">int</span> c = !(x + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 只有b和c都是0，才返回1</span><br>  <span class="hljs-keyword">return</span> !(b | c);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><p>思路</p><ol><li>这一题要判断这个数是否满足：所有的奇数位都是1</li><li>那么可以通过0xAAAAAAAA这个数与x进行按位与，将取出所有的奇数位，并将偶数为置0</li><li>如果这个数所有奇数位都是1，那么它现在应该和0xAAAAAAAA相同。相同的话异或为0，再取个反，刚好是1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 构造出奇数位均为1的数</span><br>  <span class="hljs-type">int</span> a = (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">24</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">16</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xaa</span>;<br>  <span class="hljs-comment">// 将a看做掩码，取出x中所有奇数位</span><br>  <span class="hljs-type">int</span> b = x &amp; a;<br>  <span class="hljs-comment">// 判断a和b是否相同，只有当a和b相同，异或才为0，那么取！后才为1</span><br>  <span class="hljs-keyword">return</span> !(a ^ b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><p>思路</p><ol><li>送分题，按位取反，末位加1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * negate - return -x</span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> (~x) + <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><p>思路</p><ol><li>判断这个数是否在$0x30 &lt;&#x3D; x &lt;&#x3D; 0x39$这个范围内</li><li>这个范围可以写成十六进制，即<ol><li>0x 0011 0000</li><li>0x 0011 1001</li></ol></li><li>可以发现，高28位一定是0x0000003，低4位则在0x0到0x9之间。<ol><li>所以先将高28位取出来，判断是否是0x0000003</li><li>再将低4位取出来<ol><li>低4位里，如果第4位是0，那么对低三位则没有要求</li><li>如果第4位是1，那么第二位和第三位一定是0，对低1位没有要求</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27;</span><br><span class="hljs-comment"> * to &#x27;9&#x27;) Example: isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0x 0011 0000</span><br>  <span class="hljs-comment">// 0x 0011 1001</span><br>  <span class="hljs-comment">// 首先，右移4位之后，应该是0x3，即a=1</span><br>  <span class="hljs-type">int</span> a = !((x &gt;&gt; <span class="hljs-number">4</span>) ^ (<span class="hljs-number">0x3</span>));<br>  <span class="hljs-comment">// 低4位，要么第4位为0，要么就只能是1001或者1000</span><br>  <span class="hljs-comment">// b为1，代表第4位为0</span><br>  <span class="hljs-type">int</span> b = !((x &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// c为1，代表为1001或者1000，即第1位和第4位无所谓，但是第2和第3位必须是0</span><br>  <span class="hljs-type">int</span> c = !(x &amp; <span class="hljs-number">0x6</span>);<br>  <span class="hljs-comment">// printf(&quot;-----------------\n%x\n%d\n%d\n%d\n%d\n&quot;,x,a,b,c,a&amp;(b|c));</span><br>  <span class="hljs-keyword">return</span> a &amp; (b | c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><p>思路</p><ol><li>实现三目运算符</li><li>主要是看x，如果x不为0，那么返回y，如果x为0，那么返回z。</li><li>这个做法就有点tricky<ol><li>如果x不为0，那么将x变为0xffffffff</li><li>如果x为0，那么将x变为0 </li><li>在上面改变的基础上，<ol><li>如果x不为0，那么应该返回y，此时的x经过变换之后是全1<ol><li>将x和y按位与，按位与的结果就是y</li><li>将~x和z按位与，按位与的结果是0</li><li>将上述两个结果进行按位或操作，得到的就是y</li></ol></li><li>之所以使用按位或操作，是因为如果x为0，依然可以返回正确结果。此时x和y按位与就是0，~x和z按位与的结果就是z，按位或之后的结果就是z</li><li>如何将非0的x变为全1呢？首先通过两次！操作，可以把非零的x变为1，此时对它取反再加1就是全1了</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * conditional - same as x ? y : z</span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>  <span class="hljs-comment">// 如果x不为0，则得到一个全1的数，如果x为0，则得到一个全0的数</span><br>  <span class="hljs-comment">// 如果x为0，则得到0，如果x非0，则得到1</span><br>  <span class="hljs-type">int</span> a = !!x;<br>  <span class="hljs-comment">// 如果a为0，则b为0，如果a为1，则b为-1，即全1</span><br>  <span class="hljs-type">int</span> b = ~a + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// c和d一定有一个为0</span><br>  <span class="hljs-type">int</span> c = b &amp; y;<br>  <span class="hljs-type">int</span> d = ~b &amp; z;<br>  <span class="hljs-keyword">return</span> c | d;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><p>思路</p><ol><li>判断x是否小于等于y</li><li>如果x和y符号不同<ol><li>如果x为负数，则小于y</li><li>如果x为正数，则大于y</li></ol></li><li>如果x和y符号相同，则需要计算x和y的差值，因为不可以直接用减号，计算x-y，其实就是计算x+（y的补码）<ol><li>如果差值小于0，则小于y</li><li>如果差值大于0，则大于y</li></ol></li><li>还需要特判一下x是否等于y<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 如果符号不同，则正数更大，如果符号相同，则看差值，还要特判一下x是否和y相同</span><br>  <span class="hljs-type">int</span> x_flag = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> y_flag = y &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果flag_not_same为1，则代表符号不同，如果为0，则代表符号相同</span><br>  <span class="hljs-type">int</span> flag_not_same = x_flag ^ y_flag;<br>  <span class="hljs-comment">// 还要结合差值的正负来看,x-y，即x+(y的补码)</span><br>  <span class="hljs-type">int</span> y_ = ~y + <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> sub_flag = (x + y_) &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果符号不同并且x为负，即a=1，即x_flag=1，并且flag_not_same=1，</span><br>  <span class="hljs-type">int</span> a = flag_not_same &amp; x_flag;<br>  <span class="hljs-comment">// 如果符号相同，并且差值为负，即b=1，即flag_same=0,sub_flag=1;</span><br>  <span class="hljs-type">int</span> b = !(flag_not_same | (!sub_flag));<br>  <span class="hljs-comment">// 如果两个数相同，则c为1，否则c为0</span><br>  <span class="hljs-type">int</span> c = !(x ^ y);<br>  <span class="hljs-keyword">return</span> a | b | c;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><p>思路</p><ol><li>对于0，返回1，对于非0的数，返回0</li><li>其实只需要对确定x是0后返回1，其他情况都是返回0</li><li>做法很tricky<ol><li>首先，对于任何符号位为0的数，加上Tmax之后，只有0不会导致溢出为负数。</li><li>因此只需要满足下面两个条件就可以返回1，否则返回0<ol><li>x的符号位是0</li><li>x+Tmax之后的符号位也是0</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of</span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 先得到最大的32位有符号数</span><br>  <span class="hljs-type">int</span> T_max = ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);<br>  <span class="hljs-comment">// 得到x的符号</span><br>  <span class="hljs-type">int</span> x_sign = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 将x和T_max相加，除了0，其他的数加上去之后一定是一个负数</span><br>  <span class="hljs-type">int</span> a = x + T_max;<br>  <span class="hljs-type">int</span> a_sign = a &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 只有当x和a的sign都是0时，才返回1，否则返回0</span><br>  <span class="hljs-keyword">return</span> (x_sign ^ <span class="hljs-number">1</span>) &amp; (a_sign ^ <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><p>思路</p><ol><li>如果用补码来表示x，最少需要多少位？</li><li>首先对于正数，符号位一定是0，因此只需要找到最高位的1</li><li>其次对于负数，符号位一定是1，需要找到最高位的0，因为高位连续多个1其实就相当于一个1。为了方便起见，将负数取反，那么就和正数一样变成求最高位的1的问题。</li><li>如何求最高位的1？使用二分的思想<ol><li>首先判断高16位是否全0<ol><li>如果不是全0，那么低16位肯定是需要的，将16加到答案里去，再右移16位，接下来再去处理高16位</li><li>如果是全0，那么低16不一定需要，不用加到答案里去。接下来继续处理低16位</li></ol></li><li>接下来就是判断当前的8位。<ol><li>注意了，这里的8位有可能是原来的八位，也有可能是高16位经过右移之后变成了新的低16位的八位！</li></ol></li><li>然后就是不断的二分下去，直到只剩下一位</li><li>如果这一位是1，说明还需要1位。如果为0，则说明这一位不需要了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 如果是正数，那么直接求x的最高位1，如果是负数，则是要求最高位的0</span><br>  <span class="hljs-comment">// 假设这个最高位为第x位，则答案案为x+1位，因为正数需要加上符号0，负数需要加上符号1</span><br>  <span class="hljs-comment">// 对于负数，先预处理，将所有的1变成0，所有的0变成1</span><br>  <span class="hljs-comment">// 如果x为正数，则help为0，如果x为负数，则help为0xffffffff</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> help = x &gt;&gt; <span class="hljs-number">31</span>;<br>  <span class="hljs-comment">// 通过help将x的1变成0,0变成1。若help为0，则x不变，若help为全1，则完成转换的任务</span><br>  x = x ^ help;<br>  <span class="hljs-comment">// 下面就统一为了计算最高位的1所在的位置</span><br>  <span class="hljs-comment">// 如果高16位不为0，则has_high_16为1，否则为0</span><br>  <span class="hljs-type">int</span> has_high_16 = !!(x &gt;&gt; <span class="hljs-number">16</span>);<br>  <span class="hljs-comment">// 如果高16位存在，即has_high_16为1，那么说明低16位肯定跑不掉了，正好就是has_high_16&lt;&lt;4</span><br>  <span class="hljs-comment">// 如果高16位不存在，has_high_16为0，低16位就不一定都要，此时左移4位正好是0</span><br>  <span class="hljs-type">int</span> add_bits = has_high_16 &lt;&lt; <span class="hljs-number">4</span>;<br>  ans += add_bits;<br>  <span class="hljs-comment">// 又是一个很巧妙的操作，如果add_bits不为0，说明低16位肯定是需要的，那么就不用管低16位，直接移位</span><br>  <span class="hljs-comment">// 如果add__bits为0，说明高16位肯定不需要，低16位可能需要，那么此时右移0位，接下来正常处理低16位</span><br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_8 = !!(x &gt;&gt; <span class="hljs-number">8</span>);<br>  add_bits = has_high_8 &lt;&lt; <span class="hljs-number">3</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_4 = !!(x &gt;&gt; <span class="hljs-number">4</span>);<br>  add_bits = has_high_4 &lt;&lt; <span class="hljs-number">2</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_2 = !!(x &gt;&gt; <span class="hljs-number">2</span>);<br>  add_bits = has_high_2 &lt;&lt; <span class="hljs-number">1</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_1 = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  add_bits = has_high_1 &lt;&lt; <span class="hljs-number">0</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-comment">// x可能现在是1</span><br>  ans += x;<br><br>  <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><p>思路</p><ol><li>将一个浮点数乘2，这个浮点数以无符号整数的形式给出</li><li>uf是NaN一类指数为11111111的，直接返回</li><li>uf是非规格化数，直接将小数部分乘2</li><li>uf是规格化数，将指数加1就可以完成乘2的效果了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果uf为NaN等特殊值，即指数为全1，直接返回这个特殊值本身</span><br>  <span class="hljs-keyword">if</span> (!(e ^ <span class="hljs-number">0xff</span>)) &#123;<br>    <span class="hljs-keyword">return</span> uf;<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为非规格化的数，即指数为0，直接将f*2即可</span><br>  <span class="hljs-comment">// 这里感觉有点问题，如果这个非规格数*2后达到了规格数的范围了，是不是要额外处理？</span><br>  <span class="hljs-keyword">if</span> (!e) &#123;<br>    <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | (f &lt;&lt; <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为规格化的数</span><br>  <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | ((e + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">23</span>) | (f);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><p>思路</p><ol><li>将浮点数转为整数</li><li>如果这个浮点数超出了int的范围，直接返回0x80000000</li><li>如果这个浮点数的阶数小于0，说明还需要将小数部分除一个2的倍数，在int里肯定直接化为0了，因此直接返回0</li><li>否则的话，按具体情况对小数部分进行移位运算<ol><li>这里虽然叫小数部分，但是其实因为这个float类型的变量是用int类型给出的，因此这里的小数部分已经是默认左移23位的了。需要考虑这个因素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效位的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果指数大于等于31了，因为要返回的值是int类型，1&lt;&lt;31位直接爆int了，所以返回0x80000000u</span><br>  <span class="hljs-type">int</span> E = e - <span class="hljs-number">127</span>;<br>  <span class="hljs-keyword">if</span> (E &gt;= <span class="hljs-number">31</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果指数小于0了，那么肯定是返回0，因为需要对小数部分除2，那么对int来说，就是0</span><br>  <span class="hljs-keyword">if</span> (E &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 真正的小数部分，是有一个隐藏的1在最前面的，这里不用考虑非规格化数，因为它已经在前面的E&lt;0里给淘汰了</span><br>  <span class="hljs-type">int</span> frac = f | <span class="hljs-number">0x800000</span>;<br>  <span class="hljs-comment">// 这个小数部分是用整数来表示的，即默认左移了23位，那么当前的移位应该减去23</span><br>  <span class="hljs-type">int</span> real_f = (E &gt; <span class="hljs-number">23</span>) ? (frac &lt;&lt; (E - <span class="hljs-number">23</span>)) : (frac &gt;&gt; (<span class="hljs-number">23</span> - E));<br>  <span class="hljs-keyword">return</span> sign ? -real_f : real_f;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><p>思路</p><ol><li>将$2^x$用浮点数表示</li><li>符号位和小数部分一定是纯0，因此只需要考虑阶码</li><li>如果阶码小于等于0，直接return 0</li><li>如果阶码超过了0xff，return INF，即0x7f800000</li><li>如果正常的话，直接将阶码左移23位就得到这个浮点数了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 得到阶码</span><br>  <span class="hljs-type">int</span> e = x + <span class="hljs-number">127</span>;<br>  <span class="hljs-comment">// 非规格数，直接返回0</span><br>  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 无穷</span><br>  <span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x7f800000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 规格数，符号位0，小数部分也是0</span><br>  <span class="hljs-keyword">return</span> e &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
